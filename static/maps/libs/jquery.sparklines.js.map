{"version":3,"sources":["libs/jquery.sparklines.js"],"names":["document","Math","undefined","factory","define","amd","jQuery","sparkline","getDefaults","createClass","SPFormat","clipval","quartile","normalizeValue","normalizeValues","remove","isNumber","all","addCSS","ensureArray","formatNumber","RangeMap","MouseHandler","Tooltip","barHighlightMixin","line","UNSET_OPTION","discrete","bullet","pie","box","defaultStyles","initStyles","VShape","VCanvas_canvas","VCanvas_vml","pending","shapeCount","type","lineColor","enableTagOptions","enableHighlight","tristate","tooltipSuffix","disableHiddenCheck","VCanvas_base","spotColor","highlightSpotColor","highlightLineColor","minSpotColor","maxSpotColor","common","fillColor","defaultPixelsPerValue","width","height","composite","tagValuesAttribute","tagOptionsPrefix","highlightLighten","tooltipSkipNull","tooltipPrefix","numberFormatter","numberDigitGroupCount","numberDigitGroupSep","numberDecimalMark","disableTooltips","disableInteraction","chartRangeMin","chartRangeClip","spotRadius","lineWidth","normalRangeMin","normalRangeMax","normalRangeColor","drawNormalOnTop","-1","0","1","chartRangeMaxX","tooltipFormat","thresholdColor","thresholdValue","bar","barColor","negBarColor","stackedBarColor","zeroAxis","barWidth","barSpacing","chartRangeMax","colorMap","r","p","t","posBarColor","zeroBarColor","raw","lineHeight","target","targetColor","targetWidth","performanceColor","rangeColors","base","fields","lq","med","ro","tooltipValueLookups","borderWidth","Class","args","this","arguments","length","prototype","$","extend","_super","apply","Array","slice","call","cls","SPFormatClass","fre","precre","init","format","fclass","match","token","lookupkey","fieldvalue","prec","fieldset","replace","lookup","self","exec","lookups","get","val","min","max","spformat","values","q","vl","floor","nf","vals","i","result","filter","num","isNaN","parseFloat","isFinite","groupsize","groupsep","decsep","toString","toFixed","split","splice","join","arr","ignoreNull","isArray","css","tag","total","createStyleSheet","cssText","createElement","appendChild","body","style","WebkitAppearance","fn","simpledraw","useExisting","interact","mhandler","data","getElementsByTagName","el","getContext","canvas","namespaces","v","add","innerWidth","registerCanvas","RangeMapClass","rangelist","map","hasOwnProperty","key","indexOf","range","Infinity","cleardraw","value","push","range_map","options","$el","currentPageX","currentPageY","splist","tooltip","over","displayTooltips","highlightEnabled","sp","updateDisplay","$canvas","mouseenter","proxy","mouseleave","click","mouseclick","reset","removeTooltip","registerSparkline","e","clickEvent","Event","unbind","bind","mousemove","pageY","currentEl","updatePosition","pageX","sparklines","trigger","spcount","needsRefresh","tooltiphtml","changeEvent","offset","localX","left","localY","top","setContent","disableHighlight","render","sizeStyle","tooltipClassname","container","tooltipOffsetX","tooltipOffsetY","sizetip","id","sizetipStyle","class","offsetLeft","offsetTop","hidden","window","updateWindowDims","scrollTop","scrollLeft","content","html","appendTo","scrollRight","visibility","getSize","x","y","mousex","mousey","userValues","userOptions","each","tmp","getAttribute","$this","innerHTML","innerHeight","alert","is","parents","defaults","sparkline_display_visible","pl","done","closest","extendedOptions","tagOptionType","mergedOptions","getTagSetting","tagValCache","prefix","substr","pairs","keyval","tagOption","defaultval","_base","currentRegion","initTarget","interactive","canvasWidth","pixelHeight","disabled","getRegion","canvasHeight","setRegionHighlight","newRegion","removeHighlight","renderHighlight","changeHighlight","clearRegionHighlight","highlight","getCurrentRegionTooltip","formatlen","text","showFields","newFields","fv","formatter","fieldlen","j","header","entries","getCurrentRegionFields","formats","showFieldsKey","calcHighlightColor","color","parse","highlightColor","lighten","suffix","rgbnew","round","parseInt","mult","newShapes","shapeids","renderRegion","regionShapes","newShape","shapes","append","ids","vertices","regionMap","xvalues","yminmax","hightlightSpotId","isNull","yvalues","highlightSpot","highlightLine","vertex","drawCircle","highlightSpotId","insertAfterShape","lastShapeId","drawLine","canvasTop","removeShapeId","scanValues","isStr","valcount","highlightLineId","Number","maxy","miny","maxx","minx","drawNormalRange","rangey","ytop","processRangeOptions","rangex","yvallast","path","xpos","xposnext","last","next","yvalcount","lineShapes","fillShapes","plen","valueSpots","hlSpotsEnabled","drawRect","canvasLeft","ceil","paths","xnext","drawShape","pop","inArray","minyorg","maxyorg","getLastShapeId","isStackString","groupMin","groupMax","stackRanges","numValues","vlen","xaxisOffset","clipMin","clipMax","stacked","yoffset","stackMax","totalBarWidth","stackTotals","stackRangesNeg","svals","slen","vlist","stackMin","abs","yMaxCalc","colorMapByValue","colorMapByIndex","calcColor","valuenum","newColor","canvasHeightEf","stacknum","minPlotted","allMin","yoffsetNeg","halfHeight","interval","itemWidth","pheight","valueShapes","regiondata","shapeid","getShapeAt","fieldkey","region","shape","renderPerformance","renderRange","rn","rangeval","rangewidth","perfwidth","perfval","renderTarget","targetval","targetheight","targettop","t0","replaceWithShape","percent","newslice","renderSlice","start","end","radius","circle","PI","drawPieSlice","field","quartiles","loutlier","routlier","lwhisker","rwhisker","iqr","q1","q2","q3","unitSize","maxValue","a","b","minValue","sort","size","_pxregex","x2","_genShape","endAngle","startAngle","getElement","pixelWidth","shapetype","shapeargs","unshift","appendShape","display","verticalAlign","_calculatePixelDims","_getContext","context","strokeStyle","fillStyle","clearRect","_drawShape","moveTo","targetY","targetX","shapeseq","_drawCircle","isPointInPath","stroke","fill","_drawPieSlice","beginPath","arc","_drawRect","currentTargetShapeId","lineTo","shapemap","sid","first","replaceWithShapes","groupel","position","overflow","margin","padding","_insert","insertAdjacentHTML","group","children","rendered","initial","closed","vpath","starty","endx","endy","startx","cos","vel","sin","prerender","existing","outerHTML","removeChild"],"mappings":"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","file":"../../scripts/libs/jquery.sparklines.js","sourcesContent":["/**\n*\n* jquery.sparkline.js\n*\n* v2.1.2\n* (c) Splunk, Inc\n* Contact: Gareth Watts (gareth@splunk.com)\n* http://omnipotent.net/jquery.sparkline/\n*\n* Generates inline sparkline charts from data supplied either to the method\n* or inline in HTML\n*\n* Compatible with Internet Explorer 6.0+ and modern browsers equipped with the canvas tag\n* (Firefox 2.0+, Safari, Opera, etc)\n*\n* License: New BSD License\n*\n* Copyright (c) 2012, Splunk Inc.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*\n*     * Redistributions of source code must retain the above copyright notice,\n*       this list of conditions and the following disclaimer.\n*     * Redistributions in binary form must reproduce the above copyright notice,\n*       this list of conditions and the following disclaimer in the documentation\n*       and/or other materials provided with the distribution.\n*     * Neither the name of Splunk Inc nor the names of its contributors may\n*       be used to endorse or promote products derived from this software without\n*       specific prior written permission.\n*\n* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\n* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\n* SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT\n* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*\n*\n* Usage:\n*  $(selector).sparkline(values, options)\n*\n* If values is undefined or set to 'html' then the data values are read from the specified tag:\n*   <p>Sparkline: <span class=\"sparkline\">1,4,6,6,8,5,3,5</span></p>\n*   $('.sparkline').sparkline();\n* There must be no spaces in the enclosed data set\n*\n* Otherwise values must be an array of numbers or null values\n*    <p>Sparkline: <span id=\"sparkline1\">This text replaced if the browser is compatible</span></p>\n*    $('#sparkline1').sparkline([1,4,6,6,8,5,3,5])\n*    $('#sparkline2').sparkline([1,4,6,null,null,5,3,5])\n*\n* Values can also be specified in an HTML comment, or as a values attribute:\n*    <p>Sparkline: <span class=\"sparkline\"><!--1,4,6,6,8,5,3,5 --></span></p>\n*    <p>Sparkline: <span class=\"sparkline\" values=\"1,4,6,6,8,5,3,5\"></span></p>\n*    $('.sparkline').sparkline();\n*\n* For line charts, x values can also be specified:\n*   <p>Sparkline: <span class=\"sparkline\">1:1,2.7:4,3.4:6,5:6,6:8,8.7:5,9:3,10:5</span></p>\n*    $('#sparkline1').sparkline([ [1,1], [2.7,4], [3.4,6], [5,6], [6,8], [8.7,5], [9,3], [10,5] ])\n*\n* By default, options should be passed in as teh second argument to the sparkline function:\n*   $('.sparkline').sparkline([1,2,3,4], {type: 'bar'})\n*\n* Options can also be set by passing them on the tag itself.  This feature is disabled by default though\n* as there's a slight performance overhead:\n*   $('.sparkline').sparkline([1,2,3,4], {enableTagOptions: true})\n*   <p>Sparkline: <span class=\"sparkline\" sparkType=\"bar\" sparkBarColor=\"red\">loading</span></p>\n* Prefix all options supplied as tag attribute with \"spark\" (configurable by setting tagOptionPrefix)\n*\n* Supported options:\n*   lineColor - Color of the line used for the chart\n*   fillColor - Color used to fill in the chart - Set to '' or false for a transparent chart\n*   width - Width of the chart - Defaults to 3 times the number of values in pixels\n*   height - Height of the chart - Defaults to the height of the containing element\n*   chartRangeMin - Specify the minimum value to use for the Y range of the chart - Defaults to the minimum value supplied\n*   chartRangeMax - Specify the maximum value to use for the Y range of the chart - Defaults to the maximum value supplied\n*   chartRangeClip - Clip out of range values to the max/min specified by chartRangeMin and chartRangeMax\n*   chartRangeMinX - Specify the minimum value to use for the X range of the chart - Defaults to the minimum value supplied\n*   chartRangeMaxX - Specify the maximum value to use for the X range of the chart - Defaults to the maximum value supplied\n*   composite - If true then don't erase any existing chart attached to the tag, but draw\n*           another chart over the top - Note that width and height are ignored if an\n*           existing chart is detected.\n*   tagValuesAttribute - Name of tag attribute to check for data values - Defaults to 'values'\n*   enableTagOptions - Whether to check tags for sparkline options\n*   tagOptionPrefix - Prefix used for options supplied as tag attributes - Defaults to 'spark'\n*   disableHiddenCheck - If set to true, then the plugin will assume that charts will never be drawn into a\n*           hidden dom element, avoding a browser reflow\n*   disableInteraction - If set to true then all mouseover/click interaction behaviour will be disabled,\n*       making the plugin perform much like it did in 1.x\n*   disableTooltips - If set to true then tooltips will be disabled - Defaults to false (tooltips enabled)\n*   disableHighlight - If set to true then highlighting of selected chart elements on mouseover will be disabled\n*       defaults to false (highlights enabled)\n*   highlightLighten - Factor to lighten/darken highlighted chart values by - Defaults to 1.4 for a 40% increase\n*   tooltipContainer - Specify which DOM element the tooltip should be rendered into - defaults to document.body\n*   tooltipClassname - Optional CSS classname to apply to tooltips - If not specified then a default style will be applied\n*   tooltipOffsetX - How many pixels away from the mouse pointer to render the tooltip on the X axis\n*   tooltipOffsetY - How many pixels away from the mouse pointer to render the tooltip on the r axis\n*   tooltipFormatter  - Optional callback that allows you to override the HTML displayed in the tooltip\n*       callback is given arguments of (sparkline, options, fields)\n*   tooltipChartTitle - If specified then the tooltip uses the string specified by this setting as a title\n*   tooltipFormat - A format string or SPFormat object  (or an array thereof for multiple entries)\n*       to control the format of the tooltip\n*   tooltipPrefix - A string to prepend to each field displayed in a tooltip\n*   tooltipSuffix - A string to append to each field displayed in a tooltip\n*   tooltipSkipNull - If true then null values will not have a tooltip displayed (defaults to true)\n*   tooltipValueLookups - An object or range map to map field values to tooltip strings\n*       (eg. to map -1 to \"Lost\", 0 to \"Draw\", and 1 to \"Win\")\n*   numberFormatter - Optional callback for formatting numbers in tooltips\n*   numberDigitGroupSep - Character to use for group separator in numbers \"1,234\" - Defaults to \",\"\n*   numberDecimalMark - Character to use for the decimal point when formatting numbers - Defaults to \".\"\n*   numberDigitGroupCount - Number of digits between group separator - Defaults to 3\n*\n* There are 7 types of sparkline, selected by supplying a \"type\" option of 'line' (default),\n* 'bar', 'tristate', 'bullet', 'discrete', 'pie' or 'box'\n*    line - Line chart.  Options:\n*       spotColor - Set to '' to not end each line in a circular spot\n*       minSpotColor - If set, color of spot at minimum value\n*       maxSpotColor - If set, color of spot at maximum value\n*       spotRadius - Radius in pixels\n*       lineWidth - Width of line in pixels\n*       normalRangeMin\n*       normalRangeMax - If set draws a filled horizontal bar between these two values marking the \"normal\"\n*                      or expected range of values\n*       normalRangeColor - Color to use for the above bar\n*       drawNormalOnTop - Draw the normal range above the chart fill color if true\n*       defaultPixelsPerValue - Defaults to 3 pixels of width for each value in the chart\n*       highlightSpotColor - The color to use for drawing a highlight spot on mouseover - Set to null to disable\n*       highlightLineColor - The color to use for drawing a highlight line on mouseover - Set to null to disable\n*       valueSpots - Specify which points to draw spots on, and in which color.  Accepts a range map\n*\n*   bar - Bar chart.  Options:\n*       barColor - Color of bars for postive values\n*       negBarColor - Color of bars for negative values\n*       zeroColor - Color of bars with zero values\n*       nullColor - Color of bars with null values - Defaults to omitting the bar entirely\n*       barWidth - Width of bars in pixels\n*       colorMap - Optional mappnig of values to colors to override the *BarColor values above\n*                  can be an Array of values to control the color of individual bars or a range map\n*                  to specify colors for individual ranges of values\n*       barSpacing - Gap between bars in pixels\n*       zeroAxis - Centers the y-axis around zero if true\n*\n*   tristate - Charts values of win (>0), lose (<0) or draw (=0)\n*       posBarColor - Color of win values\n*       negBarColor - Color of lose values\n*       zeroBarColor - Color of draw values\n*       barWidth - Width of bars in pixels\n*       barSpacing - Gap between bars in pixels\n*       colorMap - Optional mappnig of values to colors to override the *BarColor values above\n*                  can be an Array of values to control the color of individual bars or a range map\n*                  to specify colors for individual ranges of values\n*\n*   discrete - Options:\n*       lineHeight - Height of each line in pixels - Defaults to 30% of the graph height\n*       thesholdValue - Values less than this value will be drawn using thresholdColor instead of lineColor\n*       thresholdColor\n*\n*   bullet - Values for bullet graphs msut be in the order: target, performance, range1, range2, range3, ...\n*       options:\n*       targetColor - The color of the vertical target marker\n*       targetWidth - The width of the target marker in pixels\n*       performanceColor - The color of the performance measure horizontal bar\n*       rangeColors - Colors to use for each qualitative range background color\n*\n*   pie - Pie chart. Options:\n*       sliceColors - An array of colors to use for pie slices\n*       offset - Angle in degrees to offset the first slice - Try -90 or +90\n*       borderWidth - Width of border to draw around the pie chart, in pixels - Defaults to 0 (no border)\n*       borderColor - Color to use for the pie chart border - Defaults to #000\n*\n*   box - Box plot. Options:\n*       raw - Set to true to supply pre-computed plot points as values\n*             values should be: low_outlier, low_whisker, q1, median, q3, high_whisker, high_outlier\n*             When set to false you can supply any number of values and the box plot will\n*             be computed for you.  Default is false.\n*       showOutliers - Set to true (default) to display outliers as circles\n*       outlierIQR - Interquartile range used to determine outliers.  Default 1.5\n*       boxLineColor - Outline color of the box\n*       boxFillColor - Fill color for the box\n*       whiskerColor - Line color used for whiskers\n*       outlierLineColor - Outline color of outlier circles\n*       outlierFillColor - Fill color of the outlier circles\n*       spotRadius - Radius of outlier circles\n*       medianColor - Line color of the median line\n*       target - Draw a target cross hair at the supplied value (default undefined)\n*\n*\n*\n*   Examples:\n*   $('#sparkline1').sparkline(myvalues, { lineColor: '#f00', fillColor: false });\n*   $('.barsparks').sparkline('html', { type:'bar', height:'40px', barWidth:5 });\n*   $('#tristate').sparkline([1,1,-1,1,0,0,-1], { type:'tristate' }):\n*   $('#discrete').sparkline([1,3,4,5,5,3,4,5], { type:'discrete' });\n*   $('#bullet').sparkline([10,12,12,9,7], { type:'bullet' });\n*   $('#pie').sparkline([1,1,2], { type:'pie' });\n*/\n\n/*jslint regexp: true, browser: true, jquery: true, white: true, nomen: false, plusplus: false, maxerr: 500, indent: 4 */\n\n(function(document, Math, undefined) { // performance/minified-size optimization\n(function(factory) {\n    if(typeof define === 'function' && define.amd) {\n        define(['jquery'], factory);\n    } else if (jQuery && !jQuery.fn.sparkline) {\n        factory(jQuery);\n    }\n}\n(function($) {\n    'use strict';\n\n    var UNSET_OPTION = {},\n        getDefaults, createClass, SPFormat, clipval, quartile, normalizeValue, normalizeValues,\n        remove, isNumber, all, sum, addCSS, ensureArray, formatNumber, RangeMap,\n        MouseHandler, Tooltip, barHighlightMixin,\n        line, bar, tristate, discrete, bullet, pie, box, defaultStyles, initStyles,\n        VShape, VCanvas_base, VCanvas_canvas, VCanvas_vml, pending, shapeCount = 0;\n\n    /**\n     * Default configuration settings\n     */\n    getDefaults = function () {\n        return {\n            // Settings common to most/all chart types\n            common: {\n                type: 'line',\n                lineColor: '#00f',\n                fillColor: '#cdf',\n                defaultPixelsPerValue: 3,\n                width: 'auto',\n                height: 'auto',\n                composite: false,\n                tagValuesAttribute: 'values',\n                tagOptionsPrefix: 'spark',\n                enableTagOptions: false,\n                enableHighlight: true,\n                highlightLighten: 1.4,\n                tooltipSkipNull: true,\n                tooltipPrefix: '',\n                tooltipSuffix: '',\n                disableHiddenCheck: false,\n                numberFormatter: false,\n                numberDigitGroupCount: 3,\n                numberDigitGroupSep: ',',\n                numberDecimalMark: '.',\n                disableTooltips: false,\n                disableInteraction: false\n            },\n            // Defaults for line charts\n            line: {\n                spotColor: '#f80',\n                highlightSpotColor: '#5f5',\n                highlightLineColor: '#f22',\n                spotRadius: 1.5,\n                minSpotColor: '#f80',\n                maxSpotColor: '#f80',\n                lineWidth: 1,\n                normalRangeMin: undefined,\n                normalRangeMax: undefined,\n                normalRangeColor: '#ccc',\n                drawNormalOnTop: false,\n                chartRangeMin: undefined,\n                chartRangeMax: undefined,\n                chartRangeMinX: undefined,\n                chartRangeMaxX: undefined,\n                tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{prefix}}{{y}}{{suffix}}')\n            },\n            // Defaults for bar charts\n            bar: {\n                barColor: '#3366cc',\n                negBarColor: '#f44',\n                stackedBarColor: ['#3366cc', '#dc3912', '#ff9900', '#109618', '#66aa00',\n                    '#dd4477', '#0099c6', '#990099'],\n                zeroColor: undefined,\n                nullColor: undefined,\n                zeroAxis: true,\n                barWidth: 4,\n                barSpacing: 1,\n                chartRangeMax: undefined,\n                chartRangeMin: undefined,\n                chartRangeClip: false,\n                colorMap: undefined,\n                tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{prefix}}{{value}}{{suffix}}')\n            },\n            // Defaults for tristate charts\n            tristate: {\n                barWidth: 4,\n                barSpacing: 1,\n                posBarColor: '#6f6',\n                negBarColor: '#f44',\n                zeroBarColor: '#999',\n                colorMap: {},\n                tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{value:map}}'),\n                tooltipValueLookups: { map: { '-1': 'Loss', '0': 'Draw', '1': 'Win' } }\n            },\n            // Defaults for discrete charts\n            discrete: {\n                lineHeight: 'auto',\n                thresholdColor: undefined,\n                thresholdValue: 0,\n                chartRangeMax: undefined,\n                chartRangeMin: undefined,\n                chartRangeClip: false,\n                tooltipFormat: new SPFormat('{{prefix}}{{value}}{{suffix}}')\n            },\n            // Defaults for bullet charts\n            bullet: {\n                targetColor: '#f33',\n                targetWidth: 3, // width of the target bar in pixels\n                performanceColor: '#33f',\n                rangeColors: ['#d3dafe', '#a8b6ff', '#7f94ff'],\n                base: undefined, // set this to a number to change the base start number\n                tooltipFormat: new SPFormat('{{fieldkey:fields}} - {{value}}'),\n                tooltipValueLookups: { fields: {r: 'Range', p: 'Performance', t: 'Target'} }\n            },\n            // Defaults for pie charts\n            pie: {\n                offset: 0,\n                sliceColors: ['#3366cc', '#dc3912', '#ff9900', '#109618', '#66aa00',\n                    '#dd4477', '#0099c6', '#990099'],\n                borderWidth: 0,\n                borderColor: '#000',\n                tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{value}} ({{percent.1}}%)')\n            },\n            // Defaults for box plots\n            box: {\n                raw: false,\n                boxLineColor: '#000',\n                boxFillColor: '#cdf',\n                whiskerColor: '#000',\n                outlierLineColor: '#333',\n                outlierFillColor: '#fff',\n                medianColor: '#f00',\n                showOutliers: true,\n                outlierIQR: 1.5,\n                spotRadius: 1.5,\n                target: undefined,\n                targetColor: '#4a2',\n                chartRangeMax: undefined,\n                chartRangeMin: undefined,\n                tooltipFormat: new SPFormat('{{field:fields}}: {{value}}'),\n                tooltipFormatFieldlistKey: 'field',\n                tooltipValueLookups: { fields: { lq: 'Lower Quartile', med: 'Median',\n                    uq: 'Upper Quartile', lo: 'Left Outlier', ro: 'Right Outlier',\n                    lw: 'Left Whisker', rw: 'Right Whisker'} }\n            }\n        };\n    };\n\n    // You can have tooltips use a css class other than jqstooltip by specifying tooltipClassname\n    defaultStyles = '.jqstooltip { ' +\n            'position: absolute;' +\n            'left: 0px;' +\n            'top: 0px;' +\n            'visibility: hidden;' +\n            'background: rgb(0, 0, 0) transparent;' +\n            'background-color: rgba(0,0,0,0.6);' +\n            'filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);' +\n            '-ms-filter: \"progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)\";' +\n            'color: white;' +\n            'font: 10px arial, san serif;' +\n            'text-align: left;' +\n            'white-space: nowrap;' +\n            'padding: 5px;' +\n            'border: 1px solid white;' +\n            'z-index: 10000;' +\n            '}' +\n            '.jqsfield { ' +\n            'color: white;' +\n            'font: 10px arial, san serif;' +\n            'text-align: left;' +\n            '}';\n\n    /**\n     * Utilities\n     */\n\n    createClass = function (/* [baseclass, [mixin, ...]], definition */) {\n        var Class, args;\n        Class = function () {\n            this.init.apply(this, arguments);\n        };\n        if (arguments.length > 1) {\n            if (arguments[0]) {\n                Class.prototype = $.extend(new arguments[0](), arguments[arguments.length - 1]);\n                Class._super = arguments[0].prototype;\n            } else {\n                Class.prototype = arguments[arguments.length - 1];\n            }\n            if (arguments.length > 2) {\n                args = Array.prototype.slice.call(arguments, 1, -1);\n                args.unshift(Class.prototype);\n                $.extend.apply($, args);\n            }\n        } else {\n            Class.prototype = arguments[0];\n        }\n        Class.prototype.cls = Class;\n        return Class;\n    };\n\n    /**\n     * Wraps a format string for tooltips\n     * {{x}}\n     * {{x.2}\n     * {{x:months}}\n     */\n    $.SPFormatClass = SPFormat = createClass({\n        fre: /\\{\\{([\\w.]+?)(:(.+?))?\\}\\}/g,\n        precre: /(\\w+)\\.(\\d+)/,\n\n        init: function (format, fclass) {\n            this.format = format;\n            this.fclass = fclass;\n        },\n\n        render: function (fieldset, lookups, options) {\n            var self = this,\n                fields = fieldset,\n                match, token, lookupkey, fieldvalue, prec;\n            return this.format.replace(this.fre, function () {\n                var lookup;\n                token = arguments[1];\n                lookupkey = arguments[3];\n                match = self.precre.exec(token);\n                if (match) {\n                    prec = match[2];\n                    token = match[1];\n                } else {\n                    prec = false;\n                }\n                fieldvalue = fields[token];\n                if (fieldvalue === undefined) {\n                    return '';\n                }\n                if (lookupkey && lookups && lookups[lookupkey]) {\n                    lookup = lookups[lookupkey];\n                    if (lookup.get) { // RangeMap\n                        return lookups[lookupkey].get(fieldvalue) || fieldvalue;\n                    } else {\n                        return lookups[lookupkey][fieldvalue] || fieldvalue;\n                    }\n                }\n                if (isNumber(fieldvalue)) {\n                    if (options.get('numberFormatter')) {\n                        fieldvalue = options.get('numberFormatter')(fieldvalue);\n                    } else {\n                        fieldvalue = formatNumber(fieldvalue, prec,\n                            options.get('numberDigitGroupCount'),\n                            options.get('numberDigitGroupSep'),\n                            options.get('numberDecimalMark'));\n                    }\n                }\n                return fieldvalue;\n            });\n        }\n    });\n\n    // convience method to avoid needing the new operator\n    $.spformat = function(format, fclass) {\n        return new SPFormat(format, fclass);\n    };\n\n    clipval = function (val, min, max) {\n        if (val < min) {\n            return min;\n        }\n        if (val > max) {\n            return max;\n        }\n        return val;\n    };\n\n    quartile = function (values, q) {\n        var vl;\n        if (q === 2) {\n            vl = Math.floor(values.length / 2);\n            return values.length % 2 ? values[vl] : (values[vl-1] + values[vl]) / 2;\n        } else {\n            if (values.length % 2 ) { // odd\n                vl = (values.length * q + q) / 4;\n                return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 : values[vl-1];\n            } else { //even\n                vl = (values.length * q + 2) / 4;\n                return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 :  values[vl-1];\n\n            }\n        }\n    };\n\n    normalizeValue = function (val) {\n        var nf;\n        switch (val) {\n            case 'undefined':\n                val = undefined;\n                break;\n            case 'null':\n                val = null;\n                break;\n            case 'true':\n                val = true;\n                break;\n            case 'false':\n                val = false;\n                break;\n            default:\n                nf = parseFloat(val);\n                if (val == nf) {\n                    val = nf;\n                }\n        }\n        return val;\n    };\n\n    normalizeValues = function (vals) {\n        var i, result = [];\n        for (i = vals.length; i--;) {\n            result[i] = normalizeValue(vals[i]);\n        }\n        return result;\n    };\n\n    remove = function (vals, filter) {\n        var i, vl, result = [];\n        for (i = 0, vl = vals.length; i < vl; i++) {\n            if (vals[i] !== filter) {\n                result.push(vals[i]);\n            }\n        }\n        return result;\n    };\n\n    isNumber = function (num) {\n        return !isNaN(parseFloat(num)) && isFinite(num);\n    };\n\n    formatNumber = function (num, prec, groupsize, groupsep, decsep) {\n        var p, i;\n        num = (prec === false ? parseFloat(num).toString() : num.toFixed(prec)).split('');\n        p = (p = $.inArray('.', num)) < 0 ? num.length : p;\n        if (p < num.length) {\n            num[p] = decsep;\n        }\n        for (i = p - groupsize; i > 0; i -= groupsize) {\n            num.splice(i, 0, groupsep);\n        }\n        return num.join('');\n    };\n\n    // determine if all values of an array match a value\n    // returns true if the array is empty\n    all = function (val, arr, ignoreNull) {\n        var i;\n        for (i = arr.length; i--; ) {\n            if (ignoreNull && arr[i] === null) continue;\n            if (arr[i] !== val) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    // sums the numeric values in an array, ignoring other values\n    sum = function (vals) {\n        var total = 0, i;\n        for (i = vals.length; i--;) {\n            total += typeof vals[i] === 'number' ? vals[i] : 0;\n        }\n        return total;\n    };\n\n    ensureArray = function (val) {\n        return $.isArray(val) ? val : [val];\n    };\n\n    // http://paulirish.com/2008/bookmarklet-inject-new-css-rules/\n    addCSS = function(css) {\n        var tag;\n        //if ('\\v' == 'v') /* ie only */ {\n        if (document.createStyleSheet) {\n            document.createStyleSheet().cssText = css;\n        } else {\n            tag = document.createElement('style');\n            tag.type = 'text/css';\n            document.getElementsByTagName('head')[0].appendChild(tag);\n            tag[(typeof document.body.style.WebkitAppearance == 'string') /* webkit only */ ? 'innerText' : 'innerHTML'] = css;\n        }\n    };\n\n    // Provide a cross-browser interface to a few simple drawing primitives\n    $.fn.simpledraw = function (width, height, useExisting, interact) {\n        var target, mhandler;\n        if (useExisting && (target = this.data('_jqs_vcanvas'))) {\n            return target;\n        }\n\n        if ($.fn.sparkline.canvas === false) {\n            // We've already determined that neither Canvas nor VML are available\n            return false;\n\n        } else if ($.fn.sparkline.canvas === undefined) {\n            // No function defined yet -- need to see if we support Canvas or VML\n            var el = document.createElement('canvas');\n            if (!!(el.getContext && el.getContext('2d'))) {\n                // Canvas is available\n                $.fn.sparkline.canvas = function(width, height, target, interact) {\n                    return new VCanvas_canvas(width, height, target, interact);\n                };\n            } else if (document.namespaces && !document.namespaces.v) {\n                // VML is available\n                document.namespaces.add('v', 'urn:schemas-microsoft-com:vml', '#default#VML');\n                $.fn.sparkline.canvas = function(width, height, target, interact) {\n                    return new VCanvas_vml(width, height, target);\n                };\n            } else {\n                // Neither Canvas nor VML are available\n                $.fn.sparkline.canvas = false;\n                return false;\n            }\n        }\n\n        if (width === undefined) {\n            width = $(this).innerWidth();\n        }\n        if (height === undefined) {\n            height = $(this).innerHeight();\n        }\n\n        target = $.fn.sparkline.canvas(width, height, this, interact);\n\n        mhandler = $(this).data('_jqs_mhandler');\n        if (mhandler) {\n            mhandler.registerCanvas(target);\n        }\n        return target;\n    };\n\n    $.fn.cleardraw = function () {\n        var target = this.data('_jqs_vcanvas');\n        if (target) {\n            target.reset();\n        }\n    };\n\n    $.RangeMapClass = RangeMap = createClass({\n        init: function (map) {\n            var key, range, rangelist = [];\n            for (key in map) {\n                if (map.hasOwnProperty(key) && typeof key === 'string' && key.indexOf(':') > -1) {\n                    range = key.split(':');\n                    range[0] = range[0].length === 0 ? -Infinity : parseFloat(range[0]);\n                    range[1] = range[1].length === 0 ? Infinity : parseFloat(range[1]);\n                    range[2] = map[key];\n                    rangelist.push(range);\n                }\n            }\n            this.map = map;\n            this.rangelist = rangelist || false;\n        },\n\n        get: function (value) {\n            var rangelist = this.rangelist,\n                i, range, result;\n            if ((result = this.map[value]) !== undefined) {\n                return result;\n            }\n            if (rangelist) {\n                for (i = rangelist.length; i--;) {\n                    range = rangelist[i];\n                    if (range[0] <= value && range[1] >= value) {\n                        return range[2];\n                    }\n                }\n            }\n            return undefined;\n        }\n    });\n\n    // Convenience function\n    $.range_map = function(map) {\n        return new RangeMap(map);\n    };\n\n    MouseHandler = createClass({\n        init: function (el, options) {\n            var $el = $(el);\n            this.$el = $el;\n            this.options = options;\n            this.currentPageX = 0;\n            this.currentPageY = 0;\n            this.el = el;\n            this.splist = [];\n            this.tooltip = null;\n            this.over = false;\n            this.displayTooltips = !options.get('disableTooltips');\n            this.highlightEnabled = !options.get('disableHighlight');\n        },\n\n        registerSparkline: function (sp) {\n            this.splist.push(sp);\n            if (this.over) {\n                this.updateDisplay();\n            }\n        },\n\n        registerCanvas: function (canvas) {\n            var $canvas = $(canvas.canvas);\n            this.canvas = canvas;\n            this.$canvas = $canvas;\n            $canvas.mouseenter($.proxy(this.mouseenter, this));\n            $canvas.mouseleave($.proxy(this.mouseleave, this));\n            $canvas.click($.proxy(this.mouseclick, this));\n        },\n\n        reset: function (removeTooltip) {\n            this.splist = [];\n            if (this.tooltip && removeTooltip) {\n                this.tooltip.remove();\n                this.tooltip = undefined;\n            }\n        },\n\n        mouseclick: function (e) {\n            var clickEvent = $.Event('sparklineClick');\n            clickEvent.originalEvent = e;\n            clickEvent.sparklines = this.splist;\n            this.$el.trigger(clickEvent);\n        },\n\n        mouseenter: function (e) {\n            $(document.body).unbind('mousemove.jqs');\n            $(document.body).bind('mousemove.jqs', $.proxy(this.mousemove, this));\n            this.over = true;\n            this.currentPageX = e.pageX;\n            this.currentPageY = e.pageY;\n            this.currentEl = e.target;\n            if (!this.tooltip && this.displayTooltips) {\n                this.tooltip = new Tooltip(this.options);\n                this.tooltip.updatePosition(e.pageX, e.pageY);\n            }\n            this.updateDisplay();\n        },\n\n        mouseleave: function () {\n            $(document.body).unbind('mousemove.jqs');\n            var splist = this.splist,\n                 spcount = splist.length,\n                 needsRefresh = false,\n                 sp, i;\n            this.over = false;\n            this.currentEl = null;\n\n            if (this.tooltip) {\n                this.tooltip.remove();\n                this.tooltip = null;\n            }\n\n            for (i = 0; i < spcount; i++) {\n                sp = splist[i];\n                if (sp.clearRegionHighlight()) {\n                    needsRefresh = true;\n                }\n            }\n\n            if (needsRefresh) {\n                this.canvas.render();\n            }\n        },\n\n        mousemove: function (e) {\n            this.currentPageX = e.pageX;\n            this.currentPageY = e.pageY;\n            this.currentEl = e.target;\n            if (this.tooltip) {\n                this.tooltip.updatePosition(e.pageX, e.pageY);\n            }\n            this.updateDisplay();\n        },\n\n        updateDisplay: function () {\n            var splist = this.splist,\n                 spcount = splist.length,\n                 needsRefresh = false,\n                 offset = this.$canvas.offset(),\n                 localX = this.currentPageX - offset.left,\n                 localY = this.currentPageY - offset.top,\n                 tooltiphtml, sp, i, result, changeEvent;\n            if (!this.over) {\n                return;\n            }\n            for (i = 0; i < spcount; i++) {\n                sp = splist[i];\n                result = sp.setRegionHighlight(this.currentEl, localX, localY);\n                if (result) {\n                    needsRefresh = true;\n                }\n            }\n            if (needsRefresh) {\n                changeEvent = $.Event('sparklineRegionChange');\n                changeEvent.sparklines = this.splist;\n                this.$el.trigger(changeEvent);\n                if (this.tooltip) {\n                    tooltiphtml = '';\n                    for (i = 0; i < spcount; i++) {\n                        sp = splist[i];\n                        tooltiphtml += sp.getCurrentRegionTooltip();\n                    }\n                    this.tooltip.setContent(tooltiphtml);\n                }\n                if (!this.disableHighlight) {\n                    this.canvas.render();\n                }\n            }\n            if (result === null) {\n                this.mouseleave();\n            }\n        }\n    });\n\n\n    Tooltip = createClass({\n        sizeStyle: 'position: static !important;' +\n            'display: block !important;' +\n            'visibility: hidden !important;' +\n            'float: left !important;',\n\n        init: function (options) {\n            var tooltipClassname = options.get('tooltipClassname', 'jqstooltip'),\n                sizetipStyle = this.sizeStyle,\n                offset;\n            this.container = options.get('tooltipContainer') || document.body;\n            this.tooltipOffsetX = options.get('tooltipOffsetX', 10);\n            this.tooltipOffsetY = options.get('tooltipOffsetY', 12);\n            // remove any previous lingering tooltip\n            $('#jqssizetip').remove();\n            $('#jqstooltip').remove();\n            this.sizetip = $('<div/>', {\n                id: 'jqssizetip',\n                style: sizetipStyle,\n                'class': tooltipClassname\n            });\n            this.tooltip = $('<div/>', {\n                id: 'jqstooltip',\n                'class': tooltipClassname\n            }).appendTo(this.container);\n            // account for the container's location\n            offset = this.tooltip.offset();\n            this.offsetLeft = offset.left;\n            this.offsetTop = offset.top;\n            this.hidden = true;\n            $(window).unbind('resize.jqs scroll.jqs');\n            $(window).bind('resize.jqs scroll.jqs', $.proxy(this.updateWindowDims, this));\n            this.updateWindowDims();\n        },\n\n        updateWindowDims: function () {\n            this.scrollTop = $(window).scrollTop();\n            this.scrollLeft = $(window).scrollLeft();\n            this.scrollRight = this.scrollLeft + $(window).width();\n            this.updatePosition();\n        },\n\n        getSize: function (content) {\n            this.sizetip.html(content).appendTo(this.container);\n            this.width = this.sizetip.width() + 1;\n            this.height = this.sizetip.height();\n            this.sizetip.remove();\n        },\n\n        setContent: function (content) {\n            if (!content) {\n                this.tooltip.css('visibility', 'hidden');\n                this.hidden = true;\n                return;\n            }\n            this.getSize(content);\n            this.tooltip.html(content)\n                .css({\n                    'width': this.width,\n                    'height': this.height,\n                    'visibility': 'visible'\n                });\n            if (this.hidden) {\n                this.hidden = false;\n                this.updatePosition();\n            }\n        },\n\n        updatePosition: function (x, y) {\n            if (x === undefined) {\n                if (this.mousex === undefined) {\n                    return;\n                }\n                x = this.mousex - this.offsetLeft;\n                y = this.mousey - this.offsetTop;\n\n            } else {\n                this.mousex = x = x - this.offsetLeft;\n                this.mousey = y = y - this.offsetTop;\n            }\n            if (!this.height || !this.width || this.hidden) {\n                return;\n            }\n\n            y -= this.height + this.tooltipOffsetY;\n            x += this.tooltipOffsetX;\n\n            if (y < this.scrollTop) {\n                y = this.scrollTop;\n            }\n            if (x < this.scrollLeft) {\n                x = this.scrollLeft;\n            } else if (x + this.width > this.scrollRight) {\n                x = this.scrollRight - this.width;\n            }\n\n            this.tooltip.css({\n                'left': x,\n                'top': y\n            });\n        },\n\n        remove: function () {\n            this.tooltip.remove();\n            this.sizetip.remove();\n            this.sizetip = this.tooltip = undefined;\n            $(window).unbind('resize.jqs scroll.jqs');\n        }\n    });\n\n    initStyles = function() {\n        addCSS(defaultStyles);\n    };\n\n    $(initStyles);\n\n    pending = [];\n    $.fn.sparkline = function (userValues, userOptions) {\n        return this.each(function () {\n            var options = new $.fn.sparkline.options(this, userOptions),\n                 $this = $(this),\n                 render, i;\n            render = function () {\n                var values, width, height, tmp, mhandler, sp, vals;\n                if (userValues === 'html' || userValues === undefined) {\n                    vals = this.getAttribute(options.get('tagValuesAttribute'));\n                    if (vals === undefined || vals === null) {\n                        vals = $this.html();\n                    }\n                    values = vals.replace(/(^\\s*<!--)|(-->\\s*$)|\\s+/g, '').split(',');\n                } else {\n                    values = userValues;\n                }\n\n                width = options.get('width') === 'auto' ? values.length * options.get('defaultPixelsPerValue') : options.get('width');\n                if (options.get('height') === 'auto') {\n                    if (!options.get('composite') || !$.data(this, '_jqs_vcanvas')) {\n                        // must be a better way to get the line height\n                        tmp = document.createElement('span');\n                        tmp.innerHTML = 'a';\n                        $this.html(tmp);\n                        height = $(tmp).innerHeight() || $(tmp).height();\n                        $(tmp).remove();\n                        tmp = null;\n                    }\n                } else {\n                    height = options.get('height');\n                }\n\n                if (!options.get('disableInteraction')) {\n                    mhandler = $.data(this, '_jqs_mhandler');\n                    if (!mhandler) {\n                        mhandler = new MouseHandler(this, options);\n                        $.data(this, '_jqs_mhandler', mhandler);\n                    } else if (!options.get('composite')) {\n                        mhandler.reset();\n                    }\n                } else {\n                    mhandler = false;\n                }\n\n                if (options.get('composite') && !$.data(this, '_jqs_vcanvas')) {\n                    if (!$.data(this, '_jqs_errnotify')) {\n                        alert('Attempted to attach a composite sparkline to an element with no existing sparkline');\n                        $.data(this, '_jqs_errnotify', true);\n                    }\n                    return;\n                }\n\n                sp = new $.fn.sparkline[options.get('type')](this, values, options, width, height);\n\n                sp.render();\n\n                if (mhandler) {\n                    mhandler.registerSparkline(sp);\n                }\n            };\n            if (($(this).html() && !options.get('disableHiddenCheck') && $(this).is(':hidden')) || !$(this).parents('body').length) {\n                if (!options.get('composite') && $.data(this, '_jqs_pending')) {\n                    // remove any existing references to the element\n                    for (i = pending.length; i; i--) {\n                        if (pending[i - 1][0] == this) {\n                            pending.splice(i - 1, 1);\n                        }\n                    }\n                }\n                pending.push([this, render]);\n                $.data(this, '_jqs_pending', true);\n            } else {\n                render.call(this);\n            }\n        });\n    };\n\n    $.fn.sparkline.defaults = getDefaults();\n\n\n    $.sparkline_display_visible = function () {\n        var el, i, pl;\n        var done = [];\n        for (i = 0, pl = pending.length; i < pl; i++) {\n            el = pending[i][0];\n            if ($(el).is(':visible') && !$(el).parents().is(':hidden')) {\n                pending[i][1].call(el);\n                $.data(pending[i][0], '_jqs_pending', false);\n                done.push(i);\n            } else if (!$(el).closest('html').length && !$.data(el, '_jqs_pending')) {\n                // element has been inserted and removed from the DOM\n                // If it was not yet inserted into the dom then the .data request\n                // will return true.\n                // removing from the dom causes the data to be removed.\n                $.data(pending[i][0], '_jqs_pending', false);\n                done.push(i);\n            }\n        }\n        for (i = done.length; i; i--) {\n            pending.splice(done[i - 1], 1);\n        }\n    };\n\n\n    /**\n     * User option handler\n     */\n    $.fn.sparkline.options = createClass({\n        init: function (tag, userOptions) {\n            var extendedOptions, defaults, base, tagOptionType;\n            this.userOptions = userOptions = userOptions || {};\n            this.tag = tag;\n            this.tagValCache = {};\n            defaults = $.fn.sparkline.defaults;\n            base = defaults.common;\n            this.tagOptionsPrefix = userOptions.enableTagOptions && (userOptions.tagOptionsPrefix || base.tagOptionsPrefix);\n\n            tagOptionType = this.getTagSetting('type');\n            if (tagOptionType === UNSET_OPTION) {\n                extendedOptions = defaults[userOptions.type || base.type];\n            } else {\n                extendedOptions = defaults[tagOptionType];\n            }\n            this.mergedOptions = $.extend({}, base, extendedOptions, userOptions);\n        },\n\n\n        getTagSetting: function (key) {\n            var prefix = this.tagOptionsPrefix,\n                val, i, pairs, keyval;\n            if (prefix === false || prefix === undefined) {\n                return UNSET_OPTION;\n            }\n            if (this.tagValCache.hasOwnProperty(key)) {\n                val = this.tagValCache.key;\n            } else {\n                val = this.tag.getAttribute(prefix + key);\n                if (val === undefined || val === null) {\n                    val = UNSET_OPTION;\n                } else if (val.substr(0, 1) === '[') {\n                    val = val.substr(1, val.length - 2).split(',');\n                    for (i = val.length; i--;) {\n                        val[i] = normalizeValue(val[i].replace(/(^\\s*)|(\\s*$)/g, ''));\n                    }\n                } else if (val.substr(0, 1) === '{') {\n                    pairs = val.substr(1, val.length - 2).split(',');\n                    val = {};\n                    for (i = pairs.length; i--;) {\n                        keyval = pairs[i].split(':', 2);\n                        val[keyval[0].replace(/(^\\s*)|(\\s*$)/g, '')] = normalizeValue(keyval[1].replace(/(^\\s*)|(\\s*$)/g, ''));\n                    }\n                } else {\n                    val = normalizeValue(val);\n                }\n                this.tagValCache.key = val;\n            }\n            return val;\n        },\n\n        get: function (key, defaultval) {\n            var tagOption = this.getTagSetting(key),\n                result;\n            if (tagOption !== UNSET_OPTION) {\n                return tagOption;\n            }\n            return (result = this.mergedOptions[key]) === undefined ? defaultval : result;\n        }\n    });\n\n\n    $.fn.sparkline._base = createClass({\n        disabled: false,\n\n        init: function (el, values, options, width, height) {\n            this.el = el;\n            this.$el = $(el);\n            this.values = values;\n            this.options = options;\n            this.width = width;\n            this.height = height;\n            this.currentRegion = undefined;\n        },\n\n        /**\n         * Setup the canvas\n         */\n        initTarget: function () {\n            var interactive = !this.options.get('disableInteraction');\n            if (!(this.target = this.$el.simpledraw(this.width, this.height, this.options.get('composite'), interactive))) {\n                this.disabled = true;\n            } else {\n                this.canvasWidth = this.target.pixelWidth;\n                this.canvasHeight = this.target.pixelHeight;\n            }\n        },\n\n        /**\n         * Actually render the chart to the canvas\n         */\n        render: function () {\n            if (this.disabled) {\n                this.el.innerHTML = '';\n                return false;\n            }\n            return true;\n        },\n\n        /**\n         * Return a region id for a given x/y co-ordinate\n         */\n        getRegion: function (x, y) {\n        },\n\n        /**\n         * Highlight an item based on the moused-over x,y co-ordinate\n         */\n        setRegionHighlight: function (el, x, y) {\n            var currentRegion = this.currentRegion,\n                highlightEnabled = !this.options.get('disableHighlight'),\n                newRegion;\n            if (x > this.canvasWidth || y > this.canvasHeight || x < 0 || y < 0) {\n                return null;\n            }\n            newRegion = this.getRegion(el, x, y);\n            if (currentRegion !== newRegion) {\n                if (currentRegion !== undefined && highlightEnabled) {\n                    this.removeHighlight();\n                }\n                this.currentRegion = newRegion;\n                if (newRegion !== undefined && highlightEnabled) {\n                    this.renderHighlight();\n                }\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Reset any currently highlighted item\n         */\n        clearRegionHighlight: function () {\n            if (this.currentRegion !== undefined) {\n                this.removeHighlight();\n                this.currentRegion = undefined;\n                return true;\n            }\n            return false;\n        },\n\n        renderHighlight: function () {\n            this.changeHighlight(true);\n        },\n\n        removeHighlight: function () {\n            this.changeHighlight(false);\n        },\n\n        changeHighlight: function (highlight)  {},\n\n        /**\n         * Fetch the HTML to display as a tooltip\n         */\n        getCurrentRegionTooltip: function () {\n            var options = this.options,\n                header = '',\n                entries = [],\n                fields, formats, formatlen, fclass, text, i,\n                showFields, showFieldsKey, newFields, fv,\n                formatter, format, fieldlen, j;\n            if (this.currentRegion === undefined) {\n                return '';\n            }\n            fields = this.getCurrentRegionFields();\n            formatter = options.get('tooltipFormatter');\n            if (formatter) {\n                return formatter(this, options, fields);\n            }\n            if (options.get('tooltipChartTitle')) {\n                header += '<div class=\"jqs jqstitle\">' + options.get('tooltipChartTitle') + '</div>\\n';\n            }\n            formats = this.options.get('tooltipFormat');\n            if (!formats) {\n                return '';\n            }\n            if (!$.isArray(formats)) {\n                formats = [formats];\n            }\n            if (!$.isArray(fields)) {\n                fields = [fields];\n            }\n            showFields = this.options.get('tooltipFormatFieldlist');\n            showFieldsKey = this.options.get('tooltipFormatFieldlistKey');\n            if (showFields && showFieldsKey) {\n                // user-selected ordering of fields\n                newFields = [];\n                for (i = fields.length; i--;) {\n                    fv = fields[i][showFieldsKey];\n                    if ((j = $.inArray(fv, showFields)) != -1) {\n                        newFields[j] = fields[i];\n                    }\n                }\n                fields = newFields;\n            }\n            formatlen = formats.length;\n            fieldlen = fields.length;\n            for (i = 0; i < formatlen; i++) {\n                format = formats[i];\n                if (typeof format === 'string') {\n                    format = new SPFormat(format);\n                }\n                fclass = format.fclass || 'jqsfield';\n                for (j = 0; j < fieldlen; j++) {\n                    if (!fields[j].isNull || !options.get('tooltipSkipNull')) {\n                        $.extend(fields[j], {\n                            prefix: options.get('tooltipPrefix'),\n                            suffix: options.get('tooltipSuffix')\n                        });\n                        text = format.render(fields[j], options.get('tooltipValueLookups'), options);\n                        entries.push('<div class=\"' + fclass + '\">' + text + '</div>');\n                    }\n                }\n            }\n            if (entries.length) {\n                return header + entries.join('\\n');\n            }\n            return '';\n        },\n\n        getCurrentRegionFields: function () {},\n\n        calcHighlightColor: function (color, options) {\n            var highlightColor = options.get('highlightColor'),\n                lighten = options.get('highlightLighten'),\n                parse, mult, rgbnew, i;\n            if (highlightColor) {\n                return highlightColor;\n            }\n            if (lighten) {\n                // extract RGB values\n                parse = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(color) || /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color);\n                if (parse) {\n                    rgbnew = [];\n                    mult = color.length === 4 ? 16 : 1;\n                    for (i = 0; i < 3; i++) {\n                        rgbnew[i] = clipval(Math.round(parseInt(parse[i + 1], 16) * mult * lighten), 0, 255);\n                    }\n                    return 'rgb(' + rgbnew.join(',') + ')';\n                }\n\n            }\n            return color;\n        }\n\n    });\n\n    barHighlightMixin = {\n        changeHighlight: function (highlight) {\n            var currentRegion = this.currentRegion,\n                target = this.target,\n                shapeids = this.regionShapes[currentRegion],\n                newShapes;\n            // will be null if the region value was null\n            if (shapeids) {\n                newShapes = this.renderRegion(currentRegion, highlight);\n                if ($.isArray(newShapes) || $.isArray(shapeids)) {\n                    target.replaceWithShapes(shapeids, newShapes);\n                    this.regionShapes[currentRegion] = $.map(newShapes, function (newShape) {\n                        return newShape.id;\n                    });\n                } else {\n                    target.replaceWithShape(shapeids, newShapes);\n                    this.regionShapes[currentRegion] = newShapes.id;\n                }\n            }\n        },\n\n        render: function () {\n            var values = this.values,\n                target = this.target,\n                regionShapes = this.regionShapes,\n                shapes, ids, i, j;\n\n            if (!this.cls._super.render.call(this)) {\n                return;\n            }\n            for (i = values.length; i--;) {\n                shapes = this.renderRegion(i);\n                if (shapes) {\n                    if ($.isArray(shapes)) {\n                        ids = [];\n                        for (j = shapes.length; j--;) {\n                            shapes[j].append();\n                            ids.push(shapes[j].id);\n                        }\n                        regionShapes[i] = ids;\n                    } else {\n                        shapes.append();\n                        regionShapes[i] = shapes.id; // store just the shapeid\n                    }\n                } else {\n                    // null value\n                    regionShapes[i] = null;\n                }\n            }\n            target.render();\n        }\n    };\n\n    /**\n     * Line charts\n     */\n    $.fn.sparkline.line = line = createClass($.fn.sparkline._base, {\n        type: 'line',\n\n        init: function (el, values, options, width, height) {\n            line._super.init.call(this, el, values, options, width, height);\n            this.vertices = [];\n            this.regionMap = [];\n            this.xvalues = [];\n            this.yvalues = [];\n            this.yminmax = [];\n            this.hightlightSpotId = null;\n            this.lastShapeId = null;\n            this.initTarget();\n        },\n\n        getRegion: function (el, x, y) {\n            var i,\n                regionMap = this.regionMap; // maps regions to value positions\n            for (i = regionMap.length; i--;) {\n                if (regionMap[i] !== null && x >= regionMap[i][0] && x <= regionMap[i][1]) {\n                    return regionMap[i][2];\n                }\n            }\n            return undefined;\n        },\n\n        getCurrentRegionFields: function () {\n            var currentRegion = this.currentRegion;\n            return {\n                isNull: this.yvalues[currentRegion] === null,\n                x: this.xvalues[currentRegion],\n                y: this.yvalues[currentRegion],\n                color: this.options.get('lineColor'),\n                fillColor: this.options.get('fillColor'),\n                offset: currentRegion\n            };\n        },\n\n        renderHighlight: function () {\n            var currentRegion = this.currentRegion,\n                target = this.target,\n                vertex = this.vertices[currentRegion],\n                options = this.options,\n                spotRadius = options.get('spotRadius'),\n                highlightSpotColor = options.get('highlightSpotColor'),\n                highlightLineColor = options.get('highlightLineColor'),\n                highlightSpot, highlightLine;\n\n            if (!vertex) {\n                return;\n            }\n            if (spotRadius && highlightSpotColor) {\n                highlightSpot = target.drawCircle(vertex[0], vertex[1],\n                    spotRadius, undefined, highlightSpotColor);\n                this.highlightSpotId = highlightSpot.id;\n                target.insertAfterShape(this.lastShapeId, highlightSpot);\n            }\n            if (highlightLineColor) {\n                highlightLine = target.drawLine(vertex[0], this.canvasTop, vertex[0],\n                    this.canvasTop + this.canvasHeight, highlightLineColor);\n                this.highlightLineId = highlightLine.id;\n                target.insertAfterShape(this.lastShapeId, highlightLine);\n            }\n        },\n\n        removeHighlight: function () {\n            var target = this.target;\n            if (this.highlightSpotId) {\n                target.removeShapeId(this.highlightSpotId);\n                this.highlightSpotId = null;\n            }\n            if (this.highlightLineId) {\n                target.removeShapeId(this.highlightLineId);\n                this.highlightLineId = null;\n            }\n        },\n\n        scanValues: function () {\n            var values = this.values,\n                valcount = values.length,\n                xvalues = this.xvalues,\n                yvalues = this.yvalues,\n                yminmax = this.yminmax,\n                i, val, isStr, isArray, sp;\n            for (i = 0; i < valcount; i++) {\n                val = values[i];\n                isStr = typeof(values[i]) === 'string';\n                isArray = typeof(values[i]) === 'object' && values[i] instanceof Array;\n                sp = isStr && values[i].split(':');\n                if (isStr && sp.length === 2) { // x:y\n                    xvalues.push(Number(sp[0]));\n                    yvalues.push(Number(sp[1]));\n                    yminmax.push(Number(sp[1]));\n                } else if (isArray) {\n                    xvalues.push(val[0]);\n                    yvalues.push(val[1]);\n                    yminmax.push(val[1]);\n                } else {\n                    xvalues.push(i);\n                    if (values[i] === null || values[i] === 'null') {\n                        yvalues.push(null);\n                    } else {\n                        yvalues.push(Number(val));\n                        yminmax.push(Number(val));\n                    }\n                }\n            }\n            if (this.options.get('xvalues')) {\n                xvalues = this.options.get('xvalues');\n            }\n\n            this.maxy = this.maxyorg = Math.max.apply(Math, yminmax);\n            this.miny = this.minyorg = Math.min.apply(Math, yminmax);\n\n            this.maxx = Math.max.apply(Math, xvalues);\n            this.minx = Math.min.apply(Math, xvalues);\n\n            this.xvalues = xvalues;\n            this.yvalues = yvalues;\n            this.yminmax = yminmax;\n\n        },\n\n        processRangeOptions: function () {\n            var options = this.options,\n                normalRangeMin = options.get('normalRangeMin'),\n                normalRangeMax = options.get('normalRangeMax');\n\n            if (normalRangeMin !== undefined) {\n                if (normalRangeMin < this.miny) {\n                    this.miny = normalRangeMin;\n                }\n                if (normalRangeMax > this.maxy) {\n                    this.maxy = normalRangeMax;\n                }\n            }\n            if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < this.miny)) {\n                this.miny = options.get('chartRangeMin');\n            }\n            if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > this.maxy)) {\n                this.maxy = options.get('chartRangeMax');\n            }\n            if (options.get('chartRangeMinX') !== undefined && (options.get('chartRangeClipX') || options.get('chartRangeMinX') < this.minx)) {\n                this.minx = options.get('chartRangeMinX');\n            }\n            if (options.get('chartRangeMaxX') !== undefined && (options.get('chartRangeClipX') || options.get('chartRangeMaxX') > this.maxx)) {\n                this.maxx = options.get('chartRangeMaxX');\n            }\n\n        },\n\n        drawNormalRange: function (canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey) {\n            var normalRangeMin = this.options.get('normalRangeMin'),\n                normalRangeMax = this.options.get('normalRangeMax'),\n                ytop = canvasTop + Math.round(canvasHeight - (canvasHeight * ((normalRangeMax - this.miny) / rangey))),\n                height = Math.round((canvasHeight * (normalRangeMax - normalRangeMin)) / rangey);\n            this.target.drawRect(canvasLeft, ytop, canvasWidth, height, undefined, this.options.get('normalRangeColor')).append();\n        },\n\n        render: function () {\n            var options = this.options,\n                target = this.target,\n                canvasWidth = this.canvasWidth,\n                canvasHeight = this.canvasHeight,\n                vertices = this.vertices,\n                spotRadius = options.get('spotRadius'),\n                regionMap = this.regionMap,\n                rangex, rangey, yvallast,\n                canvasTop, canvasLeft,\n                vertex, path, paths, x, y, xnext, xpos, xposnext,\n                last, next, yvalcount, lineShapes, fillShapes, plen,\n                valueSpots, hlSpotsEnabled, color, xvalues, yvalues, i;\n\n            if (!line._super.render.call(this)) {\n                return;\n            }\n\n            this.scanValues();\n            this.processRangeOptions();\n\n            xvalues = this.xvalues;\n            yvalues = this.yvalues;\n\n            if (!this.yminmax.length || this.yvalues.length < 2) {\n                // empty or all null valuess\n                return;\n            }\n\n            canvasTop = canvasLeft = 0;\n\n            rangex = this.maxx - this.minx === 0 ? 1 : this.maxx - this.minx;\n            rangey = this.maxy - this.miny === 0 ? 1 : this.maxy - this.miny;\n            yvallast = this.yvalues.length - 1;\n\n            if (spotRadius && (canvasWidth < (spotRadius * 4) || canvasHeight < (spotRadius * 4))) {\n                spotRadius = 0;\n            }\n            if (spotRadius) {\n                // adjust the canvas size as required so that spots will fit\n                hlSpotsEnabled = options.get('highlightSpotColor') &&  !options.get('disableInteraction');\n                if (hlSpotsEnabled || options.get('minSpotColor') || (options.get('spotColor') && yvalues[yvallast] === this.miny)) {\n                    canvasHeight -= Math.ceil(spotRadius);\n                }\n                if (hlSpotsEnabled || options.get('maxSpotColor') || (options.get('spotColor') && yvalues[yvallast] === this.maxy)) {\n                    canvasHeight -= Math.ceil(spotRadius);\n                    canvasTop += Math.ceil(spotRadius);\n                }\n                if (hlSpotsEnabled ||\n                     ((options.get('minSpotColor') || options.get('maxSpotColor')) && (yvalues[0] === this.miny || yvalues[0] === this.maxy))) {\n                    canvasLeft += Math.ceil(spotRadius);\n                    canvasWidth -= Math.ceil(spotRadius);\n                }\n                if (hlSpotsEnabled || options.get('spotColor') ||\n                    (options.get('minSpotColor') || options.get('maxSpotColor') &&\n                        (yvalues[yvallast] === this.miny || yvalues[yvallast] === this.maxy))) {\n                    canvasWidth -= Math.ceil(spotRadius);\n                }\n            }\n\n\n            canvasHeight--;\n\n            if (options.get('normalRangeMin') !== undefined && !options.get('drawNormalOnTop')) {\n                this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);\n            }\n\n            path = [];\n            paths = [path];\n            last = next = null;\n            yvalcount = yvalues.length;\n            for (i = 0; i < yvalcount; i++) {\n                x = xvalues[i];\n                xnext = xvalues[i + 1];\n                y = yvalues[i];\n                xpos = canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex));\n                xposnext = i < yvalcount - 1 ? canvasLeft + Math.round((xnext - this.minx) * (canvasWidth / rangex)) : canvasWidth;\n                next = xpos + ((xposnext - xpos) / 2);\n                regionMap[i] = [last || 0, next, i];\n                last = next;\n                if (y === null) {\n                    if (i) {\n                        if (yvalues[i - 1] !== null) {\n                            path = [];\n                            paths.push(path);\n                        }\n                        vertices.push(null);\n                    }\n                } else {\n                    if (y < this.miny) {\n                        y = this.miny;\n                    }\n                    if (y > this.maxy) {\n                        y = this.maxy;\n                    }\n                    if (!path.length) {\n                        // previous value was null\n                        path.push([xpos, canvasTop + canvasHeight]);\n                    }\n                    vertex = [xpos, canvasTop + Math.round(canvasHeight - (canvasHeight * ((y - this.miny) / rangey)))];\n                    path.push(vertex);\n                    vertices.push(vertex);\n                }\n            }\n\n            lineShapes = [];\n            fillShapes = [];\n            plen = paths.length;\n            for (i = 0; i < plen; i++) {\n                path = paths[i];\n                if (path.length) {\n                    if (options.get('fillColor')) {\n                        path.push([path[path.length - 1][0], (canvasTop + canvasHeight)]);\n                        fillShapes.push(path.slice(0));\n                        path.pop();\n                    }\n                    // if there's only a single point in this path, then we want to display it\n                    // as a vertical line which means we keep path[0]  as is\n                    if (path.length > 2) {\n                        // else we want the first value\n                        path[0] = [path[0][0], path[1][1]];\n                    }\n                    lineShapes.push(path);\n                }\n            }\n\n            // draw the fill first, then optionally the normal range, then the line on top of that\n            plen = fillShapes.length;\n            for (i = 0; i < plen; i++) {\n                target.drawShape(fillShapes[i],\n                    options.get('fillColor'), options.get('fillColor')).append();\n            }\n\n            if (options.get('normalRangeMin') !== undefined && options.get('drawNormalOnTop')) {\n                this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);\n            }\n\n            plen = lineShapes.length;\n            for (i = 0; i < plen; i++) {\n                target.drawShape(lineShapes[i], options.get('lineColor'), undefined,\n                    options.get('lineWidth')).append();\n            }\n\n            if (spotRadius && options.get('valueSpots')) {\n                valueSpots = options.get('valueSpots');\n                if (valueSpots.get === undefined) {\n                    valueSpots = new RangeMap(valueSpots);\n                }\n                for (i = 0; i < yvalcount; i++) {\n                    color = valueSpots.get(yvalues[i]);\n                    if (color) {\n                        target.drawCircle(canvasLeft + Math.round((xvalues[i] - this.minx) * (canvasWidth / rangex)),\n                            canvasTop + Math.round(canvasHeight - (canvasHeight * ((yvalues[i] - this.miny) / rangey))),\n                            spotRadius, undefined,\n                            color).append();\n                    }\n                }\n\n            }\n            if (spotRadius && options.get('spotColor') && yvalues[yvallast] !== null) {\n                target.drawCircle(canvasLeft + Math.round((xvalues[xvalues.length - 1] - this.minx) * (canvasWidth / rangex)),\n                    canvasTop + Math.round(canvasHeight - (canvasHeight * ((yvalues[yvallast] - this.miny) / rangey))),\n                    spotRadius, undefined,\n                    options.get('spotColor')).append();\n            }\n            if (this.maxy !== this.minyorg) {\n                if (spotRadius && options.get('minSpotColor')) {\n                    x = xvalues[$.inArray(this.minyorg, yvalues)];\n                    target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)),\n                        canvasTop + Math.round(canvasHeight - (canvasHeight * ((this.minyorg - this.miny) / rangey))),\n                        spotRadius, undefined,\n                        options.get('minSpotColor')).append();\n                }\n                if (spotRadius && options.get('maxSpotColor')) {\n                    x = xvalues[$.inArray(this.maxyorg, yvalues)];\n                    target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)),\n                        canvasTop + Math.round(canvasHeight - (canvasHeight * ((this.maxyorg - this.miny) / rangey))),\n                        spotRadius, undefined,\n                        options.get('maxSpotColor')).append();\n                }\n            }\n\n            this.lastShapeId = target.getLastShapeId();\n            this.canvasTop = canvasTop;\n            target.render();\n        }\n    });\n\n    /**\n     * Bar charts\n     */\n    $.fn.sparkline.bar = bar = createClass($.fn.sparkline._base, barHighlightMixin, {\n        type: 'bar',\n\n        init: function (el, values, options, width, height) {\n            var barWidth = parseInt(options.get('barWidth'), 10),\n                barSpacing = parseInt(options.get('barSpacing'), 10),\n                chartRangeMin = options.get('chartRangeMin'),\n                chartRangeMax = options.get('chartRangeMax'),\n                chartRangeClip = options.get('chartRangeClip'),\n                stackMin = Infinity,\n                stackMax = -Infinity,\n                isStackString, groupMin, groupMax, stackRanges,\n                numValues, i, vlen, range, zeroAxis, xaxisOffset, min, max, clipMin, clipMax,\n                stacked, vlist, j, slen, svals, val, yoffset, yMaxCalc, canvasHeightEf;\n            bar._super.init.call(this, el, values, options, width, height);\n\n            // scan values to determine whether to stack bars\n            for (i = 0, vlen = values.length; i < vlen; i++) {\n                val = values[i];\n                isStackString = typeof(val) === 'string' && val.indexOf(':') > -1;\n                if (isStackString || $.isArray(val)) {\n                    stacked = true;\n                    if (isStackString) {\n                        val = values[i] = normalizeValues(val.split(':'));\n                    }\n                    val = remove(val, null); // min/max will treat null as zero\n                    groupMin = Math.min.apply(Math, val);\n                    groupMax = Math.max.apply(Math, val);\n                    if (groupMin < stackMin) {\n                        stackMin = groupMin;\n                    }\n                    if (groupMax > stackMax) {\n                        stackMax = groupMax;\n                    }\n                }\n            }\n\n            this.stacked = stacked;\n            this.regionShapes = {};\n            this.barWidth = barWidth;\n            this.barSpacing = barSpacing;\n            this.totalBarWidth = barWidth + barSpacing;\n            this.width = width = (values.length * barWidth) + ((values.length - 1) * barSpacing);\n\n            this.initTarget();\n\n            if (chartRangeClip) {\n                clipMin = chartRangeMin === undefined ? -Infinity : chartRangeMin;\n                clipMax = chartRangeMax === undefined ? Infinity : chartRangeMax;\n            }\n\n            numValues = [];\n            stackRanges = stacked ? [] : numValues;\n            var stackTotals = [];\n            var stackRangesNeg = [];\n            for (i = 0, vlen = values.length; i < vlen; i++) {\n                if (stacked) {\n                    vlist = values[i];\n                    values[i] = svals = [];\n                    stackTotals[i] = 0;\n                    stackRanges[i] = stackRangesNeg[i] = 0;\n                    for (j = 0, slen = vlist.length; j < slen; j++) {\n                        val = svals[j] = chartRangeClip ? clipval(vlist[j], clipMin, clipMax) : vlist[j];\n                        if (val !== null) {\n                            if (val > 0) {\n                                stackTotals[i] += val;\n                            }\n                            if (stackMin < 0 && stackMax > 0) {\n                                if (val < 0) {\n                                    stackRangesNeg[i] += Math.abs(val);\n                                } else {\n                                    stackRanges[i] += val;\n                                }\n                            } else {\n                                stackRanges[i] += Math.abs(val - (val < 0 ? stackMax : stackMin));\n                            }\n                            numValues.push(val);\n                        }\n                    }\n                } else {\n                    val = chartRangeClip ? clipval(values[i], clipMin, clipMax) : values[i];\n                    val = values[i] = normalizeValue(val);\n                    if (val !== null) {\n                        numValues.push(val);\n                    }\n                }\n            }\n            this.max = max = Math.max.apply(Math, numValues);\n            this.min = min = Math.min.apply(Math, numValues);\n            this.stackMax = stackMax = stacked ? Math.max.apply(Math, stackTotals) : max;\n            this.stackMin = stackMin = stacked ? Math.min.apply(Math, numValues) : min;\n\n            if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < min)) {\n                min = options.get('chartRangeMin');\n            }\n            if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > max)) {\n                max = options.get('chartRangeMax');\n            }\n\n            this.zeroAxis = zeroAxis = options.get('zeroAxis', true);\n            if (min <= 0 && max >= 0 && zeroAxis) {\n                xaxisOffset = 0;\n            } else if (zeroAxis == false) {\n                xaxisOffset = min;\n            } else if (min > 0) {\n                xaxisOffset = min;\n            } else {\n                xaxisOffset = max;\n            }\n            this.xaxisOffset = xaxisOffset;\n\n            range = stacked ? (Math.max.apply(Math, stackRanges) + Math.max.apply(Math, stackRangesNeg)) : max - min;\n\n            // as we plot zero/min values a single pixel line, we add a pixel to all other\n            // values - Reduce the effective canvas size to suit\n            this.canvasHeightEf = (zeroAxis && min < 0) ? this.canvasHeight - 2 : this.canvasHeight - 1;\n\n            if (min < xaxisOffset) {\n                yMaxCalc = (stacked && max >= 0) ? stackMax : max;\n                yoffset = (yMaxCalc - xaxisOffset) / range * this.canvasHeight;\n                if (yoffset !== Math.ceil(yoffset)) {\n                    this.canvasHeightEf -= 2;\n                    yoffset = Math.ceil(yoffset);\n                }\n            } else {\n                yoffset = this.canvasHeight;\n            }\n            this.yoffset = yoffset;\n\n            if ($.isArray(options.get('colorMap'))) {\n                this.colorMapByIndex = options.get('colorMap');\n                this.colorMapByValue = null;\n            } else {\n                this.colorMapByIndex = null;\n                this.colorMapByValue = options.get('colorMap');\n                if (this.colorMapByValue && this.colorMapByValue.get === undefined) {\n                    this.colorMapByValue = new RangeMap(this.colorMapByValue);\n                }\n            }\n\n            this.range = range;\n        },\n\n        getRegion: function (el, x, y) {\n            var result = Math.floor(x / this.totalBarWidth);\n            return (result < 0 || result >= this.values.length) ? undefined : result;\n        },\n\n        getCurrentRegionFields: function () {\n            var currentRegion = this.currentRegion,\n                values = ensureArray(this.values[currentRegion]),\n                result = [],\n                value, i;\n            for (i = values.length; i--;) {\n                value = values[i];\n                result.push({\n                    isNull: value === null,\n                    value: value,\n                    color: this.calcColor(i, value, currentRegion),\n                    offset: currentRegion\n                });\n            }\n            return result;\n        },\n\n        calcColor: function (stacknum, value, valuenum) {\n            var colorMapByIndex = this.colorMapByIndex,\n                colorMapByValue = this.colorMapByValue,\n                options = this.options,\n                color, newColor;\n            if (this.stacked) {\n                color = options.get('stackedBarColor');\n            } else {\n                color = (value < 0) ? options.get('negBarColor') : options.get('barColor');\n            }\n            if (value === 0 && options.get('zeroColor') !== undefined) {\n                color = options.get('zeroColor');\n            }\n            if (colorMapByValue && (newColor = colorMapByValue.get(value))) {\n                color = newColor;\n            } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {\n                color = colorMapByIndex[valuenum];\n            }\n            return $.isArray(color) ? color[stacknum % color.length] : color;\n        },\n\n        /**\n         * Render bar(s) for a region\n         */\n        renderRegion: function (valuenum, highlight) {\n            var vals = this.values[valuenum],\n                options = this.options,\n                xaxisOffset = this.xaxisOffset,\n                result = [],\n                range = this.range,\n                stacked = this.stacked,\n                target = this.target,\n                x = valuenum * this.totalBarWidth,\n                canvasHeightEf = this.canvasHeightEf,\n                yoffset = this.yoffset,\n                y, height, color, isNull, yoffsetNeg, i, valcount, val, minPlotted, allMin;\n\n            vals = $.isArray(vals) ? vals : [vals];\n            valcount = vals.length;\n            val = vals[0];\n            isNull = all(null, vals);\n            allMin = all(xaxisOffset, vals, true);\n\n            if (isNull) {\n                if (options.get('nullColor')) {\n                    color = highlight ? options.get('nullColor') : this.calcHighlightColor(options.get('nullColor'), options);\n                    y = (yoffset > 0) ? yoffset - 1 : yoffset;\n                    return target.drawRect(x, y, this.barWidth - 1, 0, color, color);\n                } else {\n                    return undefined;\n                }\n            }\n            yoffsetNeg = yoffset;\n            for (i = 0; i < valcount; i++) {\n                val = vals[i];\n\n                if (stacked && val === xaxisOffset) {\n                    if (!allMin || minPlotted) {\n                        continue;\n                    }\n                    minPlotted = true;\n                }\n\n                if (range > 0) {\n                    height = Math.floor(canvasHeightEf * ((Math.abs(val - xaxisOffset) / range))) + 1;\n                } else {\n                    height = 1;\n                }\n                if (val < xaxisOffset || (val === xaxisOffset && yoffset === 0)) {\n                    y = yoffsetNeg;\n                    yoffsetNeg += height;\n                } else {\n                    y = yoffset - height;\n                    yoffset -= height;\n                }\n                color = this.calcColor(i, val, valuenum);\n                if (highlight) {\n                    color = this.calcHighlightColor(color, options);\n                }\n                result.push(target.drawRect(x, y, this.barWidth - 1, height - 1, color, color));\n            }\n            if (result.length === 1) {\n                return result[0];\n            }\n            return result;\n        }\n    });\n\n    /**\n     * Tristate charts\n     */\n    $.fn.sparkline.tristate = tristate = createClass($.fn.sparkline._base, barHighlightMixin, {\n        type: 'tristate',\n\n        init: function (el, values, options, width, height) {\n            var barWidth = parseInt(options.get('barWidth'), 10),\n                barSpacing = parseInt(options.get('barSpacing'), 10);\n            tristate._super.init.call(this, el, values, options, width, height);\n\n            this.regionShapes = {};\n            this.barWidth = barWidth;\n            this.barSpacing = barSpacing;\n            this.totalBarWidth = barWidth + barSpacing;\n            this.values = $.map(values, Number);\n            this.width = width = (values.length * barWidth) + ((values.length - 1) * barSpacing);\n\n            if ($.isArray(options.get('colorMap'))) {\n                this.colorMapByIndex = options.get('colorMap');\n                this.colorMapByValue = null;\n            } else {\n                this.colorMapByIndex = null;\n                this.colorMapByValue = options.get('colorMap');\n                if (this.colorMapByValue && this.colorMapByValue.get === undefined) {\n                    this.colorMapByValue = new RangeMap(this.colorMapByValue);\n                }\n            }\n            this.initTarget();\n        },\n\n        getRegion: function (el, x, y) {\n            return Math.floor(x / this.totalBarWidth);\n        },\n\n        getCurrentRegionFields: function () {\n            var currentRegion = this.currentRegion;\n            return {\n                isNull: this.values[currentRegion] === undefined,\n                value: this.values[currentRegion],\n                color: this.calcColor(this.values[currentRegion], currentRegion),\n                offset: currentRegion\n            };\n        },\n\n        calcColor: function (value, valuenum) {\n            var values = this.values,\n                options = this.options,\n                colorMapByIndex = this.colorMapByIndex,\n                colorMapByValue = this.colorMapByValue,\n                color, newColor;\n\n            if (colorMapByValue && (newColor = colorMapByValue.get(value))) {\n                color = newColor;\n            } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {\n                color = colorMapByIndex[valuenum];\n            } else if (values[valuenum] < 0) {\n                color = options.get('negBarColor');\n            } else if (values[valuenum] > 0) {\n                color = options.get('posBarColor');\n            } else {\n                color = options.get('zeroBarColor');\n            }\n            return color;\n        },\n\n        renderRegion: function (valuenum, highlight) {\n            var values = this.values,\n                options = this.options,\n                target = this.target,\n                canvasHeight, height, halfHeight,\n                x, y, color;\n\n            canvasHeight = target.pixelHeight;\n            halfHeight = Math.round(canvasHeight / 2);\n\n            x = valuenum * this.totalBarWidth;\n            if (values[valuenum] < 0) {\n                y = halfHeight;\n                height = halfHeight - 1;\n            } else if (values[valuenum] > 0) {\n                y = 0;\n                height = halfHeight - 1;\n            } else {\n                y = halfHeight - 1;\n                height = 2;\n            }\n            color = this.calcColor(values[valuenum], valuenum);\n            if (color === null) {\n                return;\n            }\n            if (highlight) {\n                color = this.calcHighlightColor(color, options);\n            }\n            return target.drawRect(x, y, this.barWidth - 1, height - 1, color, color);\n        }\n    });\n\n    /**\n     * Discrete charts\n     */\n    $.fn.sparkline.discrete = discrete = createClass($.fn.sparkline._base, barHighlightMixin, {\n        type: 'discrete',\n\n        init: function (el, values, options, width, height) {\n            discrete._super.init.call(this, el, values, options, width, height);\n\n            this.regionShapes = {};\n            this.values = values = $.map(values, Number);\n            this.min = Math.min.apply(Math, values);\n            this.max = Math.max.apply(Math, values);\n            this.range = this.max - this.min;\n            this.width = width = options.get('width') === 'auto' ? values.length * 2 : this.width;\n            this.interval = Math.floor(width / values.length);\n            this.itemWidth = width / values.length;\n            if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < this.min)) {\n                this.min = options.get('chartRangeMin');\n            }\n            if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > this.max)) {\n                this.max = options.get('chartRangeMax');\n            }\n            this.initTarget();\n            if (this.target) {\n                this.lineHeight = options.get('lineHeight') === 'auto' ? Math.round(this.canvasHeight * 0.3) : options.get('lineHeight');\n            }\n        },\n\n        getRegion: function (el, x, y) {\n            return Math.floor(x / this.itemWidth);\n        },\n\n        getCurrentRegionFields: function () {\n            var currentRegion = this.currentRegion;\n            return {\n                isNull: this.values[currentRegion] === undefined,\n                value: this.values[currentRegion],\n                offset: currentRegion\n            };\n        },\n\n        renderRegion: function (valuenum, highlight) {\n            var values = this.values,\n                options = this.options,\n                min = this.min,\n                max = this.max,\n                range = this.range,\n                interval = this.interval,\n                target = this.target,\n                canvasHeight = this.canvasHeight,\n                lineHeight = this.lineHeight,\n                pheight = canvasHeight - lineHeight,\n                ytop, val, color, x;\n\n            val = clipval(values[valuenum], min, max);\n            x = valuenum * interval;\n            ytop = Math.round(pheight - pheight * ((val - min) / range));\n            color = (options.get('thresholdColor') && val < options.get('thresholdValue')) ? options.get('thresholdColor') : options.get('lineColor');\n            if (highlight) {\n                color = this.calcHighlightColor(color, options);\n            }\n            return target.drawLine(x, ytop, x, ytop + lineHeight, color);\n        }\n    });\n\n    /**\n     * Bullet charts\n     */\n    $.fn.sparkline.bullet = bullet = createClass($.fn.sparkline._base, {\n        type: 'bullet',\n\n        init: function (el, values, options, width, height) {\n            var min, max, vals;\n            bullet._super.init.call(this, el, values, options, width, height);\n\n            // values: target, performance, range1, range2, range3\n            this.values = values = normalizeValues(values);\n            // target or performance could be null\n            vals = values.slice();\n            vals[0] = vals[0] === null ? vals[2] : vals[0];\n            vals[1] = values[1] === null ? vals[2] : vals[1];\n            min = Math.min.apply(Math, values);\n            max = Math.max.apply(Math, values);\n            if (options.get('base') === undefined) {\n                min = min < 0 ? min : 0;\n            } else {\n                min = options.get('base');\n            }\n            this.min = min;\n            this.max = max;\n            this.range = max - min;\n            this.shapes = {};\n            this.valueShapes = {};\n            this.regiondata = {};\n            this.width = width = options.get('width') === 'auto' ? '4.0em' : width;\n            this.target = this.$el.simpledraw(width, height, options.get('composite'));\n            if (!values.length) {\n                this.disabled = true;\n            }\n            this.initTarget();\n        },\n\n        getRegion: function (el, x, y) {\n            var shapeid = this.target.getShapeAt(el, x, y);\n            return (shapeid !== undefined && this.shapes[shapeid] !== undefined) ? this.shapes[shapeid] : undefined;\n        },\n\n        getCurrentRegionFields: function () {\n            var currentRegion = this.currentRegion;\n            return {\n                fieldkey: currentRegion.substr(0, 1),\n                value: this.values[currentRegion.substr(1)],\n                region: currentRegion\n            };\n        },\n\n        changeHighlight: function (highlight) {\n            var currentRegion = this.currentRegion,\n                shapeid = this.valueShapes[currentRegion],\n                shape;\n            delete this.shapes[shapeid];\n            switch (currentRegion.substr(0, 1)) {\n                case 'r':\n                    shape = this.renderRange(currentRegion.substr(1), highlight);\n                    break;\n                case 'p':\n                    shape = this.renderPerformance(highlight);\n                    break;\n                case 't':\n                    shape = this.renderTarget(highlight);\n                    break;\n            }\n            this.valueShapes[currentRegion] = shape.id;\n            this.shapes[shape.id] = currentRegion;\n            this.target.replaceWithShape(shapeid, shape);\n        },\n\n        renderRange: function (rn, highlight) {\n            var rangeval = this.values[rn],\n                rangewidth = Math.round(this.canvasWidth * ((rangeval - this.min) / this.range)),\n                color = this.options.get('rangeColors')[rn - 2];\n            if (highlight) {\n                color = this.calcHighlightColor(color, this.options);\n            }\n            return this.target.drawRect(0, 0, rangewidth - 1, this.canvasHeight - 1, color, color);\n        },\n\n        renderPerformance: function (highlight) {\n            var perfval = this.values[1],\n                perfwidth = Math.round(this.canvasWidth * ((perfval - this.min) / this.range)),\n                color = this.options.get('performanceColor');\n            if (highlight) {\n                color = this.calcHighlightColor(color, this.options);\n            }\n            return this.target.drawRect(0, Math.round(this.canvasHeight * 0.3), perfwidth - 1,\n                Math.round(this.canvasHeight * 0.4) - 1, color, color);\n        },\n\n        renderTarget: function (highlight) {\n            var targetval = this.values[0],\n                x = Math.round(this.canvasWidth * ((targetval - this.min) / this.range) - (this.options.get('targetWidth') / 2)),\n                targettop = Math.round(this.canvasHeight * 0.10),\n                targetheight = this.canvasHeight - (targettop * 2),\n                color = this.options.get('targetColor');\n            if (highlight) {\n                color = this.calcHighlightColor(color, this.options);\n            }\n            return this.target.drawRect(x, targettop, this.options.get('targetWidth') - 1, targetheight - 1, color, color);\n        },\n\n        render: function () {\n            var vlen = this.values.length,\n                target = this.target,\n                i, shape;\n            if (!bullet._super.render.call(this)) {\n                return;\n            }\n            for (i = 2; i < vlen; i++) {\n                shape = this.renderRange(i).append();\n                this.shapes[shape.id] = 'r' + i;\n                this.valueShapes['r' + i] = shape.id;\n            }\n            if (this.values[1] !== null) {\n                shape = this.renderPerformance().append();\n                this.shapes[shape.id] = 'p1';\n                this.valueShapes.p1 = shape.id;\n            }\n            if (this.values[0] !== null) {\n                shape = this.renderTarget().append();\n                this.shapes[shape.id] = 't0';\n                this.valueShapes.t0 = shape.id;\n            }\n            target.render();\n        }\n    });\n\n    /**\n     * Pie charts\n     */\n    $.fn.sparkline.pie = pie = createClass($.fn.sparkline._base, {\n        type: 'pie',\n\n        init: function (el, values, options, width, height) {\n            var total = 0, i;\n\n            pie._super.init.call(this, el, values, options, width, height);\n\n            this.shapes = {}; // map shape ids to value offsets\n            this.valueShapes = {}; // maps value offsets to shape ids\n            this.values = values = $.map(values, Number);\n\n            if (options.get('width') === 'auto') {\n                this.width = this.height;\n            }\n\n            if (values.length > 0) {\n                for (i = values.length; i--;) {\n                    total += values[i];\n                }\n            }\n            this.total = total;\n            this.initTarget();\n            this.radius = Math.floor(Math.min(this.canvasWidth, this.canvasHeight) / 2);\n        },\n\n        getRegion: function (el, x, y) {\n            var shapeid = this.target.getShapeAt(el, x, y);\n            return (shapeid !== undefined && this.shapes[shapeid] !== undefined) ? this.shapes[shapeid] : undefined;\n        },\n\n        getCurrentRegionFields: function () {\n            var currentRegion = this.currentRegion;\n            return {\n                isNull: this.values[currentRegion] === undefined,\n                value: this.values[currentRegion],\n                percent: this.values[currentRegion] / this.total * 100,\n                color: this.options.get('sliceColors')[currentRegion % this.options.get('sliceColors').length],\n                offset: currentRegion\n            };\n        },\n\n        changeHighlight: function (highlight) {\n            var currentRegion = this.currentRegion,\n                 newslice = this.renderSlice(currentRegion, highlight),\n                 shapeid = this.valueShapes[currentRegion];\n            delete this.shapes[shapeid];\n            this.target.replaceWithShape(shapeid, newslice);\n            this.valueShapes[currentRegion] = newslice.id;\n            this.shapes[newslice.id] = currentRegion;\n        },\n\n        renderSlice: function (valuenum, highlight) {\n            var target = this.target,\n                options = this.options,\n                radius = this.radius,\n                borderWidth = options.get('borderWidth'),\n                offset = options.get('offset'),\n                circle = 2 * Math.PI,\n                values = this.values,\n                total = this.total,\n                next = offset ? (2*Math.PI)*(offset/360) : 0,\n                start, end, i, vlen, color;\n\n            vlen = values.length;\n            for (i = 0; i < vlen; i++) {\n                start = next;\n                end = next;\n                if (total > 0) {  // avoid divide by zero\n                    end = next + (circle * (values[i] / total));\n                }\n                if (valuenum === i) {\n                    color = options.get('sliceColors')[i % options.get('sliceColors').length];\n                    if (highlight) {\n                        color = this.calcHighlightColor(color, options);\n                    }\n\n                    return target.drawPieSlice(radius, radius, radius - borderWidth, start, end, undefined, color);\n                }\n                next = end;\n            }\n        },\n\n        render: function () {\n            var target = this.target,\n                values = this.values,\n                options = this.options,\n                radius = this.radius,\n                borderWidth = options.get('borderWidth'),\n                shape, i;\n\n            if (!pie._super.render.call(this)) {\n                return;\n            }\n            if (borderWidth) {\n                target.drawCircle(radius, radius, Math.floor(radius - (borderWidth / 2)),\n                    options.get('borderColor'), undefined, borderWidth).append();\n            }\n            for (i = values.length; i--;) {\n                if (values[i]) { // don't render zero values\n                    shape = this.renderSlice(i).append();\n                    this.valueShapes[i] = shape.id; // store just the shapeid\n                    this.shapes[shape.id] = i;\n                }\n            }\n            target.render();\n        }\n    });\n\n    /**\n     * Box plots\n     */\n    $.fn.sparkline.box = box = createClass($.fn.sparkline._base, {\n        type: 'box',\n\n        init: function (el, values, options, width, height) {\n            box._super.init.call(this, el, values, options, width, height);\n            this.values = $.map(values, Number);\n            this.width = options.get('width') === 'auto' ? '4.0em' : width;\n            this.initTarget();\n            if (!this.values.length) {\n                this.disabled = 1;\n            }\n        },\n\n        /**\n         * Simulate a single region\n         */\n        getRegion: function () {\n            return 1;\n        },\n\n        getCurrentRegionFields: function () {\n            var result = [\n                { field: 'lq', value: this.quartiles[0] },\n                { field: 'med', value: this.quartiles[1] },\n                { field: 'uq', value: this.quartiles[2] }\n            ];\n            if (this.loutlier !== undefined) {\n                result.push({ field: 'lo', value: this.loutlier});\n            }\n            if (this.routlier !== undefined) {\n                result.push({ field: 'ro', value: this.routlier});\n            }\n            if (this.lwhisker !== undefined) {\n                result.push({ field: 'lw', value: this.lwhisker});\n            }\n            if (this.rwhisker !== undefined) {\n                result.push({ field: 'rw', value: this.rwhisker});\n            }\n            return result;\n        },\n\n        render: function () {\n            var target = this.target,\n                values = this.values,\n                vlen = values.length,\n                options = this.options,\n                canvasWidth = this.canvasWidth,\n                canvasHeight = this.canvasHeight,\n                minValue = options.get('chartRangeMin') === undefined ? Math.min.apply(Math, values) : options.get('chartRangeMin'),\n                maxValue = options.get('chartRangeMax') === undefined ? Math.max.apply(Math, values) : options.get('chartRangeMax'),\n                canvasLeft = 0,\n                lwhisker, loutlier, iqr, q1, q2, q3, rwhisker, routlier, i,\n                size, unitSize;\n\n            if (!box._super.render.call(this)) {\n                return;\n            }\n\n            if (options.get('raw')) {\n                if (options.get('showOutliers') && values.length > 5) {\n                    loutlier = values[0];\n                    lwhisker = values[1];\n                    q1 = values[2];\n                    q2 = values[3];\n                    q3 = values[4];\n                    rwhisker = values[5];\n                    routlier = values[6];\n                } else {\n                    lwhisker = values[0];\n                    q1 = values[1];\n                    q2 = values[2];\n                    q3 = values[3];\n                    rwhisker = values[4];\n                }\n            } else {\n                values.sort(function (a, b) { return a - b; });\n                q1 = quartile(values, 1);\n                q2 = quartile(values, 2);\n                q3 = quartile(values, 3);\n                iqr = q3 - q1;\n                if (options.get('showOutliers')) {\n                    lwhisker = rwhisker = undefined;\n                    for (i = 0; i < vlen; i++) {\n                        if (lwhisker === undefined && values[i] > q1 - (iqr * options.get('outlierIQR'))) {\n                            lwhisker = values[i];\n                        }\n                        if (values[i] < q3 + (iqr * options.get('outlierIQR'))) {\n                            rwhisker = values[i];\n                        }\n                    }\n                    loutlier = values[0];\n                    routlier = values[vlen - 1];\n                } else {\n                    lwhisker = values[0];\n                    rwhisker = values[vlen - 1];\n                }\n            }\n            this.quartiles = [q1, q2, q3];\n            this.lwhisker = lwhisker;\n            this.rwhisker = rwhisker;\n            this.loutlier = loutlier;\n            this.routlier = routlier;\n\n            unitSize = canvasWidth / (maxValue - minValue + 1);\n            if (options.get('showOutliers')) {\n                canvasLeft = Math.ceil(options.get('spotRadius'));\n                canvasWidth -= 2 * Math.ceil(options.get('spotRadius'));\n                unitSize = canvasWidth / (maxValue - minValue + 1);\n                if (loutlier < lwhisker) {\n                    target.drawCircle((loutlier - minValue) * unitSize + canvasLeft,\n                        canvasHeight / 2,\n                        options.get('spotRadius'),\n                        options.get('outlierLineColor'),\n                        options.get('outlierFillColor')).append();\n                }\n                if (routlier > rwhisker) {\n                    target.drawCircle((routlier - minValue) * unitSize + canvasLeft,\n                        canvasHeight / 2,\n                        options.get('spotRadius'),\n                        options.get('outlierLineColor'),\n                        options.get('outlierFillColor')).append();\n                }\n            }\n\n            // box\n            target.drawRect(\n                Math.round((q1 - minValue) * unitSize + canvasLeft),\n                Math.round(canvasHeight * 0.1),\n                Math.round((q3 - q1) * unitSize),\n                Math.round(canvasHeight * 0.8),\n                options.get('boxLineColor'),\n                options.get('boxFillColor')).append();\n            // left whisker\n            target.drawLine(\n                Math.round((lwhisker - minValue) * unitSize + canvasLeft),\n                Math.round(canvasHeight / 2),\n                Math.round((q1 - minValue) * unitSize + canvasLeft),\n                Math.round(canvasHeight / 2),\n                options.get('lineColor')).append();\n            target.drawLine(\n                Math.round((lwhisker - minValue) * unitSize + canvasLeft),\n                Math.round(canvasHeight / 4),\n                Math.round((lwhisker - minValue) * unitSize + canvasLeft),\n                Math.round(canvasHeight - canvasHeight / 4),\n                options.get('whiskerColor')).append();\n            // right whisker\n            target.drawLine(Math.round((rwhisker - minValue) * unitSize + canvasLeft),\n                Math.round(canvasHeight / 2),\n                Math.round((q3 - minValue) * unitSize + canvasLeft),\n                Math.round(canvasHeight / 2),\n                options.get('lineColor')).append();\n            target.drawLine(\n                Math.round((rwhisker - minValue) * unitSize + canvasLeft),\n                Math.round(canvasHeight / 4),\n                Math.round((rwhisker - minValue) * unitSize + canvasLeft),\n                Math.round(canvasHeight - canvasHeight / 4),\n                options.get('whiskerColor')).append();\n            // median line\n            target.drawLine(\n                Math.round((q2 - minValue) * unitSize + canvasLeft),\n                Math.round(canvasHeight * 0.1),\n                Math.round((q2 - minValue) * unitSize + canvasLeft),\n                Math.round(canvasHeight * 0.9),\n                options.get('medianColor')).append();\n            if (options.get('target')) {\n                size = Math.ceil(options.get('spotRadius'));\n                target.drawLine(\n                    Math.round((options.get('target') - minValue) * unitSize + canvasLeft),\n                    Math.round((canvasHeight / 2) - size),\n                    Math.round((options.get('target') - minValue) * unitSize + canvasLeft),\n                    Math.round((canvasHeight / 2) + size),\n                    options.get('targetColor')).append();\n                target.drawLine(\n                    Math.round((options.get('target') - minValue) * unitSize + canvasLeft - size),\n                    Math.round(canvasHeight / 2),\n                    Math.round((options.get('target') - minValue) * unitSize + canvasLeft + size),\n                    Math.round(canvasHeight / 2),\n                    options.get('targetColor')).append();\n            }\n            target.render();\n        }\n    });\n\n    // Setup a very simple \"virtual canvas\" to make drawing the few shapes we need easier\n    // This is accessible as $(foo).simpledraw()\n\n    VShape = createClass({\n        init: function (target, id, type, args) {\n            this.target = target;\n            this.id = id;\n            this.type = type;\n            this.args = args;\n        },\n        append: function () {\n            this.target.appendShape(this);\n            return this;\n        }\n    });\n\n    VCanvas_base = createClass({\n        _pxregex: /(\\d+)(px)?\\s*$/i,\n\n        init: function (width, height, target) {\n            if (!width) {\n                return;\n            }\n            this.width = width;\n            this.height = height;\n            this.target = target;\n            this.lastShapeId = null;\n            if (target[0]) {\n                target = target[0];\n            }\n            $.data(target, '_jqs_vcanvas', this);\n        },\n\n        drawLine: function (x1, y1, x2, y2, lineColor, lineWidth) {\n            return this.drawShape([[x1, y1], [x2, y2]], lineColor, lineWidth);\n        },\n\n        drawShape: function (path, lineColor, fillColor, lineWidth) {\n            return this._genShape('Shape', [path, lineColor, fillColor, lineWidth]);\n        },\n\n        drawCircle: function (x, y, radius, lineColor, fillColor, lineWidth) {\n            return this._genShape('Circle', [x, y, radius, lineColor, fillColor, lineWidth]);\n        },\n\n        drawPieSlice: function (x, y, radius, startAngle, endAngle, lineColor, fillColor) {\n            return this._genShape('PieSlice', [x, y, radius, startAngle, endAngle, lineColor, fillColor]);\n        },\n\n        drawRect: function (x, y, width, height, lineColor, fillColor) {\n            return this._genShape('Rect', [x, y, width, height, lineColor, fillColor]);\n        },\n\n        getElement: function () {\n            return this.canvas;\n        },\n\n        /**\n         * Return the most recently inserted shape id\n         */\n        getLastShapeId: function () {\n            return this.lastShapeId;\n        },\n\n        /**\n         * Clear and reset the canvas\n         */\n        reset: function () {\n            alert('reset not implemented');\n        },\n\n        _insert: function (el, target) {\n            $(target).html(el);\n        },\n\n        /**\n         * Calculate the pixel dimensions of the canvas\n         */\n        _calculatePixelDims: function (width, height, canvas) {\n            // XXX This should probably be a configurable option\n            var match;\n            match = this._pxregex.exec(height);\n            if (match) {\n                this.pixelHeight = match[1];\n            } else {\n                this.pixelHeight = $(canvas).height();\n            }\n            match = this._pxregex.exec(width);\n            if (match) {\n                this.pixelWidth = match[1];\n            } else {\n                this.pixelWidth = $(canvas).width();\n            }\n        },\n\n        /**\n         * Generate a shape object and id for later rendering\n         */\n        _genShape: function (shapetype, shapeargs) {\n            var id = shapeCount++;\n            shapeargs.unshift(id);\n            return new VShape(this, id, shapetype, shapeargs);\n        },\n\n        /**\n         * Add a shape to the end of the render queue\n         */\n        appendShape: function (shape) {\n            alert('appendShape not implemented');\n        },\n\n        /**\n         * Replace one shape with another\n         */\n        replaceWithShape: function (shapeid, shape) {\n            alert('replaceWithShape not implemented');\n        },\n\n        /**\n         * Insert one shape after another in the render queue\n         */\n        insertAfterShape: function (shapeid, shape) {\n            alert('insertAfterShape not implemented');\n        },\n\n        /**\n         * Remove a shape from the queue\n         */\n        removeShapeId: function (shapeid) {\n            alert('removeShapeId not implemented');\n        },\n\n        /**\n         * Find a shape at the specified x/y co-ordinates\n         */\n        getShapeAt: function (el, x, y) {\n            alert('getShapeAt not implemented');\n        },\n\n        /**\n         * Render all queued shapes onto the canvas\n         */\n        render: function () {\n            alert('render not implemented');\n        }\n    });\n\n    VCanvas_canvas = createClass(VCanvas_base, {\n        init: function (width, height, target, interact) {\n            VCanvas_canvas._super.init.call(this, width, height, target);\n            this.canvas = document.createElement('canvas');\n            if (target[0]) {\n                target = target[0];\n            }\n            $.data(target, '_jqs_vcanvas', this);\n            $(this.canvas).css({ display: 'inline-block', width: width, height: height, verticalAlign: 'top' });\n            this._insert(this.canvas, target);\n            this._calculatePixelDims(width, height, this.canvas);\n            this.canvas.width = this.pixelWidth;\n            this.canvas.height = this.pixelHeight;\n            this.interact = interact;\n            this.shapes = {};\n            this.shapeseq = [];\n            this.currentTargetShapeId = undefined;\n            $(this.canvas).css({width: this.pixelWidth, height: this.pixelHeight});\n        },\n\n        _getContext: function (lineColor, fillColor, lineWidth) {\n            var context = this.canvas.getContext('2d');\n            if (lineColor !== undefined) {\n                context.strokeStyle = lineColor;\n            }\n            context.lineWidth = lineWidth === undefined ? 1 : lineWidth;\n            if (fillColor !== undefined) {\n                context.fillStyle = fillColor;\n            }\n            return context;\n        },\n\n        reset: function () {\n            var context = this._getContext();\n            context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);\n            this.shapes = {};\n            this.shapeseq = [];\n            this.currentTargetShapeId = undefined;\n        },\n\n        _drawShape: function (shapeid, path, lineColor, fillColor, lineWidth) {\n            var context = this._getContext(lineColor, fillColor, lineWidth),\n                i, plen;\n            context.beginPath();\n            context.moveTo(path[0][0] + 0.5, path[0][1] + 0.5);\n            for (i = 1, plen = path.length; i < plen; i++) {\n                context.lineTo(path[i][0] + 0.5, path[i][1] + 0.5); // the 0.5 offset gives us crisp pixel-width lines\n            }\n            if (lineColor !== undefined) {\n                context.stroke();\n            }\n            if (fillColor !== undefined) {\n                context.fill();\n            }\n            if (this.targetX !== undefined && this.targetY !== undefined &&\n                context.isPointInPath(this.targetX, this.targetY)) {\n                this.currentTargetShapeId = shapeid;\n            }\n        },\n\n        _drawCircle: function (shapeid, x, y, radius, lineColor, fillColor, lineWidth) {\n            var context = this._getContext(lineColor, fillColor, lineWidth);\n            context.beginPath();\n            context.arc(x, y, radius, 0, 2 * Math.PI, false);\n            if (this.targetX !== undefined && this.targetY !== undefined &&\n                context.isPointInPath(this.targetX, this.targetY)) {\n                this.currentTargetShapeId = shapeid;\n            }\n            if (lineColor !== undefined) {\n                context.stroke();\n            }\n            if (fillColor !== undefined) {\n                context.fill();\n            }\n        },\n\n        _drawPieSlice: function (shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {\n            var context = this._getContext(lineColor, fillColor);\n            context.beginPath();\n            context.moveTo(x, y);\n            context.arc(x, y, radius, startAngle, endAngle, false);\n            context.lineTo(x, y);\n            context.closePath();\n            if (lineColor !== undefined) {\n                context.stroke();\n            }\n            if (fillColor) {\n                context.fill();\n            }\n            if (this.targetX !== undefined && this.targetY !== undefined &&\n                context.isPointInPath(this.targetX, this.targetY)) {\n                this.currentTargetShapeId = shapeid;\n            }\n        },\n\n        _drawRect: function (shapeid, x, y, width, height, lineColor, fillColor) {\n            return this._drawShape(shapeid, [[x, y], [x + width, y], [x + width, y + height], [x, y + height], [x, y]], lineColor, fillColor);\n        },\n\n        appendShape: function (shape) {\n            this.shapes[shape.id] = shape;\n            this.shapeseq.push(shape.id);\n            this.lastShapeId = shape.id;\n            return shape.id;\n        },\n\n        replaceWithShape: function (shapeid, shape) {\n            var shapeseq = this.shapeseq,\n                i;\n            this.shapes[shape.id] = shape;\n            for (i = shapeseq.length; i--;) {\n                if (shapeseq[i] == shapeid) {\n                    shapeseq[i] = shape.id;\n                }\n            }\n            delete this.shapes[shapeid];\n        },\n\n        replaceWithShapes: function (shapeids, shapes) {\n            var shapeseq = this.shapeseq,\n                shapemap = {},\n                sid, i, first;\n\n            for (i = shapeids.length; i--;) {\n                shapemap[shapeids[i]] = true;\n            }\n            for (i = shapeseq.length; i--;) {\n                sid = shapeseq[i];\n                if (shapemap[sid]) {\n                    shapeseq.splice(i, 1);\n                    delete this.shapes[sid];\n                    first = i;\n                }\n            }\n            for (i = shapes.length; i--;) {\n                shapeseq.splice(first, 0, shapes[i].id);\n                this.shapes[shapes[i].id] = shapes[i];\n            }\n\n        },\n\n        insertAfterShape: function (shapeid, shape) {\n            var shapeseq = this.shapeseq,\n                i;\n            for (i = shapeseq.length; i--;) {\n                if (shapeseq[i] === shapeid) {\n                    shapeseq.splice(i + 1, 0, shape.id);\n                    this.shapes[shape.id] = shape;\n                    return;\n                }\n            }\n        },\n\n        removeShapeId: function (shapeid) {\n            var shapeseq = this.shapeseq,\n                i;\n            for (i = shapeseq.length; i--;) {\n                if (shapeseq[i] === shapeid) {\n                    shapeseq.splice(i, 1);\n                    break;\n                }\n            }\n            delete this.shapes[shapeid];\n        },\n\n        getShapeAt: function (el, x, y) {\n            this.targetX = x;\n            this.targetY = y;\n            this.render();\n            return this.currentTargetShapeId;\n        },\n\n        render: function () {\n            var shapeseq = this.shapeseq,\n                shapes = this.shapes,\n                shapeCount = shapeseq.length,\n                context = this._getContext(),\n                shapeid, shape, i;\n            context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);\n            for (i = 0; i < shapeCount; i++) {\n                shapeid = shapeseq[i];\n                shape = shapes[shapeid];\n                this['_draw' + shape.type].apply(this, shape.args);\n            }\n            if (!this.interact) {\n                // not interactive so no need to keep the shapes array\n                this.shapes = {};\n                this.shapeseq = [];\n            }\n        }\n\n    });\n\n    VCanvas_vml = createClass(VCanvas_base, {\n        init: function (width, height, target) {\n            var groupel;\n            VCanvas_vml._super.init.call(this, width, height, target);\n            if (target[0]) {\n                target = target[0];\n            }\n            $.data(target, '_jqs_vcanvas', this);\n            this.canvas = document.createElement('span');\n            $(this.canvas).css({ display: 'inline-block', position: 'relative', overflow: 'hidden', width: width, height: height, margin: '0px', padding: '0px', verticalAlign: 'top'});\n            this._insert(this.canvas, target);\n            this._calculatePixelDims(width, height, this.canvas);\n            this.canvas.width = this.pixelWidth;\n            this.canvas.height = this.pixelHeight;\n            groupel = '<v:group coordorigin=\"0 0\" coordsize=\"' + this.pixelWidth + ' ' + this.pixelHeight + '\"' +\n                    ' style=\"position:absolute;top:0;left:0;width:' + this.pixelWidth + 'px;height=' + this.pixelHeight + 'px;\"></v:group>';\n            this.canvas.insertAdjacentHTML('beforeEnd', groupel);\n            this.group = $(this.canvas).children()[0];\n            this.rendered = false;\n            this.prerender = '';\n        },\n\n        _drawShape: function (shapeid, path, lineColor, fillColor, lineWidth) {\n            var vpath = [],\n                initial, stroke, fill, closed, vel, plen, i;\n            for (i = 0, plen = path.length; i < plen; i++) {\n                vpath[i] = '' + (path[i][0]) + ',' + (path[i][1]);\n            }\n            initial = vpath.splice(0, 1);\n            lineWidth = lineWidth === undefined ? 1 : lineWidth;\n            stroke = lineColor === undefined ? ' stroked=\"false\" ' : ' strokeWeight=\"' + lineWidth + 'px\" strokeColor=\"' + lineColor + '\" ';\n            fill = fillColor === undefined ? ' filled=\"false\"' : ' fillColor=\"' + fillColor + '\" filled=\"true\" ';\n            closed = vpath[0] === vpath[vpath.length - 1] ? 'x ' : '';\n            vel = '<v:shape coordorigin=\"0 0\" coordsize=\"' + this.pixelWidth + ' ' + this.pixelHeight + '\" ' +\n                 ' id=\"jqsshape' + shapeid + '\" ' +\n                 stroke +\n                 fill +\n                ' style=\"position:absolute;left:0px;top:0px;height:' + this.pixelHeight + 'px;width:' + this.pixelWidth + 'px;padding:0px;margin:0px;\" ' +\n                ' path=\"m ' + initial + ' l ' + vpath.join(', ') + ' ' + closed + 'e\">' +\n                ' </v:shape>';\n            return vel;\n        },\n\n        _drawCircle: function (shapeid, x, y, radius, lineColor, fillColor, lineWidth) {\n            var stroke, fill, vel;\n            x -= radius;\n            y -= radius;\n            stroke = lineColor === undefined ? ' stroked=\"false\" ' : ' strokeWeight=\"' + lineWidth + 'px\" strokeColor=\"' + lineColor + '\" ';\n            fill = fillColor === undefined ? ' filled=\"false\"' : ' fillColor=\"' + fillColor + '\" filled=\"true\" ';\n            vel = '<v:oval ' +\n                 ' id=\"jqsshape' + shapeid + '\" ' +\n                stroke +\n                fill +\n                ' style=\"position:absolute;top:' + y + 'px; left:' + x + 'px; width:' + (radius * 2) + 'px; height:' + (radius * 2) + 'px\"></v:oval>';\n            return vel;\n\n        },\n\n        _drawPieSlice: function (shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {\n            var vpath, startx, starty, endx, endy, stroke, fill, vel;\n            if (startAngle === endAngle) {\n                return '';  // VML seems to have problem when start angle equals end angle.\n            }\n            if ((endAngle - startAngle) === (2 * Math.PI)) {\n                startAngle = 0.0;  // VML seems to have a problem when drawing a full circle that doesn't start 0\n                endAngle = (2 * Math.PI);\n            }\n\n            startx = x + Math.round(Math.cos(startAngle) * radius);\n            starty = y + Math.round(Math.sin(startAngle) * radius);\n            endx = x + Math.round(Math.cos(endAngle) * radius);\n            endy = y + Math.round(Math.sin(endAngle) * radius);\n\n            if (startx === endx && starty === endy) {\n                if ((endAngle - startAngle) < Math.PI) {\n                    // Prevent very small slices from being mistaken as a whole pie\n                    return '';\n                }\n                // essentially going to be the entire circle, so ignore startAngle\n                startx = endx = x + radius;\n                starty = endy = y;\n            }\n\n            if (startx === endx && starty === endy && (endAngle - startAngle) < Math.PI) {\n                return '';\n            }\n\n            vpath = [x - radius, y - radius, x + radius, y + radius, startx, starty, endx, endy];\n            stroke = lineColor === undefined ? ' stroked=\"false\" ' : ' strokeWeight=\"1px\" strokeColor=\"' + lineColor + '\" ';\n            fill = fillColor === undefined ? ' filled=\"false\"' : ' fillColor=\"' + fillColor + '\" filled=\"true\" ';\n            vel = '<v:shape coordorigin=\"0 0\" coordsize=\"' + this.pixelWidth + ' ' + this.pixelHeight + '\" ' +\n                 ' id=\"jqsshape' + shapeid + '\" ' +\n                 stroke +\n                 fill +\n                ' style=\"position:absolute;left:0px;top:0px;height:' + this.pixelHeight + 'px;width:' + this.pixelWidth + 'px;padding:0px;margin:0px;\" ' +\n                ' path=\"m ' + x + ',' + y + ' wa ' + vpath.join(', ') + ' x e\">' +\n                ' </v:shape>';\n            return vel;\n        },\n\n        _drawRect: function (shapeid, x, y, width, height, lineColor, fillColor) {\n            return this._drawShape(shapeid, [[x, y], [x, y + height], [x + width, y + height], [x + width, y], [x, y]], lineColor, fillColor);\n        },\n\n        reset: function () {\n            this.group.innerHTML = '';\n        },\n\n        appendShape: function (shape) {\n            var vel = this['_draw' + shape.type].apply(this, shape.args);\n            if (this.rendered) {\n                this.group.insertAdjacentHTML('beforeEnd', vel);\n            } else {\n                this.prerender += vel;\n            }\n            this.lastShapeId = shape.id;\n            return shape.id;\n        },\n\n        replaceWithShape: function (shapeid, shape) {\n            var existing = $('#jqsshape' + shapeid),\n                vel = this['_draw' + shape.type].apply(this, shape.args);\n            existing[0].outerHTML = vel;\n        },\n\n        replaceWithShapes: function (shapeids, shapes) {\n            // replace the first shapeid with all the new shapes then toast the remaining old shapes\n            var existing = $('#jqsshape' + shapeids[0]),\n                replace = '',\n                slen = shapes.length,\n                i;\n            for (i = 0; i < slen; i++) {\n                replace += this['_draw' + shapes[i].type].apply(this, shapes[i].args);\n            }\n            existing[0].outerHTML = replace;\n            for (i = 1; i < shapeids.length; i++) {\n                $('#jqsshape' + shapeids[i]).remove();\n            }\n        },\n\n        insertAfterShape: function (shapeid, shape) {\n            var existing = $('#jqsshape' + shapeid),\n                 vel = this['_draw' + shape.type].apply(this, shape.args);\n            existing[0].insertAdjacentHTML('afterEnd', vel);\n        },\n\n        removeShapeId: function (shapeid) {\n            var existing = $('#jqsshape' + shapeid);\n            this.group.removeChild(existing[0]);\n        },\n\n        getShapeAt: function (el, x, y) {\n            var shapeid = el.id.substr(8);\n            return shapeid;\n        },\n\n        render: function () {\n            if (!this.rendered) {\n                // batch the intial render into a single repaint\n                this.group.innerHTML = this.prerender;\n                this.rendered = true;\n            }\n        }\n    });\n\n}))}(document, Math));"]}