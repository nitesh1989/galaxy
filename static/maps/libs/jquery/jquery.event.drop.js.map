{"version":3,"sources":["libs/jquery/jquery.event.drop.js"],"names":["$","fn","drop","str","arg","opts","type","isFunction","indexOf","this","bind","trigger","multi","Infinity","isNaN","delay","tolerance","mode","$event","event","$special","special","targets","datakey","noBubble","add","obj","data","remove","related","setup","active","anyactive","winner","push","teardown","element","target","handler","dd","$targets","filter","droppable","drag","hijack","timer","clearTimeout","propagates","locate","elem","index","$elem","posi","height","width","location","top","left","right","contains","test","bottom","modes","intersect","proxy","pageX","overlap","Math","max","min","fit","middle","sort","a","b","tolerate","i","drp","drg","arr","len","x","end","interactions","length","xy","pageY","ia","call","last","setTimeout"],"mappings":"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","file":"../../../scripts/libs/jquery/jquery.event.drop.js","sourcesContent":["/*! \n * jquery.event.drop - v 2.2\n * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com\n * Open Source MIT License - http://threedubmedia.com/code/license\n */\n// Created: 2008-06-04 \n// Updated: 2012-05-21\n// REQUIRES: jquery 1.7.x, event.drag 2.2\n\n;(function($){ // secure $ jQuery alias\n\n// Events: drop, dropstart, dropend\n\n// add the jquery instance method\n$.fn.drop = function( str, arg, opts ){\n\t// figure out the event type\n\tvar type = typeof str == \"string\" ? str : \"\",\n\t// figure out the event handler...\n\tfn = $.isFunction( str ) ? str : $.isFunction( arg ) ? arg : null;\n\t// fix the event type\n\tif ( type.indexOf(\"drop\") !== 0 ) \n\t\ttype = \"drop\"+ type;\n\t// were options passed\n\topts = ( str == fn ? arg : opts ) || {};\n\t// trigger or bind event handler\n\treturn fn ? this.bind( type, opts, fn ) : this.trigger( type );\n};\n\n// DROP MANAGEMENT UTILITY\n// returns filtered drop target elements, caches their positions\n$.drop = function( opts ){ \n\topts = opts || {};\n\t// safely set new options...\n\tdrop.multi = opts.multi === true ? Infinity : \n\t\topts.multi === false ? 1 : !isNaN( opts.multi ) ? opts.multi : drop.multi;\n\tdrop.delay = opts.delay || drop.delay;\n\tdrop.tolerance = $.isFunction( opts.tolerance ) ? opts.tolerance : \n\t\topts.tolerance === null ? null : drop.tolerance;\n\tdrop.mode = opts.mode || drop.mode || 'intersect';\n};\n\n// local refs (increase compression)\nvar $event = $.event, \n$special = $event.special,\n// configure the drop special event\ndrop = $.event.special.drop = {\n\n\t// these are the default settings\n\tmulti: 1, // allow multiple drop winners per dragged element\n\tdelay: 20, // async timeout delay\n\tmode: 'overlap', // drop tolerance mode\n\t\t\n\t// internal cache\n\ttargets: [], \n\t\n\t// the key name for stored drop data\n\tdatakey: \"dropdata\",\n\t\t\n\t// prevent bubbling for better performance\n\tnoBubble: true,\n\t\n\t// count bound related events\n\tadd: function( obj ){ \n\t\t// read the interaction data\n\t\tvar data = $.data( this, drop.datakey );\n\t\t// count another realted event\n\t\tdata.related += 1;\n\t},\n\t\n\t// forget unbound related events\n\tremove: function(){\n\t\t$.data( this, drop.datakey ).related -= 1;\n\t},\n\t\n\t// configure the interactions\n\tsetup: function(){\n\t\t// check for related events\n\t\tif ( $.data( this, drop.datakey ) ) \n\t\t\treturn;\n\t\t// initialize the drop element data\n\t\tvar data = { \n\t\t\trelated: 0,\n\t\t\tactive: [],\n\t\t\tanyactive: 0,\n\t\t\twinner: 0,\n\t\t\tlocation: {}\n\t\t};\n\t\t// store the drop data on the element\n\t\t$.data( this, drop.datakey, data );\n\t\t// store the drop target in internal cache\n\t\tdrop.targets.push( this );\n\t},\n\t\n\t// destroy the configure interaction\t\n\tteardown: function(){ \n\t\tvar data = $.data( this, drop.datakey ) || {};\n\t\t// check for related events\n\t\tif ( data.related ) \n\t\t\treturn;\n\t\t// remove the stored data\n\t\t$.removeData( this, drop.datakey );\n\t\t// reference the targeted element\n\t\tvar element = this;\n\t\t// remove from the internal cache\n\t\tdrop.targets = $.grep( drop.targets, function( target ){ \n\t\t\treturn ( target !== element ); \n\t\t});\n\t},\n\t\n\t// shared event handler\n\thandler: function( event, dd ){ \n\t\t// local vars\n\t\tvar results, $targets;\n\t\t// make sure the right data is available\n\t\tif ( !dd ) \n\t\t\treturn;\n\t\t// handle various events\n\t\tswitch ( event.type ){\n\t\t\t// draginit, from $.event.special.drag\n\t\t\tcase 'mousedown': // DROPINIT >>\n\t\t\tcase 'touchstart': // DROPINIT >>\n\t\t\t\t// collect and assign the drop targets\n\t\t\t\t$targets =  $( drop.targets );\n\t\t\t\tif ( typeof dd.drop == \"string\" )\n\t\t\t\t\t$targets = $targets.filter( dd.drop );\n\t\t\t\t// reset drop data winner properties\n\t\t\t\t$targets.each(function(){\n\t\t\t\t\tvar data = $.data( this, drop.datakey );\n\t\t\t\t\tdata.active = [];\n\t\t\t\t\tdata.anyactive = 0;\n\t\t\t\t\tdata.winner = 0;\n\t\t\t\t});\n\t\t\t\t// set available target elements\n\t\t\t\tdd.droppable = $targets;\n\t\t\t\t// activate drop targets for the initial element being dragged\n\t\t\t\t$special.drag.hijack( event, \"dropinit\", dd ); \n\t\t\t\tbreak;\n\t\t\t// drag, from $.event.special.drag\n\t\t\tcase 'mousemove': // TOLERATE >>\n\t\t\tcase 'touchmove': // TOLERATE >>\n\t\t\t\tdrop.event = event; // store the mousemove event\n\t\t\t\tif ( !drop.timer )\n\t\t\t\t\t// monitor drop targets\n\t\t\t\t\tdrop.tolerate( dd ); \n\t\t\t\tbreak;\n\t\t\t// dragend, from $.event.special.drag\n\t\t\tcase 'mouseup': // DROP >> DROPEND >>\n\t\t\tcase 'touchend': // DROP >> DROPEND >>\n\t\t\t\tdrop.timer = clearTimeout( drop.timer ); // delete timer\t\n\t\t\t\tif ( dd.propagates ){\n\t\t\t\t\t$special.drag.hijack( event, \"drop\", dd ); \n\t\t\t\t\t$special.drag.hijack( event, \"dropend\", dd ); \n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t}\n\t},\n\t\t\n\t// returns the location positions of an element\n\tlocate: function( elem, index ){ \n\t\tvar data = $.data( elem, drop.datakey ),\n\t\t$elem = $( elem ), \n\t\tposi = $elem.offset() || {}, \n\t\theight = $elem.outerHeight(), \n\t\twidth = $elem.outerWidth(),\n\t\tlocation = { \n\t\t\telem: elem, \n\t\t\twidth: width, \n\t\t\theight: height,\n\t\t\ttop: posi.top, \n\t\t\tleft: posi.left, \n\t\t\tright: posi.left + width, \n\t\t\tbottom: posi.top + height\n\t\t};\n\t\t// drag elements might not have dropdata\n\t\tif ( data ){\n\t\t\tdata.location = location;\n\t\t\tdata.index = index;\n\t\t\tdata.elem = elem;\n\t\t}\n\t\treturn location;\n\t},\n\t\n\t// test the location positions of an element against another OR an X,Y coord\n\tcontains: function( target, test ){ // target { location } contains test [x,y] or { location }\n\t\treturn ( ( test[0] || test.left ) >= target.left && ( test[0] || test.right ) <= target.right\n\t\t\t&& ( test[1] || test.top ) >= target.top && ( test[1] || test.bottom ) <= target.bottom ); \n\t},\n\t\n\t// stored tolerance modes\n\tmodes: { // fn scope: \"$.event.special.drop\" object \n\t\t// target with mouse wins, else target with most overlap wins\n\t\t'intersect': function( event, proxy, target ){\n\t\t\treturn this.contains( target, [ event.pageX, event.pageY ] ) ? // check cursor\n\t\t\t\t1e9 : this.modes.overlap.apply( this, arguments ); // check overlap\n\t\t},\n\t\t// target with most overlap wins\t\n\t\t'overlap': function( event, proxy, target ){\n\t\t\t// calculate the area of overlap...\n\t\t\treturn Math.max( 0, Math.min( target.bottom, proxy.bottom ) - Math.max( target.top, proxy.top ) )\n\t\t\t\t* Math.max( 0, Math.min( target.right, proxy.right ) - Math.max( target.left, proxy.left ) );\n\t\t},\n\t\t// proxy is completely contained within target bounds\t\n\t\t'fit': function( event, proxy, target ){\n\t\t\treturn this.contains( target, proxy ) ? 1 : 0;\n\t\t},\n\t\t// center of the proxy is contained within target bounds\t\n\t\t'middle': function( event, proxy, target ){\n\t\t\treturn this.contains( target, [ proxy.left + proxy.width * .5, proxy.top + proxy.height * .5 ] ) ? 1 : 0;\n\t\t}\n\t},\t\n\t\n\t// sort drop target cache by by winner (dsc), then index (asc)\n\tsort: function( a, b ){\n\t\treturn ( b.winner - a.winner ) || ( a.index - b.index );\n\t},\n\t\t\n\t// async, recursive tolerance execution\n\ttolerate: function( dd ){\t\t\n\t\t// declare local refs\n\t\tvar i, drp, drg, data, arr, len, elem,\n\t\t// interaction iteration variables\n\t\tx = 0, ia, end = dd.interactions.length,\n\t\t// determine the mouse coords\n\t\txy = [ drop.event.pageX, drop.event.pageY ],\n\t\t// custom or stored tolerance fn\n\t\ttolerance = drop.tolerance || drop.modes[ drop.mode ];\n\t\t// go through each passed interaction...\n\t\tdo if ( ia = dd.interactions[x] ){\n\t\t\t// check valid interaction\n\t\t\tif ( !ia )\n\t\t\t\treturn; \n\t\t\t// initialize or clear the drop data\n\t\t\tia.drop = [];\n\t\t\t// holds the drop elements\n\t\t\tarr = []; \n\t\t\tlen = ia.droppable.length;\n\t\t\t// determine the proxy location, if needed\n\t\t\tif ( tolerance )\n\t\t\t\tdrg = drop.locate( ia.proxy ); \n\t\t\t// reset the loop\n\t\t\ti = 0;\n\t\t\t// loop each stored drop target\n\t\t\tdo if ( elem = ia.droppable[i] ){ \n\t\t\t\tdata = $.data( elem, drop.datakey );\n\t\t\t\tdrp = data.location;\n\t\t\t\tif ( !drp ) continue;\n\t\t\t\t// find a winner: tolerance function is defined, call it\n\t\t\t\tdata.winner = tolerance ? tolerance.call( drop, drop.event, drg, drp ) \n\t\t\t\t\t// mouse position is always the fallback\n\t\t\t\t\t: drop.contains( drp, xy ) ? 1 : 0; \n\t\t\t\tarr.push( data );\t\n\t\t\t} while ( ++i < len ); // loop \n\t\t\t// sort the drop targets\n\t\t\tarr.sort( drop.sort );\t\t\t\n\t\t\t// reset the loop\n\t\t\ti = 0;\n\t\t\t// loop through all of the targets again\n\t\t\tdo if ( data = arr[ i ] ){\n\t\t\t\t// winners...\n\t\t\t\tif ( data.winner && ia.drop.length < drop.multi ){\n\t\t\t\t\t// new winner... dropstart\n\t\t\t\t\tif ( !data.active[x] && !data.anyactive ){\n\t\t\t\t\t\t// check to make sure that this is not prevented\n\t\t\t\t\t\tif ( $special.drag.hijack( drop.event, \"dropstart\", dd, x, data.elem )[0] !== false ){ \t\n\t\t\t\t\t\t\tdata.active[x] = 1;\n\t\t\t\t\t\t\tdata.anyactive += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if false, it is not a winner\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdata.winner = 0;\n\t\t\t\t\t}\n\t\t\t\t\t// if it is still a winner\n\t\t\t\t\tif ( data.winner )\n\t\t\t\t\t\tia.drop.push( data.elem );\n\t\t\t\t}\n\t\t\t\t// losers... \n\t\t\t\telse if ( data.active[x] && data.anyactive == 1 ){\n\t\t\t\t\t// former winner... dropend\n\t\t\t\t\t$special.drag.hijack( drop.event, \"dropend\", dd, x, data.elem ); \n\t\t\t\t\tdata.active[x] = 0;\n\t\t\t\t\tdata.anyactive -= 1;\n\t\t\t\t}\n\t\t\t} while ( ++i < len ); // loop \t\t\n\t\t} while ( ++x < end ) // loop\n\t\t// check if the mouse is still moving or is idle\n\t\tif ( drop.last && xy[0] == drop.last.pageX && xy[1] == drop.last.pageY ) \n\t\t\tdelete drop.timer; // idle, don't recurse\n\t\telse  // recurse\n\t\t\tdrop.timer = setTimeout(function(){ \n\t\t\t\tdrop.tolerate( dd ); \n\t\t\t}, drop.delay );\n\t\t// remember event, to compare idleness\n\t\tdrop.last = drop.event; \n\t}\n\t\n};\n\n// share the same special event configuration with related events...\n$special.dropinit = $special.dropstart = $special.dropend = drop;\n\n})(jQuery); // confine scope\t"]}