{"version":3,"sources":["libs/bbi/bigwig.js"],"names":["define","spans","jszlib","DASFeature","DASGroup","id","this","readInt","ba","offset","read","url","start","size","chunkSizeLimit","pow","type","dataType","beforeSend","xhrObj","setRequestHeader","responseType","o","M1","M2","M3","M4","BigWig","cirTreeOffset","cirTreeLength","isSummary","bwg","definedFieldCount","asOffset","Deferred","totalSummaryOffset","uncompressBufSize","zoomLevels","then","result","zlReduction","zl","Uint8Array","header","sa","Int16Array","when","readChromTree","getAutoSQL","as","schema","promise","magic","BIG_BED_MAGIC","BIG_WIG_MAGIC_BE","BIG_BED_MAGIC_BE","resolve","toString","version","topLevelReductionCache","numZoomLevels","getZoomedView","feats","unzoomedDataOffset","_tsFetch","min","max","unzoomedIndexOffset","bwg_readOffset","fieldCount","fi","_chromId","f","callback","la","zlData","zlIndex","zoom","push","reduction","dataOffset","indexOffset","view","readWigDataById","BBIExtraIndex","bbi","field","lastChildOffset","bptReadNode","Range","union","intersection","jszlib_inflate_buffer","inflateBuffer","arrayCopy","BIG_WIG_MAGIC","BED_COLOR_REGEXP","RegExp","prototype","chromsToIDs","thisB","idsToChroms","maxID","udo","chromTreeOffset","$","bpt","Int32Array","bptMagic","blockSize","itemCount","rootNodeOffset","cnt","n","nodeType","keySize","childOffset","key","charCode","ki","String","fromCharCode","indexOf","chromId","substr","Math","BigWigView","readWigData","chrName","rval","undefined","chr","cirHeader","outstanding","cirBlockSize","blocksToFetch","filter","cirFobRecur","Date","now","instrument","console","fmin","fmax","level","length","cirFobRecur2","cachedCirRoot","fetchFeatures","fetchRanges","maxCirBlockSpan","ranges","i","blockSpan","fr","r","cirFobStartFetch","resultBuffer","attempts","cirBlockData","isLeaf","lo","startChrom","endBase","blockOffset","endChrom","recurOffsets","startBase","features","createFeature","opts","b0","b1","segment","tramp","afterBWG","k","block","fetchStart","data","parseFeatures","fetchSize","bi","tmp","buffer","fb","end","validCnt","sumData","sumSqData","fa","Float32Array","summaryOpts","maxVal","score","maxScore","blockStart","blockEnd","itemSpan","BIG_WIG_TYPE_FSTEP","blockType","itemStep","BIG_WIG_TYPE_GRAPH","log","dfc","rest","ch","fetch","featureOpts","bedColumns","label","col","isNaN","orientation","color","thickEnd","exonFrames","grp","split","notes","geneId","geneName","geneName2","gg","extend","groups","blockCount","bmin","blockStarts","bmax","span","spanList","tsList","ts","b","tl","codingRegion","blockSizes","tlList","tlOffset","s","thickStart","readframe","readingFrame","parseInt","readframeExplicit","index","brf","getFirstAdjacent","pos","dir","blockToFetch","bestBlockChr","getFirstAdjacentById","slice","bestBlockOffset","bestChr","bestPos","contains","chrx","bestFeature","toks","bestRecur","MAX_DATA_POINTS","getUnzoomedView","range","cirLen","zh","unzoomedView","chrId","initialChr","candidates","chrOrd","candidate","d","c1","c","c2","fbThresholdSearchRecur","thresholdSearch","referencePoint","threshold","rp","fromRef","headerMatch","header_re","substring","field_re","exec","comment","extraIndexCount","declType","name","fields","eiType","ii","m","eiFieldCount","eiOffset","eiField","getExtraIndices","extHeaderOffset","valSize","eil","Uint32Array","node","indices","lookup","nodeOffset","Uint16Array","makeBwg","localeCompare"],"mappings":"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","file":"../../../scripts/libs/bbi/bigwig.js","sourcesContent":["//\n// Author: Jeremy Goecks\n//\n// Modified from:\n//\n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// bigwig.js: indexed binary WIG (and BED) files\n//\n\n// Requirements:\n//  * jquery and ajax-native plugin for reading binary data, jquery for promises\n//  * spans for working working with genomic intervals\n//  * jszlib for decompression.\ndefine([\"libs/bbi/spans\", \"libs/bbi/jszlib\", \"libs/bbi/jquery-ajax-native\"], function(spans, jszlib) {\n    \"use strict\";\n\n    // -- Copied from das.js --\n\n    function DASFeature() {\n    }\n\n    function DASGroup(id) {\n        if (id)\n        this.id = id;\n    }\n\n    // -- End copy --\n\n    // -- Copied from bin.js --\n\n    function readInt(ba, offset) {\n        return (ba[offset + 3] << 24) | (ba[offset + 2] << 16) | (ba[offset + 1] << 8) | (ba[offset]);\n    }\n\n    // -- End copy --\n\n    // Some globals.\n    var Range = spans.Range;\n    var union = spans.union;\n    var intersection = spans.intersection;\n\n    var jszlib_inflate_buffer = jszlib.inflateBuffer;\n    var arrayCopy = jszlib.arrayCopy;\n\n    var BIG_WIG_MAGIC = 0x888FFC26;\n    var BIG_WIG_MAGIC_BE = 0x26FC8F88;\n    var BIG_BED_MAGIC = 0x8789F2EB;\n    var BIG_BED_MAGIC_BE = 0xEBF28987;\n\n\n    var BIG_WIG_TYPE_GRAPH = 1;\n    var BIG_WIG_TYPE_VSTEP = 2;\n    var BIG_WIG_TYPE_FSTEP = 3;\n\n    var M1 = 256;\n    var M2 = 256*256;\n    var M3 = 256*256*256;\n    var M4 = 256*256*256*256;\n\n    var BED_COLOR_REGEXP = new RegExp(\"^[0-9]+,[0-9]+,[0-9]+\");\n\n    /**\n     * Read binary data from a URL using HTTP Range header. Requires jQuery and ajax-native plugin.\n     */\n    function read(url, start, size) {\n        // Taken from bin.js:\n        // This may be necessary for Safari:\n        //   if ((isSafari || this.opts.salt) && url.indexOf('?') < 0) {\n        //       url = url + '?salt=' + b64_sha1('' + Date.now() + ',' + (++seed));\n        //   }\n\n        var chunkSizeLimit = Math.pow(10, 6); // 1 MB\n        if(size > chunkSizeLimit) {\n            // TODO: raise error.\n        }\n\n        // Read data from remote file.\n        return $.ajax({\n            type: 'GET',\n            dataType: 'native',\n            url: url,\n            // Potential timeout on first request to catch mixed-content errors on Chromium.\n            timeout: 5000,\n            beforeSend: function(xhrObj) {\n                // (size - 1) because range is inclusive.\n                xhrObj.setRequestHeader(\"Range\", \"bytes=\" + start + \"-\" + (start + (size - 1)));\n            },\n            xhrFields: {\n                responseType: 'arraybuffer'\n            }\n        });\n    }\n\n    function bwg_readOffset(ba, o) {\n        var offset = ba[o] + ba[o+1]*M1 + ba[o+2]*M2 + ba[o+3]*M3 + ba[o+4]*M4;\n        return offset;\n    }\n\n    function BigWig() {\n    }\n\n    /**\n     * Read the chromosome B+ tree header.\n     */\n    BigWig.prototype.readChromTree = function() {\n        var thisB = this;\n        this.chromsToIDs = {};\n        this.idsToChroms = {};\n        this.maxID = 0;\n\n        var udo = this.unzoomedDataOffset;\n        var eb = (udo - this.chromTreeOffset) & 3;\n        udo = udo + 4 - eb;\n\n        // Read and parse the chrom tree, return the promise so that subsequent actions can be taken.\n        return $.when(read(this.url, this.chromTreeOffset, udo - this.chromTreeOffset)).then(function(bpt) {\n            var ba = new Uint8Array(bpt);\n            var sa = new Int16Array(bpt);\n            var la = new Int32Array(bpt);\n            var bptMagic = la[0];\n            var blockSize = la[1];\n            var keySize = la[2];\n            var valSize = la[3];\n            var itemCount = bwg_readOffset(ba, 16);\n            var rootNodeOffset = 32;\n\n            var bptReadNode = function(offset) {\n                var nodeType = ba[offset];\n                var cnt = sa[(offset/2) + 1];\n                offset += 4;\n                for (var n = 0; n < cnt; ++n) {\n                    if (nodeType === 0) {\n                        offset += keySize;\n                        var childOffset = bwg_readOffset(ba, offset);\n                        offset += 8;\n                        childOffset -= thisB.chromTreeOffset;\n                        bptReadNode(childOffset);\n                    } else {\n                        var key = '';\n                        for (var ki = 0; ki < keySize; ++ki) {\n                            var charCode = ba[offset++];\n                            if (charCode !== 0) {\n                                key += String.fromCharCode(charCode);\n                            }\n                        }\n                        var chromId = (ba[offset+3]<<24) | (ba[offset+2]<<16) | (ba[offset+1]<<8) | (ba[offset+0]);\n                        var chromSize = (ba[offset + 7]<<24) | (ba[offset+6]<<16) | (ba[offset+5]<<8) | (ba[offset+4]);\n                        offset += 8;\n\n                        thisB.chromsToIDs[key] = chromId;\n                        if (key.indexOf('chr') === 0) {\n                            thisB.chromsToIDs[key.substr(3)] = chromId;\n                        }\n                        thisB.idsToChroms[chromId] = key;\n                        thisB.maxID = Math.max(thisB.maxID, chromId);\n                    }\n                }\n            };\n            bptReadNode(rootNodeOffset);\n        });\n    }\n\n    function BigWigView(bwg, cirTreeOffset, cirTreeLength, isSummary) {\n        this.bwg = bwg;\n        this.cirTreeOffset = cirTreeOffset;\n        this.cirTreeLength = cirTreeLength;\n        this.isSummary = isSummary;\n    }\n\n\n\n    BigWigView.prototype.readWigData = function(chrName, min, max) {\n        var chr = this.bwg.chromsToIDs[chrName],\n            rval;\n        if (chr === undefined) {\n            // Not an error because some .bwgs won't have data for all chromosomes.\n            rval = [];\n        } else {\n            rval = this.readWigDataById(chr, min, max);\n        }\n\n        return rval;\n    };\n\n    BigWigView.prototype.readWigDataById = function(chr, min, max) {\n        var thisB = this,\n            promise = $.Deferred();\n\n        // Read the R-tree index header and then read data again.\n        if (!this.cirHeader) {\n            $.when(read(thisB.bwg.url, this.cirTreeOffset, 48)).then(function(result) {\n                thisB.cirHeader = result;\n                var la = new Int32Array(thisB.cirHeader);\n                thisB.cirBlockSize = la[1];\n                $.when(thisB.readWigDataById(chr, min, max)).then(function(result) {\n                    promise.resolve(result);\n                });\n            });\n            return promise;\n        }\n\n        var blocksToFetch = [];\n        var outstanding = 0;\n\n        var beforeBWG = Date.now();\n\n        var filter = function(chromId, fmin, fmax, toks) {\n            return ((chr < 0 || chromId == chr) && fmin <= max && fmax >= min);\n        };\n\n        var cirFobRecur = function(offset, level) {\n            if (thisB.bwg.instrument)\n            console.log('level=' + level + '; offset=' + offset + '; time=' + (Date.now()|0));\n\n            outstanding += offset.length;\n\n            if (offset.length == 1 && offset[0] - thisB.cirTreeOffset == 48 && thisB.cachedCirRoot) {\n                cirFobRecur2(thisB.cachedCirRoot, 0, level);\n                --outstanding;\n                if (outstanding === 0) {\n                    $.when(thisB.fetchFeatures(filter, blocksToFetch)).then(function(result) {\n                        promise.resolve(result);\n                    });\n                }\n                return;\n            }\n\n            var maxCirBlockSpan = 4 +  (thisB.cirBlockSize * 32);   // Upper bound on size, based on a completely full leaf node.\n            var spans;\n            for (var i = 0; i < offset.length; ++i) {\n                var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);\n                spans = spans ? union(spans, blockSpan) : blockSpan;\n            }\n\n            var fetchRanges = spans.ranges();\n            for (var r = 0; r < fetchRanges.length; ++r) {\n                var fr = fetchRanges[r];\n                cirFobStartFetch(offset, fr, level);\n            }\n        };\n\n        var cirFobStartFetch = function(offset, fr, level, attempts) {\n            var length = fr.max() - fr.min();\n            $.when(read(thisB.bwg.url, fr.min(), fr.max() - fr.min())).then(function(resultBuffer) {\n                for (var i = 0; i < offset.length; ++i) {\n                    if (fr.contains(offset[i])) {\n                        cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);\n\n                        if (offset[i] - thisB.cirTreeOffset == 48 && offset[i] - fr.min() === 0)\n                            thisB.cachedCirRoot = resultBuffer;\n\n                        --outstanding;\n                        if (outstanding === 0) {\n                            $.when(thisB.fetchFeatures(filter, blocksToFetch)).then(function(result) {\n                                promise.resolve(result);\n                            });\n                        }\n                    }\n                }\n            });\n        };\n\n        var cirFobRecur2 = function(cirBlockData, offset, level) {\n            var ba = new Uint8Array(cirBlockData);\n            var sa = new Int16Array(cirBlockData);\n            var la = new Int32Array(cirBlockData);\n\n            var isLeaf = ba[offset];\n            var cnt = sa[offset/2 + 1];\n            offset += 4;\n\n            if (isLeaf !== 0) {\n                for (var i = 0; i < cnt; ++i) {\n                    var lo = offset/4;\n                    var startChrom = la[lo];\n                    var startBase = la[lo + 1];\n                    var endChrom = la[lo + 2];\n                    var endBase = la[lo + 3];\n                    var blockOffset = bwg_readOffset(ba, offset+16);\n                    var blockSize = bwg_readOffset(ba, offset+24);\n                    if (((chr < 0 || startChrom < chr) || (startChrom == chr && startBase <= max)) &&\n                    ((chr < 0 || endChrom   > chr) || (endChrom == chr && endBase >= min)))\n                    {\n                        blocksToFetch.push({offset: blockOffset, size: blockSize});\n                    }\n                    offset += 32;\n                }\n            } else {\n                var recurOffsets = [];\n                for (var i = 0; i < cnt; ++i) {\n                    var lo = offset/4;\n                    var startChrom = la[lo];\n                    var startBase = la[lo + 1];\n                    var endChrom = la[lo + 2];\n                    var endBase = la[lo + 3];\n                    var blockOffset = bwg_readOffset(ba, offset+16);\n                    if ((chr < 0 || startChrom < chr || (startChrom == chr && startBase <= max)) &&\n                    (chr < 0 || endChrom   > chr || (endChrom == chr && endBase >= min)))\n                    {\n                        recurOffsets.push(blockOffset);\n                    }\n                    offset += 24;\n                }\n                if (recurOffsets.length > 0) {\n                    cirFobRecur(recurOffsets, level + 1);\n                }\n            }\n        };\n\n        cirFobRecur([thisB.cirTreeOffset + 48], 1);\n        return promise;\n    };\n\n    /**\n     * Fetch data for a set of blocks. Returns a promise that resolves to fetched data.\n     */\n    BigWigView.prototype.fetchFeatures = function(filter, blocksToFetch) {\n        var thisB = this,\n            promise = $.Deferred();\n\n        blocksToFetch.sort(function(b0, b1) {\n            return (b0.offset|0) - (b1.offset|0);\n        });\n\n        if (blocksToFetch.length === 0) {\n            return [];\n        } else {\n            var features = [];\n            var createFeature = function(chr, fmin, fmax, opts) {\n                if (!opts) {\n                    opts = {};\n                }\n\n                var f = new DASFeature();\n                f._chromId = chr;\n                f.segment = thisB.bwg.idsToChroms[chr];\n                f.min = fmin;\n                f.max = fmax;\n                f.type = thisB.bwg.type;\n\n                for (var k in opts) {\n                    f[k] = opts[k];\n                }\n\n                features.push(f);\n            };\n\n            // Recursive function to read blocks of data.\n            var tramp = function() {\n                if (blocksToFetch.length === 0) {\n                    var afterBWG = Date.now();\n                    // dlog('BWG fetch took ' + (afterBWG - beforeBWG) + 'ms');\n                    return promise.resolve(features);\n                }\n                else {\n                    var block = blocksToFetch[0];\n                    if (block.data) {\n                        thisB.parseFeatures(block.data, createFeature, filter);\n                        blocksToFetch.splice(0, 1);\n                        tramp();\n                    }\n                    else {\n                        var fetchStart = block.offset;\n                        var fetchSize = block.size;\n                        var bi = 1;\n                        while (bi < blocksToFetch.length && blocksToFetch[bi].offset == (fetchStart + fetchSize)) {\n                            fetchSize += blocksToFetch[bi].size;\n                            ++bi;\n                        }\n\n                        $.when(read(thisB.bwg.url, fetchStart, fetchSize)).then(function(result) {\n                            var offset = 0;\n                            var bi = 0;\n                            while (offset < fetchSize) {\n                                var fb = blocksToFetch[bi];\n\n                                var data;\n                                if (thisB.bwg.uncompressBufSize > 0) {\n                                    data = jszlib_inflate_buffer(result, offset + 2, fb.size - 2);\n                                } else {\n                                    var tmp = new Uint8Array(fb.size);    // FIXME is this really the best we can do?\n                                    arrayCopy(new Uint8Array(result, offset, fb.size), 0, tmp, 0, fb.size);\n                                    data = tmp.buffer;\n                                }\n                                fb.data = data;\n\n                                offset += fb.size;\n                                ++bi;\n                            }\n                            tramp();\n                        });\n                    }\n                }\n            };\n            tramp();\n        }\n\n        return promise;\n    };\n\n    BigWigView.prototype.parseFeatures = function(data, createFeature, filter) {\n        var ba = new Uint8Array(data);\n\n        if (this.isSummary) {\n            var sa = new Int16Array(data);\n            var la = new Int32Array(data);\n            var fa = new Float32Array(data);\n\n            var itemCount = data.byteLength/32;\n            for (var i = 0; i < itemCount; ++i) {\n                var chromId =   la[(i*8)];\n                var start =     la[(i*8)+1];\n                var end =       la[(i*8)+2];\n                var validCnt =  la[(i*8)+3];\n                var minVal    = fa[(i*8)+4];\n                var maxVal    = fa[(i*8)+5];\n                var sumData   = fa[(i*8)+6];\n                var sumSqData = fa[(i*8)+7];\n\n                if (filter(chromId, start + 1, end)) {\n                    var summaryOpts = {type: 'bigwig', score: sumData/validCnt, maxScore: maxVal};\n                    if (this.bwg.type == 'bigbed') {\n                        summaryOpts.type = 'density';\n                    }\n                    createFeature(chromId, start + 1, end, summaryOpts);\n                }\n            }\n        }\n        else if (this.bwg.type == 'bigwig') {\n            var sa = new Int16Array(data);\n            var la = new Int32Array(data);\n            var fa = new Float32Array(data);\n\n            var chromId = la[0];\n            var blockStart = la[1];\n            var blockEnd = la[2];\n            var itemStep = la[3];\n            var itemSpan = la[4];\n            var blockType = ba[20];\n            var itemCount = sa[11];\n\n            if (blockType == BIG_WIG_TYPE_FSTEP) {\n                for (var i = 0; i < itemCount; ++i) {\n                    var score = fa[i + 6];\n                    var fmin = blockStart + (i*itemStep) + 1, fmax = blockStart + (i*itemStep) + itemSpan;\n                    if (filter(chromId, fmin, fmax))\n                    createFeature(chromId, fmin, fmax, {score: score});\n                }\n            } else if (blockType == BIG_WIG_TYPE_VSTEP) {\n                for (var i = 0; i < itemCount; ++i) {\n                    var start = la[(i*2) + 6] + 1;\n                    var end = start + itemSpan - 1;\n                    var score = fa[(i*2) + 7];\n                    if (filter(chromId, start, end))\n                    createFeature(chromId, start, end, {score: score});\n                }\n            } else if (blockType == BIG_WIG_TYPE_GRAPH) {\n                for (var i = 0; i < itemCount; ++i) {\n                    var start = la[(i*3) + 6] + 1;\n                    var end   = la[(i*3) + 7];\n                    var score = fa[(i*3) + 8];\n                    if (start > end) {\n                        start = end;\n                    }\n                    if (filter(chromId, start, end))\n                    createFeature(chromId, start, end, {score: score});\n                }\n            } else {\n                console.log('Currently not handling bwgType=' + blockType);\n            }\n        } else if (this.bwg.type == 'bigbed') {\n            var offset = 0;\n            var dfc = this.bwg.definedFieldCount;\n            var schema = this.bwg.schema;\n\n            while (offset < ba.length) {\n                var chromId = (ba[offset+3]<<24) | (ba[offset+2]<<16) | (ba[offset+1]<<8) | (ba[offset+0]);\n                var start = (ba[offset+7]<<24) | (ba[offset+6]<<16) | (ba[offset+5]<<8) | (ba[offset+4]);\n                var end = (ba[offset+11]<<24) | (ba[offset+10]<<16) | (ba[offset+9]<<8) | (ba[offset+8]);\n                offset += 12;\n                var rest = '';\n                while (true) {\n                    var ch = ba[offset++];\n                    if (ch != 0) {\n                        rest += String.fromCharCode(ch);\n                    } else {\n                        break;\n                    }\n                }\n\n                var featureOpts = {};\n\n                var bedColumns;\n                if (rest.length > 0) {\n                    bedColumns = rest.split('\\t');\n                } else {\n                    bedColumns = [];\n                }\n                if (bedColumns.length > 0 && dfc > 3) {\n                    featureOpts.label = bedColumns[0];\n                }\n                if (bedColumns.length > 1 && dfc > 4) {\n                    var score = parseInt(bedColumns[1]);\n                    if (!isNaN(score))\n                    featureOpts.score = score;\n                }\n                if (bedColumns.length > 2 && dfc > 5) {\n                    featureOpts.orientation = bedColumns[2];\n                }\n                if (bedColumns.length > 5 && dfc > 8) {\n                    var color = bedColumns[5];\n                    if (BED_COLOR_REGEXP.test(color)) {\n                        featureOpts.itemRgb = 'rgb(' + color + ')';\n                    }\n                }\n\n                if (bedColumns.length > dfc-3 && schema) {\n                    for (var col = dfc - 3; col < bedColumns.length; ++col) {\n                        featureOpts[schema.fields[col+3].name] = bedColumns[col];\n                    }\n                }\n\n                if (filter(chromId, start + 1, end, bedColumns)) {\n                    if (dfc < 12) {\n                        createFeature(chromId, start + 1, end, featureOpts);\n                    } else {\n                        // TODO: add block starts, sizes, thick start, thick end to feature.\n                        var thickStart = bedColumns[3]|0;\n                        var thickEnd   = bedColumns[4]|0;\n                        var blockCount = bedColumns[6]|0;\n                        var blockSizes = bedColumns[7].split(',');\n                        var blockStarts = bedColumns[8].split(',');\n\n                        if (featureOpts.exonFrames) {\n                            var exonFrames = featureOpts.exonFrames.split(',');\n                            featureOpts.exonFrames = undefined;\n                        }\n\n                        featureOpts.type = 'transcript'\n                        var grp = new DASGroup();\n                        for (var k in featureOpts) {\n                            grp[k] = featureOpts[k];\n                        }\n                        grp.id = bedColumns[0];\n                        grp.segment = this.bwg.idsToChroms[chromId];\n                        grp.min = start + 1;\n                        grp.max = end;\n                        grp.notes = [];\n                        featureOpts.groups = [grp];\n\n                        // Moving towards using bigGenePred model, but will\n                        // still support old Dalliance-style BED12+gene-name for the\n                        // foreseeable future.\n                        if (bedColumns.length > 9) {\n                            var geneId = featureOpts.geneName || bedColumns[9];\n                            var geneName = geneId;\n                            if (bedColumns.length > 10) {\n                                geneName = bedColumns[10];\n                            }\n                            if (featureOpts.geneName2)\n                            geneName = featureOpts.geneName2;\n\n                            var gg = $.extend({}, grp);\n                            gg.id = geneId;\n                            gg.label = geneName;\n                            gg.type = 'gene';\n                            featureOpts.groups.push(gg);\n                        }\n\n                        var spanList = [];\n                        for (var b = 0; b < blockCount; ++b) {\n                            var bmin = (blockStarts[b]|0) + start;\n                            var bmax = bmin + (blockSizes[b]|0);\n                            var span = new Range(bmin, bmax);\n                            spanList.push(span);\n                        }\n                        var spans = union(spanList);\n\n                        var tsList = spans.ranges();\n                        for (var s = 0; s < tsList.length; ++s) {\n                            var ts = tsList[s];\n                            createFeature(chromId, ts.min() + 1, ts.max(), featureOpts);\n                        }\n\n                        if (thickEnd > thickStart) {\n                            var codingRegion = (featureOpts.orientation == '+') ?\n                            new Range(thickStart, thickEnd + 3) :\n                            new Range(thickStart - 3, thickEnd);\n                            // +/- 3 to account for stop codon\n\n                            var tl = intersection(spans, codingRegion);\n                            if (tl) {\n                                featureOpts.type = 'translation';\n                                var tlList = tl.ranges();\n                                var readingFrame = 0;\n\n                                var tlOffset = 0;\n                                while (tlList[0].min() > tsList[tlOffset].max())\n                                tlOffset++;\n\n                                for (var s = 0; s < tlList.length; ++s) {\n                                    // Record reading frame for every exon\n                                    var index = s;\n                                    if (featureOpts.orientation == '-')\n                                    index = tlList.length - s - 1;\n                                    var ts = tlList[index];\n                                    featureOpts.readframe = readingFrame;\n                                    if (exonFrames) {\n                                        var brf = parseInt(exonFrames[index + tlOffset]);\n                                        if (typeof(brf) === 'number' && brf >= 0 && brf <= 2) {\n                                            featureOpts.readframe = brf;\n                                            featureOpts.readframeExplicit = true;\n                                        }\n                                    }\n                                    var length = ts.max() - ts.min();\n                                    readingFrame = (readingFrame + length) % 3;\n                                    createFeature(chromId, ts.min() + 1, ts.max(), featureOpts);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } else {\n            throw Error(\"Don't know what to do with \" + this.bwg.type);\n        }\n    }\n\n    //\n    // nasty cut/paste, should roll back in!\n    //\n\n    BigWigView.prototype.getFirstAdjacent = function(chrName, pos, dir, callback) {\n        var chr = this.bwg.chromsToIDs[chrName];\n        if (chr === undefined) {\n            // Not an error because some .bwgs won't have data for all chromosomes.\n            return callback([]);\n        } else {\n            this.getFirstAdjacentById(chr, pos, dir, callback);\n        }\n    }\n\n    BigWigView.prototype.getFirstAdjacentById = function(chr, pos, dir, callback) {\n        var thisB = this;\n        if (!this.cirHeader) {\n            this.bwg.data.slice(this.cirTreeOffset, 48).fetch(function(result) {\n                thisB.cirHeader = result;\n                var la = new Int32Array(thisB.cirHeader);\n                thisB.cirBlockSize = la[1];\n                thisB.getFirstAdjacentById(chr, pos, dir, callback);\n            });\n            return;\n        }\n\n        var blockToFetch = null;\n        var bestBlockChr = -1;\n        var bestBlockOffset = -1;\n\n        var outstanding = 0;\n\n        var beforeBWG = Date.now();\n\n        var cirFobRecur = function(offset, level) {\n            outstanding += offset.length;\n\n            var maxCirBlockSpan = 4 +  (thisB.cirBlockSize * 32);   // Upper bound on size, based on a completely full leaf node.\n            var spans;\n            for (var i = 0; i < offset.length; ++i) {\n                var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);\n                spans = spans ? union(spans, blockSpan) : blockSpan;\n            }\n\n            var fetchRanges = spans.ranges();\n            for (var r = 0; r < fetchRanges.length; ++r) {\n                var fr = fetchRanges[r];\n                cirFobStartFetch(offset, fr, level);\n            }\n        }\n\n        var cirFobStartFetch = function(offset, fr, level, attempts) {\n            var length = fr.max() - fr.min();\n            thisB.bwg.data.slice(fr.min(), fr.max() - fr.min()).fetch(function(resultBuffer) {\n                for (var i = 0; i < offset.length; ++i) {\n                    if (fr.contains(offset[i])) {\n                        cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);\n                        --outstanding;\n                        if (outstanding == 0) {\n                            if (!blockToFetch) {\n                                if (dir > 0 && (chr != 0 || pos > 0)) {\n                                    return thisB.getFirstAdjacentById(0, 0, dir, callback);\n                                } else if (dir < 0 && (chr != thisB.bwg.maxID || pos < 1000000000)) {\n                                    return thisB.getFirstAdjacentById(thisB.bwg.maxID, 1000000000, dir, callback);\n                                }\n                                return callback([]);\n                            }\n\n                            thisB.fetchFeatures(function(chrx, fmin, fmax, toks) {\n                                return (dir < 0 && (chrx < chr || fmax < pos)) || (dir > 0 && (chrx > chr || fmin > pos));\n                            }, [blockToFetch], function(features) {\n                                var bestFeature = null;\n                                var bestChr = -1;\n                                var bestPos = -1;\n                                for (var fi = 0; fi < features.length; ++fi) {\n                                    var f = features[fi];\n                                    var chrx = f._chromId, fmin = f.min, fmax = f.max;\n                                    if (bestFeature == null || ((dir < 0) && (chrx > bestChr || fmax > bestPos)) || ((dir > 0) && (chrx < bestChr || fmin < bestPos))) {\n                                        bestFeature = f;\n                                        bestPos = (dir < 0) ? fmax : fmin;\n                                        bestChr = chrx;\n                                    }\n                                }\n\n                                if (bestFeature != null)\n                                return callback([bestFeature]);\n                                else\n                                return callback([]);\n                            });\n                        }\n                    }\n                }\n            });\n        }\n\n        var cirFobRecur2 = function(cirBlockData, offset, level) {\n            var ba = new Uint8Array(cirBlockData);\n            var sa = new Int16Array(cirBlockData);\n            var la = new Int32Array(cirBlockData);\n\n            var isLeaf = ba[offset];\n            var cnt = sa[offset/2 + 1];\n            offset += 4;\n\n            if (isLeaf != 0) {\n                for (var i = 0; i < cnt; ++i) {\n                    var lo = offset/4;\n                    var startChrom = la[lo];\n                    var startBase = la[lo + 1];\n                    var endChrom = la[lo + 2];\n                    var endBase = la[lo + 3];\n                    var blockOffset = bwg_readOffset(ba, offset+16);\n                    var blockSize = bwg_readOffset(ba, offset+24);\n                    if ((dir < 0 && ((startChrom < chr || (startChrom == chr && startBase <= pos)))) ||\n                    (dir > 0 && ((endChrom > chr || (endChrom == chr && endBase >= pos)))))\n                    {\n                        // console.log('Got an interesting block: startBase=' + startChrom + ':' + startBase + '; endBase=' + endChrom + ':' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);\n                        if (/_random/.exec(thisB.bwg.idsToChroms[startChrom])) {\n                            // dlog('skipping random: ' + thisB.bwg.idsToChroms[startChrom]);\n                        } else if (blockToFetch == null || ((dir < 0) && (endChrom > bestBlockChr || (endChrom == bestBlockChr && endBase > bestBlockOffset)) ||\n                        (dir > 0) && (startChrom < bestBlockChr || (startChrom == bestBlockChr && startBase < bestBlockOffset))))\n                        {\n                            //                        dlog('best is: startBase=' + startChrom + ':' + startBase + '; endBase=' + endChrom + ':' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);\n                            blockToFetch = {offset: blockOffset, size: blockSize};\n                            bestBlockOffset = (dir < 0) ? endBase : startBase;\n                            bestBlockChr = (dir < 0) ? endChrom : startChrom;\n                        }\n                    }\n                    offset += 32;\n                }\n            } else {\n                var bestRecur = -1;\n                var bestPos = -1;\n                var bestChr = -1;\n                for (var i = 0; i < cnt; ++i) {\n                    var lo = offset/4;\n                    var startChrom = la[lo];\n                    var startBase = la[lo + 1];\n                    var endChrom = la[lo + 2];\n                    var endBase = la[lo + 3];\n                    var blockOffset = (la[lo + 4]<<32) | (la[lo + 5]);\n                    if ((dir < 0 && ((startChrom < chr || (startChrom == chr && startBase <= pos)) &&\n                    (endChrom   >= chr))) ||\n                    (dir > 0 && ((endChrom > chr || (endChrom == chr && endBase >= pos)) &&\n                    (startChrom <= chr))))\n                    {\n                        if (bestRecur < 0 || endBase > bestPos) {\n                            bestRecur = blockOffset;\n                            bestPos = (dir < 0) ? endBase : startBase;\n                            bestChr = (dir < 0) ? endChrom : startChrom;\n                        }\n                    }\n                    offset += 24;\n                }\n                if (bestRecur >= 0) {\n                    cirFobRecur([bestRecur], level + 1);\n                }\n            }\n        };\n\n\n        cirFobRecur([thisB.cirTreeOffset + 48], 1);\n    }\n\n    /**\n    * Automatically choose a zoom level and return data from that level.\n    */\n    BigWig.prototype.readWigData = function(chrName, min, max) {\n        // Maximum number of data points to return when reading a bigwig. This is used\n        // to choose the appropriate level. One data point ~= 25-65 bytes.\n        // FIXME: For targeted sequencing, data points returned is going to be much lower,\n        // so this will need to be tuned appropriately.\n        var MAX_DATA_POINTS = 25000;\n\n        var range = max - min,\n        view;\n        // If no zooming needed or available (common in bigbed), use unzoomed view.\n        if (range <= MAX_DATA_POINTS || this.zoomLevels.length === 0) {\n            view = this.getUnzoomedView();\n        }\n        else {\n            // Find reasonable zoom level. Reduction is the # of bases represented\n            // by each data point at that level.\n            for (var i = 0; i < this.zoomLevels.length; i++) {\n                if (range/this.zoomLevels[i].reduction < MAX_DATA_POINTS) {\n                    view = this.getZoomedView(i);\n                    break;\n                }\n            }\n        }\n\n        return view.readWigData(chrName, min, max);\n    }\n\n    BigWig.prototype.getUnzoomedView = function() {\n        if (!this.unzoomedView) {\n            var cirLen = 4000;\n            var nzl = this.zoomLevels[0];\n            if (nzl) {\n                cirLen = this.zoomLevels[0].dataOffset - this.unzoomedIndexOffset;\n            }\n            this.unzoomedView = new BigWigView(this, this.unzoomedIndexOffset, cirLen, false);\n        }\n        return this.unzoomedView;\n    }\n\n    BigWig.prototype.getZoomedView = function(z) {\n        var zh = this.zoomLevels[z];\n        if (!zh.view) {\n            zh.view = new BigWigView(this, zh.indexOffset, /* this.zoomLevels[z + 1].dataOffset - zh.indexOffset */ 4000, true);\n        }\n        return zh.view;\n    }\n\n    /**\n     * Create a BigWig object using a URL to a bigwig/bigbed file. Returns a promise\n     * that resolves to the object when it's available.\n     */\n    function makeBwg(url) {\n        var promise = $.Deferred(),\n        bwg = new BigWig();\n        bwg.url = url;\n\n        // Read and parse bigwig header, including chrom tree.\n        $.when(read(bwg.url, 0, 512)).then(function(result) {\n            if (!result) {\n                return promise.resolve(null, \"Couldn't fetch file\");\n            }\n\n            var header = result;\n            var ba = new Uint8Array(header);\n            var sa = new Int16Array(header);\n            var la = new Int32Array(header);\n            var magic = ba[0] + (M1 * ba[1]) + (M2 * ba[2]) + (M3 * ba[3]);\n            if (magic == BIG_WIG_MAGIC) {\n                bwg.type = 'bigwig';\n            } else if (magic == BIG_BED_MAGIC) {\n                bwg.type = 'bigbed';\n            } else if (magic == BIG_WIG_MAGIC_BE || magic == BIG_BED_MAGIC_BE) {\n                return promise.resolve(null, \"Currently don't support big-endian BBI files\");\n\n            } else {\n                return promise.resolve(null, \"Not a supported format, magic=0x\" + magic.toString(16));\n\n            }\n\n            bwg.version = sa[2];             // 4\n            bwg.numZoomLevels = sa[3];       // 6\n            bwg.chromTreeOffset = bwg_readOffset(ba, 8);\n            bwg.unzoomedDataOffset = bwg_readOffset(ba, 16);\n            bwg.unzoomedIndexOffset = bwg_readOffset(ba, 24);\n            bwg.fieldCount = sa[16];         // 32\n            bwg.definedFieldCount = sa[17];  // 34\n            bwg.asOffset = bwg_readOffset(ba, 36);\n            bwg.totalSummaryOffset = bwg_readOffset(ba, 44);\n            bwg.uncompressBufSize = la[13];  // 52\n            bwg.extHeaderOffset = bwg_readOffset(ba, 56);\n\n            bwg.zoomLevels = [];\n            for (var zl = 0; zl < bwg.numZoomLevels; ++zl) {\n                var zlReduction = la[zl*6 + 16]\n                var zlData = bwg_readOffset(ba, zl*24 + 72);\n                var zlIndex = bwg_readOffset(ba, zl*24 + 80);\n                bwg.zoomLevels.push({reduction: zlReduction, dataOffset: zlData, indexOffset: zlIndex});\n            }\n\n            $.when(bwg.readChromTree()).then(function() {\n                bwg.getAutoSQL(function(as) {\n                    bwg.schema = as;\n                    return promise.resolve(bwg);\n                });\n            });\n        });\n\n        return promise;\n    }\n\n\n    BigWig.prototype._tsFetch = function(zoom, chr, min, max, callback) {\n        var bwg = this;\n        if (zoom >= this.zoomLevels.length - 1) {\n            if (!this.topLevelReductionCache) {\n                this.getZoomedView(this.zoomLevels.length - 1).readWigDataById(-1, 0, 300000000, function(feats) {\n                    bwg.topLevelReductionCache = feats;\n                    return bwg._tsFetch(zoom, chr, min, max, callback);\n                });\n            } else {\n                var f = [];\n                var c = this.topLevelReductionCache;\n                for (var fi = 0; fi < c.length; ++fi) {\n                    if (c[fi]._chromId == chr) {\n                        f.push(c[fi]);\n                    }\n                }\n                return callback(f);\n            }\n        } else {\n            var view;\n            if (zoom < 0) {\n                view = this.getUnzoomedView();\n            } else {\n                view = this.getZoomedView(zoom);\n            }\n            return view.readWigDataById(chr, min, max, callback);\n        }\n    }\n\n    BigWig.prototype.thresholdSearch = function(chrName, referencePoint, dir, threshold, callback) {\n        dir = (dir<0) ? -1 : 1;\n        var bwg = this;\n        var initialChr = this.chromsToIDs[chrName];\n        var candidates = [{chrOrd: 0, chr: initialChr, zoom: bwg.zoomLevels.length - 4, min: 0, max: 300000000, fromRef: true}]\n        for (var i = 1; i <= this.maxID + 1; ++i) {\n            var chrId = (initialChr + (dir*i)) % (this.maxID + 1);\n            if (chrId < 0)\n            chrId += (this.maxID + 1);\n            candidates.push({chrOrd: i, chr: chrId, zoom: bwg.zoomLevels.length - 1, min: 0, max: 300000000})\n        }\n\n        function fbThresholdSearchRecur() {\n            if (candidates.length == 0) {\n                return callback(null);\n            }\n            candidates.sort(function(c1, c2) {\n                var d = c1.zoom - c2.zoom;\n                if (d != 0)\n                return d;\n\n                d = c1.chrOrd - c2.chrOrd;\n                if (d != 0)\n                return d;\n                else\n                return c1.min - c2.min * dir;\n            });\n\n            var candidate = candidates.splice(0, 1)[0];\n            bwg._tsFetch(candidate.zoom, candidate.chr, candidate.min, candidate.max, function(feats) {\n                var rp = dir > 0 ? 0 : 300000000;\n                if (candidate.fromRef)\n                rp = referencePoint;\n\n                for (var fi = 0; fi < feats.length; ++fi) {\n                    var f = feats[fi];\n                    var score;\n                    if (f.maxScore != undefined)\n                    score = f.maxScore;\n                    else\n                    score = f.score;\n\n                    if (dir > 0) {\n                        if (score > threshold) {\n                            if (candidate.zoom < 0) {\n                                if (f.min > rp)\n                                return callback(f);\n                            } else if (f.max > rp) {\n                                candidates.push({chr: candidate.chr, chrOrd: candidate.chrOrd, zoom: candidate.zoom - 2, min: f.min, max: f.max, fromRef: candidate.fromRef});\n                            }\n                        }\n                    } else {\n                        if (score > threshold) {\n                            if (candidate.zoom < 0) {\n                                if (f.max < rp)\n                                return callback(f);\n                            } else if (f.min < rp) {\n                                candidates.push({chr: candidate.chr, chrOrd: candidate.chrOrd, zoom: candidate.zoom - 2, min: f.min, max: f.max, fromRef: candidate.fromRef});\n                            }\n                        }\n                    }\n                }\n                fbThresholdSearchRecur();\n            });\n        }\n\n        fbThresholdSearchRecur();\n    }\n\n    BigWig.prototype.getAutoSQL = function(callback) {\n        var thisB = this;\n        if (!this.asOffset)\n        return callback(null);\n\n        $.when(read(this.url, this.asOffset, 2048)).then(function(result) {\n            var ba = new Uint8Array(result);\n            var s = '';\n            for (var i = 0; i < ba.length; ++i) {\n                if (ba[i] == 0)\n                break;\n                s += String.fromCharCode(ba[i]);\n            }\n\n            /*\n            * Quick'n'dirty attempt to parse autoSql format.\n            * See: http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/059/5949/5949l2.html\n            */\n\n            var header_re = /(\\w+)\\s+(\\w+)\\s+(\"([^\"]+)\")?\\s+\\(\\s*/;\n                var field_re = /([\\w\\[\\]]+)\\s+(\\w+)\\s*;\\s*(\"([^\"]+)\")?\\s*/g;\n\n            var headerMatch = header_re.exec(s);\n            if (headerMatch) {\n                var as = {\n                    declType: headerMatch[1],\n                    name: headerMatch[2],\n                    comment: headerMatch[4],\n\n                    fields: []\n                };\n\n                s = s.substring(headerMatch[0]);\n                for (var m = field_re.exec(s); m != null; m = field_re.exec(s)) {\n                    as.fields.push({type: m[1],\n                        name: m[2],\n                        comment: m[4]});\n                    }\n\n                    return callback(as);\n                }\n        });\n    };\n\n    BigWig.prototype.getExtraIndices = function(callback) {\n        var thisB = this;\n        if (this.version < 4 || this.extHeaderOffset == 0 || this.type != 'bigbed') {\n            return callback(null);\n        } else {\n            this.data.slice(this.extHeaderOffset, 64).fetch(function(result) {\n                if (!result) {\n                    return callback(null, \"Couldn't fetch extension header\");\n                }\n\n                var ba = new Uint8Array(result);\n                var sa = new Int16Array(result);\n                var la = new Int32Array(result);\n\n                var extHeaderSize = sa[0];\n                var extraIndexCount = sa[1];\n                var extraIndexListOffset = bwg_readOffset(ba, 4);\n\n                if (extraIndexCount == 0) {\n                    return callback(null);\n                }\n\n                // FIXME 20byte records only make sense for single-field indices.\n                // Right now, these seem to be the only things around, but the format\n                // is actually more general.\n                thisB.data.slice(extraIndexListOffset, extraIndexCount * 20).fetch(function(eil) {\n                    if (!eil) {\n                        return callback(null, \"Couldn't fetch index info\");\n                    }\n\n                    var ba = new Uint8Array(eil);\n                    var sa = new Int16Array(eil);\n                    var la = new Int32Array(eil);\n\n                    var indices = [];\n                    for (var ii = 0; ii < extraIndexCount; ++ii) {\n                        var eiType = sa[ii*10];\n                        var eiFieldCount = sa[ii*10 + 1];\n                        var eiOffset = bwg_readOffset(ba, ii*20 + 4);\n                        var eiField = sa[ii*10 + 8]\n                        var index = new BBIExtraIndex(thisB, eiType, eiFieldCount, eiOffset, eiField);\n                        indices.push(index);\n                    }\n                    callback(indices);\n                });\n            });\n        }\n    }\n\n    function BBIExtraIndex(bbi, type, fieldCount, offset, field) {\n        this.bbi = bbi;\n        this.type = type;\n        this.fieldCount = fieldCount;\n        this.offset = offset;\n        this.field = field;\n    }\n\n    BBIExtraIndex.prototype.lookup = function(name, callback) {\n        var thisB = this;\n\n        this.bbi.data.slice(this.offset, 32).fetch(function(bpt) {\n            var ba = new Uint8Array(bpt);\n            var sa = new Int16Array(bpt);\n            var la = new Int32Array(bpt);\n            var bptMagic = la[0];\n            var blockSize = la[1];\n            var keySize = la[2];\n            var valSize = la[3];\n            var itemCount = bwg_readOffset(ba, 16);\n            var rootNodeOffset = 32;\n\n            function bptReadNode(nodeOffset) {\n                thisB.bbi.data.slice(nodeOffset, 4 + (blockSize * (keySize + valSize))).fetch(function(node) {\n                    var ba = new Uint8Array(node);\n                    var sa = new Uint16Array(node);\n                    var la = new Uint32Array(node);\n\n                    var nodeType = ba[0];\n                    var cnt = sa[1];\n\n                    var offset = 4;\n                    if (nodeType == 0) {\n                        var lastChildOffset = null;\n                        for (var n = 0; n < cnt; ++n) {\n                            var key = '';\n                            for (var ki = 0; ki < keySize; ++ki) {\n                                var charCode = ba[offset++];\n                                if (charCode != 0) {\n                                    key += String.fromCharCode(charCode);\n                                }\n                            }\n\n                            var childOffset = bwg_readOffset(ba, offset);\n                            offset += 8;\n\n                            if (name.localeCompare(key) < 0 && lastChildOffset) {\n                                bptReadNode(lastChildOffset);\n                                return;\n                            }\n                            lastChildOffset = childOffset;\n                        }\n                        bptReadNode(lastChildOffset);\n                    } else {\n                        for (var n = 0; n < cnt; ++n) {\n                            var key = '';\n                            for (var ki = 0; ki < keySize; ++ki) {\n                                var charCode = ba[offset++];\n                                if (charCode != 0) {\n                                    key += String.fromCharCode(charCode);\n                                }\n                            }\n\n                            // Specific for EI case.\n                            if (key == name) {\n                                var start = bwg_readOffset(ba, offset);\n                                var length = readInt(ba, offset + 8);\n\n                                return thisB.bbi.getUnzoomedView().fetchFeatures(\n                                    function(chr, min, max, toks) {\n                                        if (toks && toks.length > thisB.field - 3)\n                                        return toks[thisB.field - 3] == name;\n                                    },\n                                    [{offset: start, size: length}],\n                                    callback);\n                                }\n                                offset += valSize;\n                            }\n                            return callback([]);\n                        }\n                    });\n                }\n\n                bptReadNode(thisB.offset + rootNodeOffset);\n        });\n    }\n\n    return {\n        makeBwg: makeBwg\n    };\n});\n"]}