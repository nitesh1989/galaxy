{"version":3,"sources":["libs/bbi/spans.js"],"names":["define","Range","min","max","_min","this","_max","_Compound","ranges","sorted","sort","_rangeOrder","merged","forEach","shift","range","current","push","_ranges","union","s0","s1","insertRange","intersection","r0","l0","r1","l1","i0","length","i1","or","lapMin","lapMax","Math","coverage","s","tot","rl","ri","r","rangeOrder","a","b","prototype","pos","isContiguous","toString","lower_bound","m","contains","lb","splice","ub","rangeOver"],"mappings":"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","file":"../../../scripts/libs/bbi/spans.js","sourcesContent":["/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n//\n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// spans.js: JavaScript Intset/Location port.\n//\n\ndefine([], function() {\n\n\"use strict\";\n\n\nfunction Range(min, max)\n{\n    if (typeof(min) != 'number' || typeof(max) != 'number')\n        throw 'Bad range ' + min + ',' + max;\n    this._min = min;\n    this._max = max;\n}\n\nRange.prototype.min = function() {\n    return this._min;\n}\n\nRange.prototype.max = function() {\n    return this._max;\n}\n\nRange.prototype.contains = function(pos) {\n    return pos >= this._min && pos <= this._max;\n}\n\nRange.prototype.isContiguous = function() {\n    return true;\n}\n\nRange.prototype.ranges = function() {\n    return [this];\n}\n\nRange.prototype._pushRanges = function(ranges) {\n    ranges.push(this);\n}\n\nRange.prototype.toString = function() {\n    return '[' + this._min + '-' + this._max + ']';\n}\n\nfunction _Compound(ranges) {\n    // given: a set of unsorted possibly overlapping ranges\n    // sort the input ranges\n    var sorted = ranges.sort(_rangeOrder);\n    // merge overlaps between adjacent ranges\n    var merged = [];\n    var current = sorted.shift();\n    sorted.forEach(function(range) {\n        if (range._min <= current._max) {\n            if (range._max > current._max) {\n                current._max = range._max;\n            }\n        }\n        else {\n            merged.push(current);\n            current = range;\n        }\n    });\n    merged.push(current);\n    this._ranges = merged;\n}\n\n_Compound.prototype.min = function() {\n    return this._ranges[0].min();\n}\n\n_Compound.prototype.max = function() {\n    return this._ranges[this._ranges.length - 1].max();\n}\n\n// returns the index of the first range that is not less than pos\n_Compound.prototype.lower_bound = function(pos) {\n    // first check if pos is out of range\n    var r = this.ranges();\n    if (pos > this.max()) return r.length;\n    if (pos < this.min()) return 0;\n    // do a binary search\n    var a=0, b=r.length - 1;\n    while (a <= b) {\n        var m = Math.floor((a+b)/2);\n        if (pos > r[m]._max) {\n            a = m+1;\n        }\n        else if (pos < r[m]._min) {\n            b = m-1;\n        }\n        else {\n            return m;\n        }\n    }\n    return a;\n}\n\n_Compound.prototype.contains = function(pos) {\n    var lb = this.lower_bound(pos);\n    if (lb < this._ranges.length && this._ranges[lb].contains(pos)) {\n        return true;\n    }\n    return false;\n}\n\n_Compound.prototype.insertRange = function(range) {\n    var lb = this.lower_bound(range._min);\n    if (lb === this._ranges.length) { // range follows this\n        this._ranges.push(range);\n        return;\n    }\n\n    var r = this.ranges();\n    if (range._max < r[lb]._min) { // range preceeds lb\n        this._ranges.splice(lb,0,range);\n        return;\n    }\n\n    // range overlaps lb (at least)\n    if (r[lb]._min < range._min) range._min = r[lb]._min;\n    var ub = lb+1;\n    while (ub < r.length && r[ub]._min <= range._max) {\n        ub++;\n    }\n    ub--;\n    // ub is the upper bound of the new range\n    if (r[ub]._max > range._max) range._max = r[ub]._max;\n\n    // splice range into this._ranges\n    this._ranges.splice(lb,ub-lb+1,range);\n    return;\n}\n\n_Compound.prototype.isContiguous = function() {\n    return this._ranges.length > 1;\n}\n\n_Compound.prototype.ranges = function() {\n    return this._ranges;\n}\n\n_Compound.prototype._pushRanges = function(ranges) {\n    for (var ri = 0; ri < this._ranges.length; ++ri)\n        ranges.push(this._ranges[ri]);\n}\n\n_Compound.prototype.toString = function() {\n    var s = '';\n    for (var r = 0; r < this._ranges.length; ++r) {\n        if (r>0) {\n            s = s + ',';\n        }\n        s = s + this._ranges[r].toString();\n    }\n    return s;\n}\n\nfunction union(s0, s1) {\n    if (! (s0 instanceof _Compound)) {\n        if (! (s0 instanceof Array))\n            s0 = [s0];\n        s0 = new _Compound(s0);\n    }\n\n    if (s1)\n        s0.insertRange(s1);\n\n    return s0;\n}\n\nfunction intersection(s0, s1) {\n    var r0 = s0.ranges();\n    var r1 = s1.ranges();\n    var l0 = r0.length, l1 = r1.length;\n    var i0 = 0, i1 = 0;\n    var or = [];\n\n    while (i0 < l0 && i1 < l1) {\n        var s0 = r0[i0], s1 = r1[i1];\n        var lapMin = Math.max(s0.min(), s1.min());\n        var lapMax = Math.min(s0.max(), s1.max());\n        if (lapMax >= lapMin) {\n            or.push(new Range(lapMin, lapMax));\n        }\n        if (s0.max() > s1.max()) {\n            ++i1;\n        } else {\n            ++i0;\n        }\n    }\n\n    if (or.length == 0) {\n        return null; // FIXME\n    } else if (or.length == 1) {\n        return or[0];\n    } else {\n        return new _Compound(or);\n    }\n}\n\nfunction coverage(s) {\n    var tot = 0;\n    var rl = s.ranges();\n    for (var ri = 0; ri < rl.length; ++ri) {\n        var r = rl[ri];\n        tot += (r.max() - r.min() + 1);\n    }\n    return tot;\n}\n\n\n\nfunction rangeOrder(a, b)\n{\n    if (a.min() < b.min()) {\n        return -1;\n    } else if (a.min() > b.min()) {\n        return 1;\n    } else if (a.max() < b.max()) {\n        return -1;\n    } else if (b.max() > a.max()) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nfunction _rangeOrder(a, b)\n{\n    if (a._min < b._min) {\n        return -1;\n    } else if (a._min > b._min) {\n        return 1;\n    } else if (a._max < b._max) {\n        return -1;\n    } else if (b._max > a._max) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nreturn {\n        Range: Range,\n        union: union,\n        intersection: intersection,\n        coverage: coverage,\n        rangeOver: rangeOrder,\n        _rangeOrder: _rangeOrder\n};\n});\n"]}