{"version":3,"sources":["viz/trackster/painters.js"],"names":["_","compute_overlap","first_region","second_region","first_start","first_end","second_start","second_end","BEFORE","overlap","OVERLAP_START","dashedLine","ctx","dashLen","q","dX","x2","x1","dY","y2","y1","dashes","Math","floor","sqrt","dashX","dashY","fillRect","drawDownwardEquilateralTriangle","down_vertex_x","down_vertex_y","side_len","y","beginPath","moveTo","lineTo","strokeStyle","this","fillStyle","fill","stroke","Scaler","default_val","prototype","gen_val","input","DrawResults","options","feature_mapper","Painter","data","prefs","mode","view_start","view_end","default_prefs","get_start_draw_pos","chrom_pos","w_scale","_chrom_pos_to_draw_pos","offset","max","LinePainter","call","min_value","undefined","color","overflow_color","draw","width","height","max_value","vertical_range","height_px","save","round","x_scaled","delta_x_pxs","in_path","map","d","i","ceil","delta_x_px","painter_color","block_color","pref_color","parseInt","slice","pref_r","y_zero","pref_g","pref_b","top_overflow","length","len","bot_overflow","new_r","saturation","new_b","new_g","overflow_x","restore","FeaturePositionMapper","slot_height","feature_positions","translation","y_translation","map_feature_data","feature_data","slot","x_start","x_end","push","get_feature_data","x","feature_dict","alpha_scaler","height_scaler","max_label_length","FeaturePainter","connector_color","get_required_height","required_height","y_scale","rows_required","get_top_padding","slots","textAlign","get_row_height","incomplete_features","feature","feature_uid","feature_end","feature_start","x_draw_coords","draw_element","tile_low","tile_high","LinkedFeaturePainter","draw_background_connector","draw_individual_connectors","extend","PACK_TRACK_HEIGHT","PACK_FEATURE_HEIGHT","LABEL_SPACING","DENSE_TRACK_HEIGHT","NO_DETAIL_TRACK_HEIGHT","feature_name","SQUISH_TRACK_HEIGHT","f_end","min","draw_start","f_start","draw_end","y_start","thick_start","thick_end","feature_strand","reverse_strand_color","label_color","globalAlpha","feature_ts","full_height","feature_te","NO_DETAIL_FEATURE_HEIGHT","thin_height","thick_height","cur_y_start","cur_height","SQUISH_FEATURE_HEIGHT","get_pattern","canvas","manager","CONNECTOR_COLOR","last_block_end","block","feature_blocks","block_start","block_end","start_and_height","last_block_start","block_thick_start","block_thick_end","draw_connector","hscale_factor","new_height","ws_height","DENSE_FEATURE_HEIGHT","measureText","ref_seq","ReadPainter","show_insertions","_parse_cigar","cigar_str","blocks","cur_block","base_pos","op","op_len","indexOf","op_char","cigar_ops","cig_len","cigar","strand","read_seq","get_draw_coord","sequence_coord","s_start","s_end","tile_region","draw_height","pack_mode","base_offset","seq_offset","gap","paint_utils","ReadPainterUtils","char_width_px","drawing_blocks","detail_block_color","rect_y","draw_last","t","is_overlap","cig_id","seq_start","cig","update_base_offset","cur_seq","cig_op","c","show_differences","fillText","c_start","start_pos","base_color_fn","draw_deletion","insert_x_coord","seq","type","str_len","x_center","update_seq_offset","item","font","connector","draw_read","Array","b1_end","b2_start","longest_feature_length","line_height","radius","angle1","ArcLinkedFeaturePainter","rgb","calculate_longest_feature_length","split","Color","block1_start","block1_end","block2_start","block2_end","toCSS","PI","arc","join","alpha","isArray","h","match","s","substring","g","a","eval","concat","color1","weight","color2","p","toString","toHSL","w1","r","b","LinearRamp","start_color","end_color","start_value","value_range","value","end_value","l","toARGB","negative_ramp","middle_color","map_value","mix","w","DiagonalHeatmapPainter","Infinity","w2","pos_color","neg_color","SplitRamp","ramp","positive_ramp","rotate","s1","s2","scale","e2","row_height","px_per_base","draw_details","VariantPainter","thickness","invsqrt2","e1","num_samples","show_sample_data","delete_details_thickness","alt","ref","ref_len","sample_gts","draw_x_start","summary_height","divider_height","allele_counts","pos","variant","draw_y_start","genotype","j","get_indel_info","feature_height","draw_summary","alt_len","start","locus_data","base_px","flatten","indel_info","snp","allele_frac","get_draw_pos"],"mappings":"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","file":"../../../scripts/viz/trackster/painters.js","sourcesContent":["import * as _ from \"libs/underscore\";\n\n/**\n * Compute the type of overlap between two regions. They are assumed to be on the same chrom/contig.\n * The overlap is computed relative to the second region; hence, OVERLAP_START indicates that the first\n * region overlaps the start (but not the end) of the second region.\n * NOTE: Coordinates are assumed to be in BED format: half open (start is closed, end is open).\n */\nvar BEFORE = 1001;\n\nvar CONTAINS = 1002;\nvar OVERLAP_START = 1003;\nvar OVERLAP_END = 1004;\nvar CONTAINED_BY = 1005;\nvar AFTER = 1006;\nvar compute_overlap = (first_region, second_region) => {\n    var first_start = first_region[0];\n    var first_end = first_region[1];\n    var second_start = second_region[0];\n    var second_end = second_region[1];\n    var overlap;\n    if (first_start < second_start) {\n        if (first_end <= second_start) {\n            overlap = BEFORE;\n        } else if (first_end <= second_end) {\n            overlap = OVERLAP_START;\n        } else {\n            // first_end > second_end\n            overlap = CONTAINS;\n        }\n    } else {\n        // first_start >= second_start\n        if (first_start > second_end) {\n            overlap = AFTER;\n        } else if (first_end <= second_end) {\n            overlap = CONTAINED_BY;\n        } else {\n            overlap = OVERLAP_END;\n        }\n    }\n\n    return overlap;\n};\n\n/**\n * Returns true if regions overlap.\n */\nvar is_overlap = (first_region, second_region) => {\n    var overlap = compute_overlap(first_region, second_region);\n    return overlap !== BEFORE && overlap !== AFTER;\n};\n\n/**\n * Draw a dashed line on a canvas using filled rectangles. This function is based on:\n * http://vetruvet.blogspot.com/2010/10/drawing-dashed-lines-on-html5-canvas.html\n * However, that approach uses lines, which don't seem to render as well, so use\n * rectangles instead.\n */\nvar dashedLine = (ctx, x1, y1, x2, y2, dashLen) => {\n    if (dashLen === undefined) {\n        dashLen = 4;\n    }\n    var dX = x2 - x1;\n    var dY = y2 - y1;\n    var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n    var dashX = dX / dashes;\n    var dashY = dY / dashes;\n    var q;\n\n    for (q = 0; q < dashes; q++, x1 += dashX, y1 += dashY) {\n        if (q % 2 !== 0) {\n            continue;\n        }\n        ctx.fillRect(x1, y1, dashLen, 1);\n    }\n};\n\n/**\n * Draw an isosceles triangle that points down.\n */\nvar drawDownwardEquilateralTriangle = function(ctx, down_vertex_x, down_vertex_y, side_len) {\n    // Compute other two points of triangle.\n    var x1 = down_vertex_x - side_len / 2;\n\n    var x2 = down_vertex_x + side_len / 2;\n    var y = down_vertex_y - Math.sqrt(side_len * 3 / 2);\n\n    // Draw and fill.\n    ctx.beginPath();\n    ctx.moveTo(x1, y);\n    ctx.lineTo(x2, y);\n    ctx.lineTo(down_vertex_x, down_vertex_y);\n    ctx.lineTo(x1, y);\n\n    ctx.strokeStyle = this.fillStyle;\n    ctx.fill();\n    ctx.stroke();\n    ctx.closePath();\n};\n\n/**\n * Base class for all scalers. Scalers produce values that are used to change (scale) drawing attributes.\n */\nvar Scaler = function(default_val) {\n    this.default_val = default_val ? default_val : 1;\n};\n\n/**\n * Produce a scaling value.\n */\nScaler.prototype.gen_val = function(input) {\n    return this.default_val;\n};\n\n/**\n * Results from painter.draw()\n */\nvar DrawResults = function(options) {\n    this.incomplete_features = options.incomplete_features;\n    this.feature_mapper = options.feature_mapper;\n};\n\n/**\n * Base class for painters\n *\n * -- Mode and prefs are both optional\n */\nvar Painter = function(data, view_start, view_end, prefs, mode) {\n    // Data and data properties\n    this.data = data;\n    // View\n    this.view_start = view_start;\n    this.view_end = view_end;\n    // Drawing prefs\n    this.prefs = _.extend({}, this.default_prefs, prefs);\n    this.mode = mode;\n};\n\nPainter.prototype.default_prefs = {};\n\n/**\n * Draw on the context using a rectangle of width x height using scale w_scale.\n */\nPainter.prototype.draw = (ctx, width, height, w_scale) => {};\n\n/**\n * Get starting drawing position, which is offset a half-base left of coordinate.\n */\nPainter.prototype.get_start_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, -0.5);\n};\n\n/**\n * Get end drawing position, which is offset a half-base right of coordinate.\n */\nPainter.prototype.get_end_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0.5);\n};\n\n/**\n * Get drawing position.\n */\nPainter.prototype.get_draw_pos = function(chrom_pos, w_scale) {\n    return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0);\n};\n\n/**\n * Convert chromosome position to drawing position.\n */\nPainter.prototype._chrom_pos_to_draw_pos = function(chrom_pos, w_scale, offset) {\n    return Math.floor(w_scale * (Math.max(0, chrom_pos - this.view_start) + offset));\n};\n\nvar LinePainter = function(data, view_start, view_end, prefs, mode) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n};\n\nLinePainter.prototype.default_prefs = {\n    min_value: undefined,\n    max_value: undefined,\n    mode: \"Histogram\",\n    color: \"#000\",\n    overflow_color: \"#F66\"\n};\n\nLinePainter.prototype.draw = function(ctx, width, height, w_scale) {\n    var in_path = false;\n    var min_value = this.prefs.min_value;\n    var max_value = this.prefs.max_value;\n    var vertical_range = max_value - min_value;\n    var height_px = height;\n    var view_start = this.view_start;\n    var mode = this.mode;\n    var data = this.data;\n\n    ctx.save();\n\n    // Pixel position of 0 on the y axis\n    var y_zero = Math.round(height + min_value / vertical_range * height);\n\n    // Horizontal line to denote x-axis\n    if (mode !== \"Intensity\") {\n        ctx.fillStyle = \"#aaa\";\n        ctx.fillRect(0, y_zero, width, 1);\n    }\n\n    ctx.beginPath();\n    var x_scaled;\n    var y;\n    var delta_x_pxs;\n    if (data.length > 1) {\n        delta_x_pxs = _.map(data.slice(0, -1), (d, i) => Math.ceil((data[i + 1][0] - data[i][0]) * w_scale));\n    } else {\n        delta_x_pxs = [10];\n    }\n\n    // Painter color can be in either block_color (FeatureTrack) or color pref (LineTrack).\n    var painter_color = this.prefs.block_color || this.prefs.color;\n\n    var // Extract RGB from preference color.\n    pref_color = parseInt(painter_color.slice(1), 16);\n\n    var pref_r = (pref_color & 0xff0000) >> 16;\n    var pref_g = (pref_color & 0x00ff00) >> 8;\n    var pref_b = pref_color & 0x0000ff;\n    var top_overflow = false;\n    var bot_overflow = false;\n\n    // Paint track.\n    var delta_x_px;\n    for (var i = 0, len = data.length; i < len; i++) {\n        // Reset attributes for next point.\n        ctx.fillStyle = ctx.strokeStyle = painter_color;\n        top_overflow = bot_overflow = false;\n        delta_x_px = delta_x_pxs[i];\n\n        x_scaled = Math.floor((data[i][0] - view_start - 0.5) * w_scale);\n        y = data[i][1];\n\n        // Process Y (scaler) value.\n        if (y === null) {\n            if (in_path && mode === \"Filled\") {\n                ctx.lineTo(x_scaled, height_px);\n            }\n            in_path = false;\n            continue;\n        }\n\n        // Bound Y value by min, max.\n        if (y < min_value) {\n            bot_overflow = true;\n            y = min_value;\n        } else if (y > max_value) {\n            top_overflow = true;\n            y = max_value;\n        }\n\n        // Draw point.\n        if (mode === \"Histogram\") {\n            // y becomes the bar height in pixels, which is the negated for canvas coords\n            y = Math.round(y / vertical_range * height_px);\n            ctx.fillRect(x_scaled, y_zero, delta_x_px, -y);\n        } else if (mode === \"Intensity\") {\n            var saturation = (y - min_value) / vertical_range;\n\n            var // Range is [pref_color, 255] where saturation = 0 --> 255 and saturation = 1 --> pref color\n            new_r = Math.round(pref_r + (255 - pref_r) * (1 - saturation));\n\n            var new_g = Math.round(pref_g + (255 - pref_g) * (1 - saturation));\n            var new_b = Math.round(pref_b + (255 - pref_b) * (1 - saturation));\n            ctx.fillStyle = `rgb(${new_r},${new_g},${new_b})`;\n            ctx.fillRect(x_scaled, 0, delta_x_px, height_px);\n        } else {\n            // mode is Coverage/Line or Filled.\n\n            // Scale Y value.\n            y = Math.round(height_px - (y - min_value) / vertical_range * height_px);\n            if (in_path) {\n                ctx.lineTo(x_scaled, y);\n            } else {\n                in_path = true;\n                if (mode === \"Filled\") {\n                    ctx.moveTo(x_scaled, height_px);\n                    ctx.lineTo(x_scaled, y);\n                } else {\n                    ctx.moveTo(x_scaled, y);\n                    // Use this approach (note: same as for filled) to draw line from 0 to\n                    // first data point.\n                    //ctx.moveTo(x_scaled, height_px);\n                    //ctx.lineTo(x_scaled, y);\n                }\n            }\n        }\n\n        // Draw lines at boundaries if overflowing min or max\n        ctx.fillStyle = this.prefs.overflow_color;\n        if (top_overflow || bot_overflow) {\n            var overflow_x;\n            if (mode === \"Histogram\" || mode === \"Intensity\") {\n                overflow_x = delta_x_px;\n            } else {\n                // Line and Filled, which are points\n                x_scaled -= 2; // Move it over to the left so it's centered on the point\n                overflow_x = 4;\n            }\n            if (top_overflow) {\n                ctx.fillRect(x_scaled, 0, overflow_x, 3);\n            }\n            if (bot_overflow) {\n                ctx.fillRect(x_scaled, height_px - 3, overflow_x, 3);\n            }\n        }\n        ctx.fillStyle = painter_color;\n    }\n    if (mode === \"Filled\") {\n        if (in_path) {\n            ctx.lineTo(x_scaled, y_zero);\n            ctx.lineTo(0, y_zero);\n        }\n        ctx.fill();\n    } else {\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Mapper that contains information about feature locations and data.\n */\nvar FeaturePositionMapper = function(slot_height) {\n    this.feature_positions = {};\n    this.slot_height = slot_height;\n    this.translation = 0;\n    this.y_translation = 0;\n};\n\n/**\n * Map feature data to a position defined by <slot, x_start, x_end>.\n */\nFeaturePositionMapper.prototype.map_feature_data = function(feature_data, slot, x_start, x_end) {\n    if (!this.feature_positions[slot]) {\n        this.feature_positions[slot] = [];\n    }\n    this.feature_positions[slot].push({\n        data: feature_data,\n        x_start: x_start,\n        x_end: x_end\n    });\n};\n\n/**\n * Get feature data for position <x, y>\n */\nFeaturePositionMapper.prototype.get_feature_data = function(x, y) {\n    // Find slot using Y.\n    var slot = Math.floor((y - this.y_translation) / this.slot_height);\n\n    var feature_dict;\n\n    // May not be over a slot due to padding, margin, etc.\n    if (!this.feature_positions[slot]) {\n        return null;\n    }\n\n    // Find feature using X.\n    x += this.translation;\n    for (var i = 0; i < this.feature_positions[slot].length; i++) {\n        feature_dict = this.feature_positions[slot][i];\n        if (x >= feature_dict.x_start && x <= feature_dict.x_end) {\n            return feature_dict.data;\n        }\n    }\n};\n\n/**\n * Abstract object for painting feature tracks. Subclasses must implement draw_element() for painting to work.\n * Painter uses a 0-based, half-open coordinate system; start coordinate is closed--included--and the end is open.\n * This coordinate system matches the BED format.\n */\nvar FeaturePainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    this.alpha_scaler = alpha_scaler ? alpha_scaler : new Scaler();\n    this.height_scaler = height_scaler ? height_scaler : new Scaler();\n    this.max_label_length = 200;\n};\n\nFeaturePainter.prototype.default_prefs = {\n    block_color: \"#FFF\",\n    connector_color: \"#FFF\"\n};\n\n_.extend(FeaturePainter.prototype, {\n    get_required_height: function(rows_required, width) {\n        // y_scale is the height per row\n        var required_height = this.get_row_height();\n\n        var y_scale = required_height;\n        var mode = this.mode;\n        // If using a packing mode, need to multiply by the number of slots used\n        if (mode === \"no_detail\" || mode === \"Squish\" || mode === \"Pack\") {\n            required_height = rows_required * y_scale;\n        }\n        return required_height + this.get_top_padding(width);\n    },\n\n    /** Extra padding before first row of features */\n    get_top_padding: function(width) {\n        return 0;\n    },\n\n    /**\n     * Draw data on ctx using slots and within the rectangle defined by width and height. Returns\n     * a FeaturePositionMapper object with information about where features were drawn.\n     */\n    draw: function(ctx, width, height, w_scale, slots) {\n        var data = this.data;\n        var view_start = this.view_start;\n        var view_end = this.view_end;\n\n        ctx.save();\n\n        ctx.fillStyle = this.prefs.block_color;\n        ctx.textAlign = \"right\";\n\n        var y_scale = this.get_row_height();\n        var feature_mapper = new FeaturePositionMapper(y_scale);\n        var x_draw_coords;\n        var incomplete_features = [];\n\n        for (var i = 0, len = data.length; i < len; i++) {\n            var feature = data[i];\n            var feature_uid = feature[0];\n            var feature_start = feature[1];\n            var feature_end = feature[2];\n\n            var // Slot valid only if features are slotted and this feature is slotted;\n            // feature may not be due to lack of space.\n            slot = slots && slots[feature_uid] !== undefined ? slots[feature_uid].slot : null;\n\n            // Draw feature if (a) mode is dense or feature is slotted (as it must be for all non-dense modes) and\n            // (b) there's overlap between the feature and drawing region.\n            if ((this.mode === \"Dense\" || slot !== null) && (feature_start < view_end && feature_end > view_start)) {\n                x_draw_coords = this.draw_element(\n                    ctx,\n                    this.mode,\n                    feature,\n                    slot,\n                    view_start,\n                    view_end,\n                    w_scale,\n                    y_scale,\n                    width\n                );\n                feature_mapper.map_feature_data(feature, slot, x_draw_coords[0], x_draw_coords[1]);\n\n                // Add to incomplete features if it's not drawn completely in region.\n                if (feature_start < view_start || feature_end > view_end) {\n                    incomplete_features.push(feature);\n                }\n            }\n        }\n\n        ctx.restore();\n\n        feature_mapper.y_translation = this.get_top_padding(width);\n        return new DrawResults({\n            incomplete_features: incomplete_features,\n            feature_mapper: feature_mapper\n        });\n    },\n\n    /**\n     * Abstract function for drawing an individual feature.\n     */\n    draw_element: function(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width) {\n        return [0, 0];\n    }\n});\n\n// Constants specific to feature tracks moved here (HACKING, these should\n// basically all be configuration options)\nvar DENSE_TRACK_HEIGHT = 10;\n\nvar NO_DETAIL_TRACK_HEIGHT = 3;\nvar SQUISH_TRACK_HEIGHT = 5;\nvar PACK_TRACK_HEIGHT = 10;\nvar NO_DETAIL_FEATURE_HEIGHT = 1;\nvar DENSE_FEATURE_HEIGHT = 9;\nvar SQUISH_FEATURE_HEIGHT = 3;\nvar PACK_FEATURE_HEIGHT = 9;\nvar LABEL_SPACING = 2;\nvar CONNECTOR_COLOR = \"#ccc\";\n\nvar LinkedFeaturePainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n    FeaturePainter.call(this, data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n    // Whether to draw a single connector in the background that spans the entire feature (the intron fishbone)\n    this.draw_background_connector = true;\n    // Whether to call draw_connector for every pair of blocks\n    this.draw_individual_connectors = false;\n};\n\n_.extend(LinkedFeaturePainter.prototype, FeaturePainter.prototype, {\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height: function() {\n        var mode = this.mode;\n        var height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"no_detail\") {\n            height = NO_DETAIL_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    },\n\n    /**\n     * Draw a feature. Returns an array with feature's start and end X coordinates.\n     */\n    draw_element: function(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width) {\n        var feature_uid = feature[0];\n        var feature_start = feature[1];\n        var feature_end = feature[2];\n        var feature_name = feature[3];\n        var feature_strand = feature[4];\n\n        var // -0.5 to offset region between bases.\n        f_start = Math.floor(Math.max(0, (feature_start - tile_low - 0.5) * w_scale));\n\n        var f_end = Math.ceil(Math.min(width, Math.max(0, (feature_end - tile_low - 0.5) * w_scale)));\n\n        var draw_start = f_start;\n        var draw_end = f_end;\n\n        var y_start = (mode === \"Dense\" ? 0 : 0 + slot) * y_scale + this.get_top_padding(width);\n\n        var thickness;\n        var y_start;\n        var thick_start = null;\n        var thick_end = null;\n\n        var // TODO: is there any reason why block, label color cannot be set at the Painter level?\n        // For now, assume '.' === '+'\n        block_color =\n            !feature_strand || feature_strand === \"+\" || feature_strand === \".\"\n                ? this.prefs.block_color\n                : this.prefs.reverse_strand_color;\n\n        var label_color = this.prefs.label_color;\n\n        // Set global alpha.\n        ctx.globalAlpha = this.alpha_scaler.gen_val(feature);\n\n        // In dense mode, put all data in top slot.\n        if (mode === \"Dense\") {\n            slot = 1;\n        }\n\n        if (mode === \"no_detail\") {\n            // No details for feature, so only one way to display.\n            ctx.fillStyle = block_color;\n            ctx.fillRect(f_start, y_start + 5, f_end - f_start, NO_DETAIL_FEATURE_HEIGHT);\n        } else {\n            // Mode is either Squish or Pack:\n            // Feature details.\n            var feature_ts = feature[5];\n\n            var feature_te = feature[6];\n            var feature_blocks = feature[7];\n\n            var // Whether we are drawing full height or squished features\n            full_height = true;\n\n            if (feature_ts && feature_te) {\n                thick_start = Math.floor(Math.max(0, (feature_ts - tile_low) * w_scale));\n                thick_end = Math.ceil(Math.min(width, Math.max(0, (feature_te - tile_low) * w_scale)));\n            }\n\n            // Set vars that depend on mode.\n            var thin_height;\n\n            var thick_height;\n            if (mode === \"Squish\") {\n                thin_height = 1;\n                thick_height = SQUISH_FEATURE_HEIGHT;\n                full_height = false;\n            } else if (mode === \"Dense\") {\n                thin_height = 5;\n                thick_height = DENSE_FEATURE_HEIGHT;\n            } else {\n                // mode === \"Pack\"\n                thin_height = 5;\n                thick_height = PACK_FEATURE_HEIGHT;\n            }\n\n            // Draw feature/feature blocks + connectors.\n            if (!feature_blocks) {\n                // If there are no blocks, treat the feature as one big exon.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(f_start, y_start + 1, f_end - f_start, thick_height);\n                // If strand is specified, draw arrows over feature\n                if (feature_strand && full_height) {\n                    if (feature_strand === \"+\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern(\"right_strand_inv\");\n                    } else if (feature_strand === \"-\") {\n                        ctx.fillStyle = ctx.canvas.manager.get_pattern(\"left_strand_inv\");\n                    }\n                    ctx.fillRect(f_start, y_start + 1, f_end - f_start, thick_height);\n                }\n            } else {\n                //\n                // There are feature blocks and mode is either Squish or Pack.\n                //\n                // Approach: (a) draw whole feature as connector/intron and (b) draw blocks as\n                // needed. This ensures that whole feature, regardless of whether it starts with\n                // a block, is visible.\n                //\n\n                // Compute y axis start position and height\n                var cur_y_start;\n\n                var cur_height;\n                if (mode === \"Squish\" || mode === \"Dense\") {\n                    cur_y_start = y_start + Math.floor(SQUISH_FEATURE_HEIGHT / 2) + 1;\n                    cur_height = 1;\n                } else {\n                    // mode === \"Pack\"\n                    if (feature_strand) {\n                        cur_y_start = y_start;\n                        cur_height = thick_height;\n                    } else {\n                        cur_y_start += SQUISH_FEATURE_HEIGHT / 2 + 1;\n                        cur_height = 1;\n                    }\n                }\n\n                // Draw whole feature as connector/intron.\n                if (this.draw_background_connector) {\n                    if (mode === \"Squish\" || mode === \"Dense\") {\n                        ctx.fillStyle = CONNECTOR_COLOR;\n                    } else {\n                        // mode === \"Pack\"\n                        if (feature_strand) {\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\"right_strand\");\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\"left_strand\");\n                            }\n                        } else {\n                            ctx.fillStyle = CONNECTOR_COLOR;\n                        }\n                    }\n                    ctx.fillRect(f_start, cur_y_start, f_end - f_start, cur_height);\n                }\n\n                // Draw blocks.\n                var start_and_height;\n                for (var k = 0, k_len = feature_blocks.length; k < k_len; k++) {\n                    var block = feature_blocks[k];\n\n                    var // -0.5 to offset block between bases.\n                    block_start = Math.floor(Math.max(0, (block[0] - tile_low - 0.5) * w_scale));\n\n                    var block_end = Math.ceil(Math.min(width, Math.max((block[1] - tile_low - 0.5) * w_scale)));\n\n                    var last_block_start;\n                    var last_block_end;\n\n                    // Skip drawing if block not on tile.\n                    if (block_start > block_end) {\n                        continue;\n                    }\n\n                    // Draw thin block.\n                    ctx.fillStyle = block_color;\n                    ctx.fillRect(\n                        block_start,\n                        y_start + (thick_height - thin_height) / 2 + 1,\n                        block_end - block_start,\n                        thin_height\n                    );\n\n                    // If block intersects with thick region, draw block as thick.\n                    // - No thick is sometimes encoded as thick_start == thick_end, so don't draw in that case\n                    if (\n                        thick_start !== undefined &&\n                        feature_te > feature_ts &&\n                        !(block_start > thick_end || block_end < thick_start)\n                    ) {\n                        var block_thick_start = Math.max(block_start, thick_start);\n\n                        var block_thick_end = Math.min(block_end, thick_end);\n                        ctx.fillRect(block_thick_start, y_start + 1, block_thick_end - block_thick_start, thick_height);\n                        if (feature_blocks.length === 1 && mode === \"Pack\") {\n                            // Exactly one block means we have no introns, but do have a distinct \"thick\" region,\n                            // draw arrows over it if in pack mode.\n                            if (feature_strand === \"+\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\"right_strand_inv\");\n                            } else if (feature_strand === \"-\") {\n                                ctx.fillStyle = ctx.canvas.manager.get_pattern(\"left_strand_inv\");\n                            }\n                            // If region is wide enough in pixels, pad a bit\n                            if (block_thick_start + 14 < block_thick_end) {\n                                block_thick_start += 2;\n                                block_thick_end -= 2;\n                            }\n                            ctx.fillRect(\n                                block_thick_start,\n                                y_start + 1,\n                                block_thick_end - block_thick_start,\n                                thick_height\n                            );\n                        }\n                    }\n                    // Draw individual connectors if required\n                    if (this.draw_individual_connectors && last_block_start) {\n                        this.draw_connector(ctx, last_block_start, last_block_end, block_start, block_end, y_start);\n                    }\n                    last_block_start = block_start;\n                    last_block_end = block_end;\n                }\n\n                // FIXME: Height scaling only works in Pack mode right now.\n                if (mode === \"Pack\") {\n                    // Reset alpha so height scaling is not impacted by alpha scaling.\n                    ctx.globalAlpha = 1;\n\n                    // Height scaling: draw white lines to reduce height according to height scale factor.\n                    ctx.fillStyle = \"white\"; // TODO: set this to background color.\n                    var hscale_factor = this.height_scaler.gen_val(feature);\n\n                    var // Ceil ensures that min height is >= 1.\n                    new_height = Math.ceil(thick_height * hscale_factor);\n\n                    var ws_height = Math.round((thick_height - new_height) / 2);\n                    if (hscale_factor !== 1) {\n                        ctx.fillRect(f_start, cur_y_start + 1, f_end - f_start, ws_height);\n                        ctx.fillRect(f_start, cur_y_start + thick_height - ws_height + 1, f_end - f_start, ws_height);\n                    }\n                }\n            }\n\n            // Reset alpha so that label is not transparent.\n            ctx.globalAlpha = 1;\n\n            // Draw label for Pack mode.\n            if (feature_name && mode === \"Pack\" && feature_start > tile_low) {\n                ctx.fillStyle = label_color;\n                // FIXME: assumption here that the entire view starts at 0\n                if (tile_low === 0 && f_start - ctx.measureText(feature_name).width < 0) {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(feature_name, f_end + LABEL_SPACING, y_start + 8, this.max_label_length);\n                    draw_end += ctx.measureText(feature_name).width + LABEL_SPACING;\n                } else {\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(feature_name, f_start - LABEL_SPACING, y_start + 8, this.max_label_length);\n                    draw_start -= ctx.measureText(feature_name).width + LABEL_SPACING;\n                }\n                //ctx.fillStyle = block_color;\n            }\n        }\n\n        // Reset global alpha.\n        ctx.globalAlpha = 1;\n\n        return [draw_start, draw_end];\n    }\n});\n\nvar ReadPainter = function(\n    data,\n    view_start,\n    view_end,\n    prefs,\n    mode,\n    alpha_scaler,\n    height_scaler,\n    ref_seq,\n    base_color_fn\n) {\n    FeaturePainter.call(this, data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n    this.ref_seq = ref_seq ? ref_seq.data : null;\n    this.base_color_fn = base_color_fn;\n};\n\n_.extend(ReadPainter.prototype, FeaturePainter.prototype, {\n    /**\n     * Returns height based on mode.\n     */\n    get_row_height: function() {\n        var height;\n        var mode = this.mode;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n            if (this.prefs.show_insertions) {\n                height *= 2;\n            }\n        }\n        return height;\n    },\n\n    /**\n     * Parse CIGAR string to get (a) a list of contiguous drawing blocks (MD=X) and\n     * (b) an array of [ op_index, op_len ] pairs where op_index is an index into the\n     * string 'MIDNSHP=X' Return value is a dictionary with two entries, blocks and cigar\n     */\n    _parse_cigar: function(cigar_str) {\n        var cigar_ops = \"MIDNSHP=X\";\n\n        // Parse cigar.\n        var blocks = [[0, 0]];\n\n        var cur_block = blocks[0];\n        var base_pos = 0;\n\n        var // Parse cigar operations out and update/create blocks as needed.\n        parsed_cigar = _.map(cigar_str.match(/[0-9]+[MIDNSHP=X]/g), op => {\n            // Get operation length, character.\n            var op_len = parseInt(op.slice(0, -1), 10),\n                op_char = op.slice(-1);\n\n            // Update drawing block.\n            if (op_char === \"N\") {\n                // At skip, so need to start new block if current block represents\n                // drawing area.\n                if (cur_block[1] !== 0) {\n                    cur_block = [base_pos + op_len, base_pos + op_len];\n                    blocks.push(cur_block);\n                }\n            } else if (\"ISHP\".indexOf(op_char) === -1) {\n                // Operation is M,D,=,X.\n                cur_block[1] += op_len;\n                base_pos += op_len;\n            }\n\n            // Return parsed cigar.\n            return [cigar_ops.indexOf(op_char), op_len];\n        });\n\n        return {\n            blocks: blocks,\n            cigar: parsed_cigar\n        };\n    },\n\n    /**\n     * Draw a single read from reference-based read sequence and cigar.\n     */\n    draw_read: function(ctx, mode, w_scale, y_start, tile_low, tile_high, feature_start, cigar, strand, read_seq) {\n        // Helper function to update base and sequnence offsets.\n        var update_base_offset = (offset, cig_op, cig_len) => {\n            if (\"M=NXD\".indexOf(cig_op) !== -1) {\n                offset += cig_len;\n            }\n            return offset;\n        };\n\n        var update_seq_offset = (offset, cig_op, cig_len) => {\n            if (\"IX\".indexOf(cig_op) !== -1) {\n                offset += cig_len;\n            }\n            return offset;\n        };\n\n        var // Gets drawing coordinate for a sequence coordinate. Assumes closure variables w_scale and tile_low.\n        get_draw_coord = (\n            sequence_coord // -0.5 to offset sequence between bases.\n        ) => Math.floor(Math.max(0, (sequence_coord - tile_low - 0.5) * w_scale));\n\n        ctx.textAlign = \"center\";\n        var tile_region = [tile_low, tile_high];\n        var base_offset = 0;\n        var seq_offset = 0;\n        var gap = Math.round(w_scale / 2);\n        var char_width_px = ctx.canvas.manager.char_width_px;\n\n        var block_color = strand === \"+\" ? this.prefs.detail_block_color : this.prefs.reverse_strand_color;\n\n        var pack_mode = mode === \"Pack\";\n\n        var draw_height = pack_mode ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT;\n\n        var rect_y = y_start + 1;\n        var paint_utils = new ReadPainterUtils(ctx, draw_height, w_scale, mode);\n        var drawing_blocks = [];\n        var s_start;\n        var s_end;\n\n        // Keep list of items that need to be drawn on top of initial drawing layer.\n        var draw_last = [];\n\n        // Parse cigar and get drawing blocks.\n        var t = this._parse_cigar(cigar);\n        cigar = t.cigar;\n        drawing_blocks = t.blocks;\n\n        // Draw blocks.\n        for (var i = 0; i < drawing_blocks.length; i++) {\n            var block = drawing_blocks[i];\n\n            if (is_overlap([feature_start + block[0], feature_start + block[1]], tile_region)) {\n                s_start = get_draw_coord(feature_start + block[0]);\n                s_end = get_draw_coord(feature_start + block[1]);\n\n                // Make sure that block is drawn even if it too small to be rendered officially; in this case,\n                // read is drawn at 1px.\n                // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n                // and drawing.\n                if (s_start === s_end) {\n                    s_end += 1;\n                }\n\n                // Draw read base as rectangle.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(s_start, rect_y, s_end - s_start, draw_height);\n            }\n        }\n\n        // Draw read features.\n        for (var cig_id = 0, len = cigar.length; cig_id < len; cig_id++) {\n            var cig = cigar[cig_id];\n            var cig_op = \"MIDNSHP=X\"[cig[0]];\n            var cig_len = cig[1];\n\n            var seq_start = feature_start + base_offset;\n            s_start = get_draw_coord(seq_start);\n            s_end = get_draw_coord(seq_start + cig_len);\n\n            // Skip feature if it's not in tile.\n            if (!is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                // Update offsets.\n                base_offset = update_base_offset(base_offset, cig_op, cig_len);\n                seq_offset = update_seq_offset(seq_offset, cig_op, cig_len);\n                continue;\n            }\n\n            // Make sure that read is drawn even if it too small to be rendered officially; in this case,\n            // read is drawn at 1px.\n            // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n            // and drawing.\n            if (s_start === s_end) {\n                s_end += 1;\n            }\n\n            // Draw read feature.\n            switch (cig_op) {\n                case \"H\": // Hard clipping.\n                case \"S\": // Soft clipping.\n                case \"P\": // Padding.\n                    // Sequence not present and not related to alignment; do nothing.\n                    break;\n                case \"M\": // \"Match\".\n                    // Because it's not known whether there is a match, ignore.\n                    base_offset += cig_len;\n                    break;\n                case \"=\": // Match with reference.\n                case \"X\": // Mismatch with reference.\n                    //\n                    // Draw sequence and/or variants.\n                    //\n\n                    // Get sequence to draw.\n                    var cur_seq = \"\";\n                    if (cig_op === \"X\") {\n                        // Get sequence from read_seq.\n                        cur_seq = read_seq.slice(seq_offset, seq_offset + cig_len);\n                    } else if (this.ref_seq) {\n                        // && cig_op === '='\n                        // Use reference sequence.\n                        cur_seq = this.ref_seq.slice(\n                            // If read starts after tile start, slice at read start.\n                            Math.max(0, seq_start - tile_low),\n                            // If read ends before tile end, slice at read end.\n                            Math.min(seq_start - tile_low + cig_len, tile_high - tile_low)\n                        );\n                    }\n\n                    // Draw sequence. Because cur_seq starts and read/tile start, go to there to start writing.\n                    var start_pos = Math.max(seq_start, tile_low);\n                    for (var c = 0; c < cur_seq.length; c++) {\n                        // Draw base if showing all (i.e. not showing differences) or there is a mismatch.\n                        if ((cur_seq && !this.prefs.show_differences) || cig_op === \"X\") {\n                            // Draw base.\n                            var c_start = Math.floor(Math.max(0, (start_pos + c - tile_low) * w_scale));\n                            ctx.fillStyle = this.base_color_fn(cur_seq[c]);\n                            if (pack_mode && w_scale > char_width_px) {\n                                ctx.fillText(cur_seq[c], c_start, y_start + 9);\n                            } else if (w_scale > 0.05) {\n                                // Require a minimum w_scale so that variants are only drawn when somewhat zoomed in.\n                                ctx.fillRect(c_start - gap, rect_y, Math.max(1, Math.round(w_scale)), draw_height);\n                            }\n                        }\n                    }\n\n                    // Move forward in sequence only if sequence used to get mismatches.\n                    if (cig_op === \"X\") {\n                        seq_offset += cig_len;\n                    }\n                    base_offset += cig_len;\n\n                    break;\n                case \"N\": // Skipped bases.\n                    ctx.fillStyle = CONNECTOR_COLOR;\n                    ctx.fillRect(s_start, rect_y + (draw_height - 1) / 2, s_end - s_start, 1);\n                    // No change in seq_offset because sequence not used when skipping.\n                    base_offset += cig_len;\n                    break;\n                case \"D\": // Deletion.\n                    paint_utils.draw_deletion(s_start, rect_y, cig_len);\n                    base_offset += cig_len;\n                    break;\n                case \"I\": // Insertion.\n                    // Check to see if sequence should be drawn at all by looking at the overlap between\n                    // the sequence region and the tile region.\n                    var insert_x_coord = s_start - gap;\n\n                    if (is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                        var seq = read_seq.slice(seq_offset, seq_offset + cig_len);\n                        // Insertion point is between the sequence start and the previous base: (-gap) moves\n                        // back from sequence start to insertion point.\n                        if (this.prefs.show_insertions) {\n                            //\n                            // Show inserted sequence above, centered on insertion point.\n                            //\n\n                            // Draw sequence.\n                            // X center is offset + start - <half_sequence_length>\n                            var x_center = s_start - (s_end - s_start) / 2;\n                            if (\n                                (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                read_seq !== undefined &&\n                                w_scale > char_width_px\n                            ) {\n                                // Draw sequence container.\n                                ctx.fillStyle = \"yellow\";\n                                ctx.fillRect(x_center - gap, y_start - 9, s_end - s_start, 9);\n                                draw_last[draw_last.length] = {\n                                    type: \"triangle\",\n                                    data: [insert_x_coord, y_start + 4, 5]\n                                };\n                                ctx.fillStyle = CONNECTOR_COLOR;\n                                // Based on overlap b/t sequence and tile, get sequence to be drawn.\n                                switch (compute_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                                    case OVERLAP_START:\n                                        seq = seq.slice(tile_low - seq_start);\n                                        break;\n                                    case OVERLAP_END:\n                                        seq = seq.slice(0, seq_start - tile_high);\n                                        break;\n                                    case CONTAINED_BY:\n                                        // All of sequence drawn.\n                                        break;\n                                    case CONTAINS:\n                                        seq = seq.slice(tile_low - seq_start, seq_start - tile_high);\n                                        break;\n                                }\n                                // Draw sequence.\n                                for (var c = 0, str_len = seq.length; c < str_len; c++) {\n                                    var c_start = Math.floor(Math.max(0, (seq_start + c - tile_low) * w_scale));\n                                    ctx.fillText(seq[c], c_start - (s_end - s_start) / 2, y_start);\n                                }\n                            } else {\n                                // Draw block.\n                                ctx.fillStyle = \"yellow\";\n                                // TODO: This is a pretty hack-ish way to fill rectangle based on mode.\n                                ctx.fillRect(\n                                    x_center,\n                                    y_start + (this.mode !== \"Dense\" ? 2 : 5),\n                                    s_end - s_start,\n                                    mode !== \"Dense\" ? SQUISH_FEATURE_HEIGHT : DENSE_FEATURE_HEIGHT\n                                );\n                            }\n                        } else {\n                            if (\n                                (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                read_seq !== undefined &&\n                                w_scale > char_width_px\n                            ) {\n                                // Show insertions with a single number at the insertion point.\n                                draw_last.push({\n                                    type: \"text\",\n                                    data: [seq.length, insert_x_coord, y_start + 9]\n                                });\n                            } else {\n                                // TODO: probably can merge this case with code above.\n                            }\n                        }\n                    }\n                    seq_offset += cig_len;\n                    // No change to base offset because insertions are drawn above sequence/read.\n                    break;\n            }\n        }\n\n        //\n        // Draw last items.\n        //\n        ctx.fillStyle = \"yellow\";\n        var item;\n        var type;\n        var data;\n        for (var i = 0; i < draw_last.length; i++) {\n            item = draw_last[i];\n            type = item.type;\n            data = item.data;\n            if (type === \"text\") {\n                ctx.save();\n                ctx.font = `bold ${ctx.font}`;\n                ctx.fillText(data[0], data[1], data[2]);\n                ctx.restore();\n            } else if (type === \"triangle\") {\n                drawDownwardEquilateralTriangle(ctx, data[0], data[1], data[2]);\n            }\n        }\n    },\n\n    /**\n     * Draw a complete read pair\n     */\n    draw_element: function(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width) {\n        // All features need a start, end, and vertical center.\n        var feature_uid = feature[0];\n\n        var feature_start = feature[1];\n        var feature_end = feature[2];\n        var feature_name = feature[3];\n\n        var // -0.5 to put element between bases.\n        f_start = Math.floor(Math.max(-0.5 * w_scale, (feature_start - tile_low - 0.5) * w_scale));\n\n        var f_end = Math.ceil(Math.min(width, Math.max(0, (feature_end - tile_low - 0.5) * w_scale)));\n\n        var y_start = (mode === \"Dense\" ? 0 : 0 + slot) * y_scale;\n\n        var draw_height = mode === \"Pack\" ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT;\n\n        var label_color = this.prefs.label_color;\n\n        // Draw read.\n        if (feature[5] instanceof Array) {\n            // Read is paired.\n            var connector = true;\n\n            // Draw left/forward read.\n            if (feature[4][1] >= tile_low && feature[4][0] <= tile_high && feature[4][2]) {\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature[4][0],\n                    feature[4][2],\n                    feature[4][3],\n                    feature[4][4]\n                );\n            } else {\n                connector = false;\n            }\n\n            // Draw right/reverse read.\n            if (feature[5][1] >= tile_low && feature[5][0] <= tile_high && feature[5][2]) {\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature[5][0],\n                    feature[5][2],\n                    feature[5][3],\n                    feature[5][4]\n                );\n            } else {\n                connector = false;\n            }\n\n            // Draw connector if both reads were drawn.\n            // TODO: currently, there is no way to connect reads drawn on different tiles; to connect reads on different tiles, data manager\n            // code is needed to join mate pairs from different regions. Alternatively, requesting multiple regions of data at once would\n            // make it possible to put together more easily.\n            // -0.5 to position connector correctly between reads.\n            var b1_end = Math.ceil(\n                Math.min(width, Math.max(-0.5 * w_scale, (feature[4][1] - tile_low - 0.5) * w_scale))\n            );\n\n            var b2_start = Math.floor(Math.max(-0.5 * w_scale, (feature[5][0] - tile_low - 0.5) * w_scale));\n\n            if (connector && b2_start > b1_end) {\n                ctx.fillStyle = CONNECTOR_COLOR;\n                var line_height = y_start + 1 + (draw_height - 1) / 2;\n                dashedLine(ctx, b1_end, line_height, b2_start, line_height);\n            }\n        } else {\n            // Read is single.\n            this.draw_read(\n                ctx,\n                mode,\n                w_scale,\n                y_start,\n                tile_low,\n                tile_high,\n                feature_start,\n                feature[4],\n                feature[5],\n                feature[6]\n            );\n        }\n        if (mode === \"Pack\" && feature_start >= tile_low && feature_name !== \".\") {\n            // Draw label.\n            ctx.fillStyle = this.prefs.label_color;\n            if (tile_low === 0 && f_start - ctx.measureText(feature_name).width < 0) {\n                ctx.textAlign = \"left\";\n                ctx.fillText(feature_name, f_end + LABEL_SPACING, y_start + 9, this.max_label_length);\n            } else {\n                ctx.textAlign = \"right\";\n                ctx.fillText(feature_name, f_start - LABEL_SPACING, y_start + 9, this.max_label_length);\n            }\n        }\n\n        // FIXME: provide actual coordinates for drawn read.\n        return [0, 0];\n    }\n});\n\nvar ArcLinkedFeaturePainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n    LinkedFeaturePainter.call(this, data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n    // Need to know the longest feature length for adding spacing\n    this.longest_feature_length = this.calculate_longest_feature_length();\n    this.draw_background_connector = false;\n    this.draw_individual_connectors = true;\n};\n\n_.extend(ArcLinkedFeaturePainter.prototype, FeaturePainter.prototype, LinkedFeaturePainter.prototype, {\n    calculate_longest_feature_length: function() {\n        var longest_feature_length = 0;\n        for (var i = 0, len = this.data.length; i < len; i++) {\n            var feature = this.data[i];\n            var feature_start = feature[1];\n            var feature_end = feature[2];\n            longest_feature_length = Math.max(longest_feature_length, feature_end - feature_start);\n        }\n        return longest_feature_length;\n    },\n\n    get_top_padding: function(width) {\n        var view_range = this.view_end - this.view_start;\n        var w_scale = width / view_range;\n        return Math.min(128, Math.ceil(this.longest_feature_length / 2 * w_scale));\n    },\n\n    draw_connector: function(ctx, block1_start, block1_end, block2_start, block2_end, y_start) {\n        // Arc drawing -- from closest endpoints\n        var x_center = (block1_end + block2_start) / 2;\n\n        var radius = block2_start - x_center;\n\n        // For full half circles\n        var angle1 = Math.PI;\n\n        var angle2 = 0;\n        if (radius > 0) {\n            ctx.beginPath();\n            ctx.arc(x_center, y_start, block2_start - x_center, Math.PI, 0);\n            ctx.stroke();\n        }\n    }\n});\n\n// Color stuff from less.js\n\nvar Color = function(rgb, a) {\n    /**\n     * The end goal here, is to parse the arguments\n     * into an integer triplet, such as `128, 255, 0`\n     *\n     * This facilitates operations and conversions.\n     */\n    if (Array.isArray(rgb)) {\n        this.rgb = rgb;\n    } else if (rgb.length == 6) {\n        this.rgb = rgb.match(/.{2}/g).map(c => parseInt(c, 16));\n    } else if (rgb.length == 7) {\n        this.rgb = rgb\n            .substring(1, 7)\n            .match(/.{2}/g)\n            .map(c => parseInt(c, 16));\n    } else {\n        this.rgb = rgb.split(\"\").map(c => parseInt(c + c, 16));\n    }\n    this.alpha = typeof a === \"number\" ? a : 1;\n};\nColor.prototype = {\n    eval: function() {\n        return this;\n    },\n\n    //\n    // If we have some transparency, the only way to represent it\n    // is via `rgba`. Otherwise, we use the hex representation,\n    // which has better compatibility with older browsers.\n    // Values are capped between `0` and `255`, rounded and zero-padded.\n    //\n    toCSS: function() {\n        if (this.alpha < 1.0) {\n            return `rgba(${this.rgb\n                .map(c => Math.round(c))\n                .concat(this.alpha)\n                .join(\", \")})`;\n        } else {\n            return `#${this.rgb\n                .map(i => {\n                    i = Math.round(i);\n                    i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                    return i.length === 1 ? `0${i}` : i;\n                })\n                .join(\"\")}`;\n        }\n    },\n\n    toHSL: function() {\n        var r = this.rgb[0] / 255;\n        var g = this.rgb[1] / 255;\n        var b = this.rgb[2] / 255;\n        var a = this.alpha;\n        var max = Math.max(r, g, b);\n        var min = Math.min(r, g, b);\n        var h;\n        var s;\n        var l = (max + min) / 2;\n        var d = max - min;\n\n        if (max === min) {\n            h = s = 0;\n        } else {\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n            switch (max) {\n                case r:\n                    h = (g - b) / d + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / d + 2;\n                    break;\n                case b:\n                    h = (r - g) / d + 4;\n                    break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s: s, l: l, a: a };\n    },\n\n    toARGB: function() {\n        var argb = [Math.round(this.alpha * 255)].concat(this.rgb);\n        return `#${argb\n            .map(i => {\n                i = Math.round(i);\n                i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                return i.length === 1 ? `0${i}` : i;\n            })\n            .join(\"\")}`;\n    },\n\n    mix: function(color2, weight) {\n        var color1 = this;\n\n        var p = weight; // .value / 100.0;\n        var w = p * 2 - 1;\n        var a = color1.toHSL().a - color2.toHSL().a;\n\n        var w1 = ((w * a == -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n        var w2 = 1 - w1;\n\n        var rgb = [\n            color1.rgb[0] * w1 + color2.rgb[0] * w2,\n            color1.rgb[1] * w1 + color2.rgb[1] * w2,\n            color1.rgb[2] * w1 + color2.rgb[2] * w2\n        ];\n\n        var alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n        return new Color(rgb, alpha);\n    }\n};\n\n// End colors from less.js\n\nvar LinearRamp = function(start_color, end_color, start_value, end_value) {\n    /**\n     * Simple linear gradient\n     */\n    this.start_color = new Color(start_color);\n    this.end_color = new Color(end_color);\n    this.start_value = start_value;\n    this.end_value = end_value;\n    this.value_range = end_value - start_value;\n};\n\nLinearRamp.prototype.map_value = function(value) {\n    value = Math.max(value, this.start_value);\n    value = Math.min(value, this.end_value);\n    value = (value - this.start_value) / this.value_range;\n    // HACK: just red for now\n    // return \"hsl(0,100%,\" + (value * 100) + \"%)\"\n    return this.start_color.mix(this.end_color, 1 - value).toCSS();\n};\n\nvar SplitRamp = function(start_color, middle_color, end_color, start_value, end_value) {\n    /**\n     * Two gradients split away from 0\n     */\n    this.positive_ramp = new LinearRamp(middle_color, end_color, 0, end_value);\n    this.negative_ramp = new LinearRamp(middle_color, start_color, 0, -start_value);\n    this.start_value = start_value;\n    this.end_value = end_value;\n};\n\nSplitRamp.prototype.map_value = function(value) {\n    value = Math.max(value, this.start_value);\n    value = Math.min(value, this.end_value);\n    if (value >= 0) {\n        return this.positive_ramp.map_value(value);\n    } else {\n        return this.negative_ramp.map_value(-value);\n    }\n};\n\nvar DiagonalHeatmapPainter = function(data, view_start, view_end, prefs, mode) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    var i;\n    var len;\n\n    if (this.prefs.min_value === undefined) {\n        var min_value = Infinity;\n        for (i = 0, len = this.data.length; i < len; i++) {\n            min_value = Math.min(min_value, this.data[i][6]);\n        }\n        this.prefs.min_value = min_value;\n    }\n    if (this.prefs.max_value === undefined) {\n        var max_value = -Infinity;\n        for (i = 0, len = this.data.length; i < len; i++) {\n            max_value = Math.max(max_value, this.data[i][6]);\n        }\n        this.prefs.max_value = max_value;\n    }\n};\n\nDiagonalHeatmapPainter.prototype.default_prefs = {\n    min_value: undefined,\n    max_value: undefined,\n    mode: \"Heatmap\",\n    pos_color: \"#FF8C00\",\n    neg_color: \"#4169E1\"\n};\n\nDiagonalHeatmapPainter.prototype.draw = function(ctx, width, height, w_scale) {\n    var min_value = this.prefs.min_value;\n    var max_value = this.prefs.max_value;\n    var value_range = max_value - min_value;\n    var height_px = height;\n    var view_start = this.view_start;\n    var mode = this.mode;\n    var data = this.data;\n    var invsqrt2 = 1 / Math.sqrt(2);\n\n    var ramp = new SplitRamp(this.prefs.neg_color, \"#FFFFFF\", this.prefs.pos_color, min_value, max_value);\n\n    var d;\n    var s1;\n    var e1;\n    var s2;\n    var e2;\n    var value;\n\n    var scale = p => (p - view_start) * w_scale;\n\n    ctx.save();\n\n    // Draw into triangle, then rotate and scale\n    ctx.rotate(-45 * Math.PI / 180);\n    ctx.scale(invsqrt2, invsqrt2);\n\n    // Paint track.\n    for (var i = 0, len = data.length; i < len; i++) {\n        d = data[i];\n\n        s1 = scale(d[1]);\n        e1 = scale(d[2]);\n        s2 = scale(d[4]);\n        e2 = scale(d[5]);\n        value = d[6];\n\n        ctx.fillStyle = ramp.map_value(value);\n        ctx.fillRect(s1, s2, e1 - s1, e2 - s2);\n    }\n\n    ctx.restore();\n};\n\n/**\n * Utilities for painting reads.\n */\nvar ReadPainterUtils = function(ctx, row_height, px_per_base, mode) {\n    this.ctx = ctx;\n    this.row_height = row_height;\n    this.px_per_base = px_per_base;\n    this.draw_details = (mode === \"Pack\" || mode === \"Auto\") && px_per_base >= ctx.canvas.manager.char_width_px;\n    this.delete_details_thickness = 0.2;\n};\n\n_.extend(ReadPainterUtils.prototype, {\n    /**\n     * Draw deletion of base(s).\n     * @param draw_detail if true, drawing in detail and deletion is drawn more subtly\n     */\n    draw_deletion: function(x, y, len) {\n        this.ctx.fillStyle = \"black\";\n        var thickness = (this.draw_details ? this.delete_details_thickness : 1) * this.row_height;\n        y += 0.5 * (this.row_height - thickness);\n        this.ctx.fillRect(x, y, len * this.px_per_base, thickness);\n    }\n});\n\n/**\n * Paints variant data onto canvas.\n */\nvar VariantPainter = function(data, view_start, view_end, prefs, mode, base_color_fn) {\n    Painter.call(this, data, view_start, view_end, prefs, mode);\n    this.base_color_fn = base_color_fn;\n    this.divider_height = 1;\n};\n\n_.extend(VariantPainter.prototype, Painter.prototype, {\n    /**\n     * Height of a single row, depends on mode\n     */\n    get_row_height: function() {\n        var mode = this.mode;\n        var height;\n        if (mode === \"Dense\") {\n            height = DENSE_TRACK_HEIGHT;\n        } else if (mode === \"Squish\") {\n            height = SQUISH_TRACK_HEIGHT;\n        } else {\n            // mode === \"Pack\"\n            height = PACK_TRACK_HEIGHT;\n        }\n        return height;\n    },\n\n    /**\n     * Returns required height to draw a particular number of samples in a given mode.\n     */\n    get_required_height: function(num_samples) {\n        // FIXME: for single-sample data, height should be summary_height when zoomed out and\n        // row_height when zoomed in.\n        var height = this.prefs.summary_height;\n\n        // If showing sample data, height is summary + divider + samples.\n        if (num_samples > 1 && this.prefs.show_sample_data) {\n            height += this.divider_height + num_samples * this.get_row_height();\n        }\n        return height;\n    },\n\n    /**\n     * Draw on the context using a rectangle of width x height with scale w_scale.\n     */\n    draw: function(ctx, width, height, w_scale) {\n        ctx.save();\n\n        var /**\n         * Returns dictionary of information about an indel; returns empty if there no indel. Assumes indel is left-aligned.\n         * Dict attributes:\n         *    -type: 'insertion' or 'deletion'\n         *    -start: where the deletion starts relative to reference start\n         *    -len: how long the deletion is\n         */\n        get_indel_info = (ref, alt) => {\n            var ref_len = ref.length;\n            var alt_len = alt.length;\n            var start = 0;\n            var len = 1;\n            var type = null;\n            if (alt === \"-\") {\n                type = \"deletion\";\n                len = ref.length;\n            } else if (ref.indexOf(alt) === 0 && ref_len > alt_len) {\n                type = \"deletion\";\n                len = ref_len - alt_len;\n                start = alt_len;\n            } else if (alt.indexOf(ref) === 0 && ref_len < alt_len) {\n                // Insertion.\n                type = \"insertion\";\n                len = alt_len - ref_len;\n                start = alt_len;\n            }\n\n            return type !== null ? { type: type, start: start, len: len } : {};\n        };\n\n        // Draw.\n        var locus_data;\n\n        var pos;\n        var id;\n        var ref;\n        var alt;\n        var qual;\n        var filter;\n        var sample_gts;\n        var allele_counts;\n        var variant;\n        var draw_x_start;\n        var draw_y_start;\n        var genotype;\n\n        var // Always draw variants at least 1 pixel wide.\n        base_px = Math.max(1, Math.floor(w_scale));\n\n        var // Determine number of samples.\n        num_samples = this.data.length ? this.data[0][7].split(\",\").length : 0;\n\n        var row_height = this.mode === \"Squish\" ? SQUISH_TRACK_HEIGHT : PACK_TRACK_HEIGHT;\n\n        var // If zoomed out, fill the whole row with feature to make it easier to read;\n        // when zoomed in, use feature height so that there are gaps in sample rows.\n        feature_height =\n            w_scale < 0.1 ? row_height : this.mode === \"Squish\" ? SQUISH_FEATURE_HEIGHT : PACK_FEATURE_HEIGHT;\n\n        var draw_summary = true;\n\n        var paint_utils = new ReadPainterUtils(ctx, row_height, w_scale, this.mode);\n\n        var j;\n\n        // If there's a single sample, update drawing variables.\n        if (num_samples === 1) {\n            row_height = feature_height =\n                w_scale < ctx.canvas.manager.char_width_px ? this.prefs.summary_height : row_height;\n            paint_utils.row_height = row_height;\n            // No summary when there's a single sample.\n            draw_summary = false;\n        }\n\n        // Draw divider between summary and samples.\n        if (this.prefs.show_sample_data && draw_summary) {\n            ctx.fillStyle = \"#F3F3F3\";\n            ctx.globalAlpha = 1;\n            ctx.fillRect(0, this.prefs.summary_height - this.divider_height, width, this.divider_height);\n        }\n\n        // Draw variants.\n        ctx.textAlign = \"center\";\n        for (var i = 0; i < this.data.length; i++) {\n            // Get locus data.\n            locus_data = this.data[i];\n            pos = locus_data[1];\n            ref = locus_data[3];\n            alt = [locus_data[4].split(\",\")];\n            sample_gts = locus_data[7].split(\",\");\n            allele_counts = locus_data.slice(8);\n\n            // Process alterate values to derive information about each alt.\n            alt = _.map(_.flatten(alt), a => {\n                var alt_info = {\n                    type: \"snp\",\n                    value: a,\n                    start: 0\n                };\n\n                var indel_info = get_indel_info(ref, a);\n\n                return _.extend(alt_info, indel_info);\n            });\n\n            // Only draw locus data if it's in viewing region.\n            if (pos < this.view_start || pos > this.view_end) {\n                continue;\n            }\n\n            // Draw summary for alleles.\n            if (draw_summary) {\n                ctx.fillStyle = \"#999999\";\n                ctx.globalAlpha = 1;\n                for (j = 0; j < alt.length; j++) {\n                    // Draw background for summary.\n                    draw_x_start = this.get_start_draw_pos(pos + alt[j].start, w_scale);\n                    ctx.fillRect(draw_x_start, 0, base_px, this.prefs.summary_height);\n                    draw_y_start = this.prefs.summary_height;\n                    // Draw allele fractions onto summary.\n                    for (j = 0; j < alt.length; j++) {\n                        ctx.fillStyle = alt[j].type === \"deletion\" ? \"black\" : this.base_color_fn(alt[j].value);\n                        var allele_frac = allele_counts / sample_gts.length;\n                        var draw_height = Math.ceil(this.prefs.summary_height * allele_frac);\n                        ctx.fillRect(draw_x_start, draw_y_start - draw_height, base_px, draw_height);\n                        draw_y_start -= draw_height;\n                    }\n                }\n            }\n\n            // Done drawing if not showing samples data.\n            if (!this.prefs.show_sample_data) {\n                continue;\n            }\n\n            // Draw sample genotype(s).\n            draw_y_start = draw_summary ? this.prefs.summary_height + this.divider_height : 0;\n            for (j = 0; j < sample_gts.length; j++, draw_y_start += row_height) {\n                genotype = sample_gts[j] ? sample_gts[j].split(/\\/|\\|/) : [\"0\", \"0\"];\n\n                // Get variant to draw and set drawing properties.\n                variant = null;\n                if (genotype[0] === genotype[1]) {\n                    if (genotype[0] === \".\") {\n                        // TODO: draw uncalled variant.\n                    } else if (genotype[0] !== \"0\") {\n                        // Homozygous for variant.\n                        variant = alt[parseInt(genotype[0], 10) - 1];\n                        ctx.globalAlpha = 1;\n                    }\n                    // else reference\n                } else {\n                    // Heterozygous for variant.\n                    variant = genotype[0] !== \"0\" ? genotype[0] : genotype[1];\n                    variant = alt[parseInt(variant, 10) - 1];\n                    ctx.globalAlpha = 0.5;\n                }\n\n                // If there's a variant, draw it.\n                if (variant) {\n                    draw_x_start = this.get_start_draw_pos(pos + variant.start, w_scale);\n                    if (variant.type === \"snp\") {\n                        var snp = variant.value;\n                        ctx.fillStyle = this.base_color_fn(snp);\n                        if (paint_utils.draw_details) {\n                            ctx.fillText(snp, this.get_draw_pos(pos, w_scale), draw_y_start + row_height);\n                        } else {\n                            ctx.fillRect(draw_x_start, draw_y_start + 1, base_px, feature_height);\n                        }\n                    } else if (variant.type === \"deletion\") {\n                        paint_utils.draw_deletion(draw_x_start, draw_y_start + 1, variant.len);\n                    } else {\n                        // TODO: handle insertions.\n                    }\n                }\n            }\n        }\n\n        ctx.restore();\n    }\n});\n\nexport default {\n    Scaler: Scaler,\n    LinePainter: LinePainter,\n    LinkedFeaturePainter: LinkedFeaturePainter,\n    ReadPainter: ReadPainter,\n    ArcLinkedFeaturePainter: ArcLinkedFeaturePainter,\n    DiagonalHeatmapPainter: DiagonalHeatmapPainter,\n    VariantPainter: VariantPainter\n};\n"]}