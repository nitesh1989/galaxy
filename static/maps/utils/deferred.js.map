{"version":3,"sources":["utils/deferred.js"],"names":["Backbone","Model","extend","initialize","this","active","last","execute","callback","self","id","_utils2","default","length","process","$","Deferred","promise","always","has_deferred","emit","debug","state","charAt","slice","when","Galaxy","resolve","reset","i","ready","isEmptyObject"],"mappings":"mMAIeA,SAASC,MAAMC,QAC1BC,WAAY,WACRC,KAAKC,UACLD,KAAKE,KAAO,MAMhBC,QAAS,SAASC,GACd,IAAIC,EAAOL,KACPM,EAAKC,EAAAC,QAXFZ,MACXG,EAAYK,EAAAK,OAAW,EAGtBT,KAJgCC,OAAAK,IAAA,EAkB7B,IAAII,EAAUC,EAAEC,WAChBF,EAAQG,UAAUC,OAAO,kBAVpBT,EAAAJ,OAAAK,GACLS,GACIT,OAAKU,KAAAC,MACLF,sBAYWf,KAAKkB,QAVpBC,OAAA,GACYb,cAAZN,KAAAkB,QAAAE,MAAA,GAJId,IAIJA,KAKIK,EAAAU,KAAArB,KAAAE,MAAOG,OAAKJ,WACZc,EAAAA,OAAAA,IAFJA,GAAAO,OAAAN,KAAAC,MAAA,sBAAA,WAAAX,GAeQF,EAASM,IAJjBK,GAAAL,EAAAa,WAEIb,EAAIL,WAGAL,KAAAE,KAAAQ,EAACK,WAKTS,MAAA,WACHF,OAzCgCN,KAAAC,MAAA,sBAAA,SA+C7B,IAAK,IAAIQ,KAAKzB,KAAKC,OAJvBD,KAAAC,OAAAwB,IAAA,GAMKC,MAAA,WACJ,OAlDgCf,EAAAgB,cAAA3B,KAAAC","file":"../../scripts/utils/deferred.js","sourcesContent":["/**\n *  This class defines a queue to ensure that multiple deferred callbacks are executed sequentially.\n */\nimport Utils from \"utils/utils\";\nexport default Backbone.Model.extend({\n    initialize: function() {\n        this.active = {};\n        this.last = null;\n    },\n\n    /** Adds a callback to the queue. Upon execution a deferred object is parsed to the callback i.e. callback( deferred ).\n     *  If the callback does not take any arguments, the deferred is resolved instantly.\n    */\n    execute: function(callback) {\n        var self = this;\n        var id = Utils.uid();\n        var has_deferred = callback.length > 0;\n\n        // register process\n        this.active[id] = true;\n\n        // deferred process\n        var process = $.Deferred();\n        process.promise().always(function() {\n            delete self.active[id];\n            has_deferred &&\n                Galaxy.emit.debug(\n                    \"deferred::execute()\",\n                    `${this.state()\n                        .charAt(0)\n                        .toUpperCase() + this.state().slice(1)} ${id}`\n                );\n        });\n\n        // deferred queue\n        $.when(this.last).always(() => {\n            if (self.active[id]) {\n                has_deferred && Galaxy.emit.debug(\"deferred::execute()\", `Running ${id}`);\n                callback(process);\n                !has_deferred && process.resolve();\n            } else {\n                process.reject();\n            }\n        });\n        this.last = process.promise();\n    },\n\n    /** Resets the promise queue. All currently queued but unexecuted callbacks/promises will be rejected.\n    */\n    reset: function() {\n        Galaxy.emit.debug(\"deferred::execute()\", \"Reset\");\n        for (var i in this.active) {\n            this.active[i] = false;\n        }\n    },\n\n    /** Returns true if all processes are done.\n    */\n    ready: function() {\n        return $.isEmptyObject(this.active);\n    }\n});\n"]}