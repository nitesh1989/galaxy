{"version":3,"sources":["utils/graph.js"],"names":["matches","d","d2","k","hasOwnProperty","extend","iterate","fn","propsOrFn","undefined","props","_typeof","returned","index","key","obj","value","push","call","Edge","source","target","data","self","this","name","json","degree","Graph","directed","options","vertexLate","init","read","prototype","toString","Vertex","eachEdge","edges","toJSON","graph","processFns","vertexEarly","vertex","search","edge","from","_cache","GraphSearch","start","vertices","_search","discovered","searchTree","_searchTree","keys","map","BreadthFirstSearch","queue","shift","adj","DepthFirstSearch","constructor","discoverAdjacentVertices","adjacent","sourceVertex","exitTimes","recurse","time","window","allowReflexiveEdges","numEdges","readNodesAndLinks","nodes","createVertex","readVerticesAndEdges","links","forEach","i","sourceName","targetName","createEdge","node","isReflexive","targetVertex","concat","apply","eachVertex","Array","print","Object","length","console","log","strings","to","join","indeces","toVerticesAndEdges","breadthFirstSearchTree","depthFirstSearchTree","weakComponents","searchGraph","components","undiscovered","toNodesAndLinks","undiscoveredVertex","filter","vertexName","hasBeenReversed","swap","getComponent","weakComponentGraph","reduce","reduction","curr","component","randGraph","numVerts","randRange","range","Math","random"],"mappings":"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","file":"../../scripts/utils/graph.js","sourcesContent":["/* ============================================================================\nTODO:\n\n============================================================================ */\n//TODO: go ahead and move to underscore...\n/** call fn on each key/value in d */\nfunction each(d, fn) {\n    for (var k in d) {\n        if (d.hasOwnProperty(k)) {\n            fn(d[k], k, d);\n        }\n    }\n}\n\n/** copy key/values from d2 to d overwriting if present */\nfunction extend(d, d2) {\n    for (var k in d2) {\n        if (d2.hasOwnProperty(k)) {\n            d[k] = d2[k];\n        }\n    }\n    return d;\n}\n\n/** deep equal of two dictionaries */\nfunction matches(d, d2) {\n    for (var k in d2) {\n        if (d2.hasOwnProperty(k)) {\n            if (!d.hasOwnProperty(k) || d[k] !== d2[k]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n/** map key/values in obj\n *      if propsOrFn is an object, return only those k/v that match the object\n *      if propsOrFn is function, call the fn and returned the mapped values from it\n */\nfunction iterate(obj, propsOrFn) {\n    var fn = typeof propsOrFn === \"function\" ? propsOrFn : undefined;\n    var props = typeof propsOrFn === \"object\" ? propsOrFn : undefined;\n    var returned = [];\n    var index = 0;\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            var value = obj[key];\n            if (fn) {\n                returned.push(fn.call(value, value, key, index));\n            } else if (props) {\n                //TODO: break out to sep?\n                if (typeof value === \"object\" && matches(value, props)) {\n                    returned.push(value);\n                }\n            } else {\n                returned.push(value);\n            }\n            index += 1;\n        }\n    }\n    return returned;\n}\n\n// ============================================================================\n/** A graph edge containing the name/id of both source and target and optional data\n */\nfunction Edge(source, target, data) {\n    var self = this;\n    self.source = source !== undefined ? source : null;\n    self.target = target !== undefined ? target : null;\n    self.data = data || null;\n    //if( typeof data === 'object' ){\n    //    extend( self, data );\n    //}\n    return self;\n}\n/** String representation */\nEdge.prototype.toString = function() {\n    return `${this.source}->${this.target}`;\n};\n\n/** Return a plain object representing this edge */\nEdge.prototype.toJSON = function() {\n    //TODO: this is safe in most browsers (fns will be stripped) - alter tests to incorporate this in order to pass data\n    //return this;\n    var json = {\n        source: this.source,\n        target: this.target\n    };\n    if (this.data) {\n        json.data = this.data;\n    }\n    return json;\n};\n\n// ============================================================================\n/** A graph vertex with a (unique) name/id and optional data.\n *      A vertex contains a list of Edges (whose sources are this vertex) and maintains the degree.\n */\nfunction Vertex(name, data) {\n    var self = this;\n    self.name = name !== undefined ? name : \"(unnamed)\";\n    self.data = data || null;\n    self.edges = {};\n    self.degree = 0;\n    return self;\n}\n\n/** String representation */\nVertex.prototype.toString = function() {\n    return `Vertex(${this.name})`;\n};\n\n//TODO: better name w no collision for either this.eachEdge or this.edges\n/** Iterate over each edge from this vertex */\nVertex.prototype.eachEdge = function(propsOrFn) {\n    return iterate(this.edges, propsOrFn);\n};\n\n/** Return a plain object representing this vertex */\nVertex.prototype.toJSON = function() {\n    //return this;\n    return {\n        name: this.name,\n        data: this.data\n    };\n};\n\n// ============================================================================\n/** Base (abstract) class for Graph search algorithms.\n *      Pass in the graph to search\n *      and an optional dictionary containing the 3 vertex/edge processing fns listed below.\n */\nvar GraphSearch = function(graph, processFns) {\n    var self = this;\n    self.graph = graph;\n\n    self.processFns = processFns || {\n        vertexEarly: function(vertex, search) {\n            //console.debug( 'processing vertex:', vertex.name, vertex );\n        },\n        edge: function(from, edge, search) {\n            //console.debug( this, 'edge:', from, edge, search );\n        },\n        vertexLate: function(vertex, search) {\n            //console.debug( this, 'vertexLate:', vertex, search );\n        }\n    };\n\n    self._cache = {};\n    return self;\n};\n\n/** Search interface where start is the vertex (or the name/id of the vertex) to begin the search at\n *      This public interface caches searches and returns the cached version if it's already been done.\n */\nGraphSearch.prototype.search = function _search(start) {\n    var self = this;\n    if (start in self._cache) {\n        return self._cache[start];\n    }\n    if (!(start instanceof Vertex)) {\n        start = self.graph.vertices[start];\n    }\n    return (self._cache[start.name] = self._search(start));\n};\n\n/** Actual search (private) function (abstract here) */\nGraphSearch.prototype._search = function __search(start, search) {\n    search = search || {\n        discovered: {},\n        //parents : {},\n        edges: []\n    };\n    return search;\n};\n\n/** Searches graph from start and returns a search tree of the results */\nGraphSearch.prototype.searchTree = function _searchTree(start) {\n    return this._searchTree(this.search(start));\n};\n\n/** Helper fn that returns a graph (a search tree) based on the search object passed in (does not actually search) */\nGraphSearch.prototype._searchTree = function __searchTree(search) {\n    var self = this;\n    return new Graph(true, {\n        edges: search.edges,\n        vertices: Object.keys(search.discovered).map(key => self.graph.vertices[key].toJSON())\n    });\n};\n\n// ============================================================================\n/** Breadth first search algo.\n */\nvar BreadthFirstSearch = function(graph, processFns) {\n    var self = this;\n    GraphSearch.call(this, graph, processFns);\n    return self;\n};\nBreadthFirstSearch.prototype = new GraphSearch();\nBreadthFirstSearch.prototype.constructor = BreadthFirstSearch;\n\n/** (Private) implementation of BFS */\nBreadthFirstSearch.prototype._search = function __search(start, search) {\n    search = search || {\n        discovered: {},\n        //parents : {},\n        edges: []\n    };\n\n    var self = this;\n    var queue = [];\n\n    function discoverAdjacent(adj, edge) {\n        var source = this;\n        if (self.processFns.edge) {\n            self.processFns.edge.call(self, source, edge, search);\n        }\n        if (!search.discovered[adj.name]) {\n            //console.debug( '\\t\\t\\t', adj.name, 'is undiscovered:', search.discovered[ adj.name ] );\n            search.discovered[adj.name] = true;\n            //search.parents[ adj.name ] = source;\n            search.edges.push({ source: source.name, target: adj.name });\n            //console.debug( '\\t\\t\\t queuing undiscovered: ', adj );\n            queue.push(adj);\n        }\n    }\n\n    //console.debug( 'BFS starting. start:', start );\n    search.discovered[start.name] = true;\n    queue.push(start);\n    while (queue.length) {\n        var vertex = queue.shift();\n        //console.debug( '\\t Queue is shifting. Current:', vertex, 'queue:', queue );\n        if (self.processFns.vertexEarly) {\n            self.processFns.vertexEarly.call(self, vertex, search);\n        }\n        self.graph.eachAdjacent(vertex, discoverAdjacent);\n        if (self.processFns.vertexLate) {\n            self.processFns.vertexLate.call(self, vertex, search);\n        }\n    }\n    //console.debug( 'search.edges:', JSON.stringify( search.edges ) );\n    return search;\n};\n\n// ============================================================================\n/** Depth first search algorithm.\n */\nvar DepthFirstSearch = function(graph, processFns) {\n    var self = this;\n    GraphSearch.call(this, graph, processFns);\n    return self;\n};\nDepthFirstSearch.prototype = new GraphSearch();\nDepthFirstSearch.prototype.constructor = DepthFirstSearch;\n\n/** (Private) implementation of DFS */\nDepthFirstSearch.prototype._search = function(start, search) {\n    //console.debug( 'depthFirstSearch:', start );\n    search = search || {\n        discovered: {},\n        //parents    : {},\n        edges: [],\n        entryTimes: {},\n        exitTimes: {}\n    };\n    var self = this;\n    var time = 0;\n\n    // discover verts adjacent to the source (this):\n    //  processing each edge, saving the edge to the tree, and caching the reverse path with parents\n    function discoverAdjacentVertices(adjacent, edge) {\n        //console.debug( '\\t\\t adjacent:', adjacent, 'edge:', edge );\n        var sourceVertex = this;\n        if (self.processFns.edge) {\n            self.processFns.edge.call(self, sourceVertex, edge, search);\n        }\n        if (!search.discovered[adjacent.name]) {\n            //search.parents[ adjacent.name ] = sourceVertex;\n            search.edges.push({\n                source: sourceVertex.name,\n                target: adjacent.name\n            });\n            recurse(adjacent);\n        }\n    }\n\n    // use function stack for DFS stack process verts, times, and discover adjacent verts (recursing into them)\n    function recurse(vertex) {\n        //console.debug( '\\t recursing into: ', vertex );\n        search.discovered[vertex.name] = true;\n        if (self.processFns.vertexEarly) {\n            self.processFns.vertexEarly.call(self, vertex, search);\n        }\n        search.entryTimes[vertex.name] = time++;\n\n        self.graph.eachAdjacent(vertex, discoverAdjacentVertices);\n\n        if (self.processFns.vertexLate) {\n            self.processFns.vertexLate.call(self, vertex, search);\n        }\n        search.exitTimes[vertex.name] = time++;\n    }\n    // begin recursion with the desired start\n    recurse(start);\n\n    return search;\n};\n\n// ============================================================================\n/** A directed/non-directed graph object.\n */\nfunction Graph(directed, data, options) {\n    //TODO: move directed to options\n    this.directed = directed || false;\n    return this.init(options).read(data);\n}\nwindow.Graph = Graph;\n\n/** Set up options and instance variables */\nGraph.prototype.init = function(options) {\n    options = options || {};\n    var self = this;\n\n    self.allowReflexiveEdges = options.allowReflexiveEdges || false;\n\n    self.vertices = {};\n    self.numEdges = 0;\n    return self;\n};\n\n/** Read data from the plain object data - both in d3 form (nodes and links) or vertices and edges */\nGraph.prototype.read = function(data) {\n    if (!data) {\n        return this;\n    }\n    var self = this;\n    if (data.hasOwnProperty(\"nodes\")) {\n        return self.readNodesAndLinks(data);\n    }\n    if (data.hasOwnProperty(\"vertices\")) {\n        return self.readVerticesAndEdges(data);\n    }\n    return self;\n};\n\n//TODO: the next two could be combined\n/** Create the graph using a list of nodes and a list of edges (where source and target are indeces into nodes) */\nGraph.prototype.readNodesAndLinks = function(data) {\n    if (!(data && data.hasOwnProperty(\"nodes\"))) {\n        return this;\n    }\n    //console.debug( 'readNodesAndLinks:', data );\n    //console.debug( 'data:\\n' + JSON.stringify( data, null, '  ' ) );\n    var self = this;\n    data.nodes.forEach(node => {\n        self.createVertex(node.name, node.data);\n    });\n    //console.debug( JSON.stringify( self.vertices, null, '  ' ) );\n\n    (data.links || []).forEach((edge, i) => {\n        var sourceName = data.nodes[edge.source].name;\n        var targetName = data.nodes[edge.target].name;\n        self.createEdge(sourceName, targetName, self.directed);\n    });\n    //self.print();\n    //console.debug( JSON.stringify( self.toNodesAndLinks(), null, '  ' ) );\n    return self;\n};\n\n/** Create the graph using a list of nodes and a list of edges (where source and target are names of nodes) */\nGraph.prototype.readVerticesAndEdges = function(data) {\n    if (!(data && data.hasOwnProperty(\"vertices\"))) {\n        return this;\n    }\n    //console.debug( 'readVerticesAndEdges:', data );\n    //console.debug( 'data:\\n' + JSON.stringify( data, null, '  ' ) );\n    var self = this;\n    data.vertices.forEach(node => {\n        self.createVertex(node.name, node.data);\n    });\n    //console.debug( JSON.stringify( self.vertices, null, '  ' ) );\n\n    (data.edges || []).forEach((edge, i) => {\n        self.createEdge(edge.source, edge.target, self.directed);\n    });\n    //self.print();\n    //console.debug( JSON.stringify( self.toNodesAndLinks(), null, '  ' ) );\n    return self;\n};\n\n/** Return the vertex with name, creating it if necessary */\nGraph.prototype.createVertex = function(name, data) {\n    //console.debug( 'createVertex:', name, data );\n    if (this.vertices[name]) {\n        return this.vertices[name];\n    }\n    return (this.vertices[name] = new Vertex(name, data));\n};\n\n/** Create an edge in vertex named sourceName to targetName (optionally adding data to it)\n *      If directed is false, create a second edge from targetName to sourceName.\n */\nGraph.prototype.createEdge = function(sourceName, targetName, directed, data) {\n    //note: allows multiple 'equivalent' edges (to/from same source/target)\n    //console.debug( 'createEdge:', source, target, directed );\n    var isReflexive = sourceName === targetName;\n    if (!this.allowReflexiveEdges && isReflexive) {\n        return null;\n    }\n\n    var sourceVertex = this.vertices[sourceName];\n    var targetVertex = this.vertices[targetName];\n    //note: silently ignores edges from/to unknown vertices\n    if (!(sourceVertex && targetVertex)) {\n        return null;\n    }\n\n    //TODO: prob. move to vertex\n    var self = this;\n\n    var edge = new Edge(sourceName, targetName, data);\n    sourceVertex.edges[targetName] = edge;\n    sourceVertex.degree += 1;\n    self.numEdges += 1;\n\n    //TODO:! don't like having duplicate edges for non-directed graphs\n    // mirror edges (reversing source and target) in non-directed graphs\n    //  but only if not reflexive\n    if (!isReflexive && !directed) {\n        // flip directed to prevent recursion loop\n        self.createEdge(targetName, sourceName, true);\n    }\n\n    return edge;\n};\n\n/** Walk over all the edges of the graph using the vertex.eachEdge iterator */\nGraph.prototype.edges = function(propsOrFn) {\n    return Array.prototype.concat.apply([], this.eachVertex(vertex => vertex.eachEdge(propsOrFn)));\n};\n\n/** Iterate over all the vertices in the graph */\nGraph.prototype.eachVertex = function(propsOrFn) {\n    return iterate(this.vertices, propsOrFn);\n};\n\n/** Return a list of the vertices adjacent to vertex */\nGraph.prototype.adjacent = function(vertex) {\n    var self = this;\n    return iterate(vertex.edges, edge => self.vertices[edge.target]);\n};\n\n/** Call fn on each vertex adjacent to vertex */\nGraph.prototype.eachAdjacent = function(vertex, fn) {\n    var self = this;\n    return iterate(vertex.edges, edge => {\n        var adj = self.vertices[edge.target];\n        return fn.call(vertex, adj, edge);\n    });\n};\n\n/** Print the graph to the console (debugging) */\nGraph.prototype.print = function() {\n    var self = this;\n    console.log(`Graph has ${Object.keys(self.vertices).length} vertices`);\n    self.eachVertex(vertex => {\n        console.log(vertex.toString());\n        vertex.eachEdge(edge => {\n            console.log(`\\t ${edge}`);\n        });\n    });\n    return self;\n};\n\n/** Return a DOT format string of this graph */\nGraph.prototype.toDOT = function() {\n    var self = this;\n    var strings = [];\n    strings.push(\"graph bler {\");\n    self.edges(edge => {\n        strings.push(`\\t${edge.from} -- ${edge.to};`);\n    });\n    strings.push(\"}\");\n    return strings.join(\"\\n\");\n};\n\n/** Return vertices and edges of this graph in d3 node/link format */\nGraph.prototype.toNodesAndLinks = function() {\n    var self = this;\n    var indeces = {};\n    return {\n        nodes: self.eachVertex((vertex, key, i) => {\n            indeces[vertex.name] = i;\n            return vertex.toJSON();\n        }),\n        links: self.edges(edge => {\n            var json = edge.toJSON();\n            json.source = indeces[edge.source];\n            json.target = indeces[edge.target];\n            return json;\n        })\n    };\n};\n\n/** Return vertices and edges of this graph where edges use the name/id as source and target */\nGraph.prototype.toVerticesAndEdges = function() {\n    var self = this;\n    return {\n        vertices: self.eachVertex((vertex, key) => vertex.toJSON()),\n        edges: self.edges(edge => edge.toJSON())\n    };\n};\n\n/** Search this graph using BFS */\nGraph.prototype.breadthFirstSearch = function(start, processFns) {\n    return new BreadthFirstSearch(this).search(start);\n};\n\n/** Return a searchtree of this graph using BFS */\nGraph.prototype.breadthFirstSearchTree = function(start, processFns) {\n    return new BreadthFirstSearch(this).searchTree(start);\n};\n\n/** Search this graph using DFS */\nGraph.prototype.depthFirstSearch = function(start, processFns) {\n    return new DepthFirstSearch(this).search(start);\n};\n\n/** Return a searchtree of this graph using DFS */\nGraph.prototype.depthFirstSearchTree = function(start, processFns) {\n    return new DepthFirstSearch(this).searchTree(start);\n};\n\n//Graph.prototype.shortestPath = function( start, end ){\n//};\n//\n//Graph.prototype.articulationVertices = function(){\n//};\n//\n//Graph.prototype.isAcyclic = function(){\n//};\n//\n//Graph.prototype.isBipartite = function(){\n//};\n\n/** Return an array of weakly connected (no edges between) sub-graphs in this graph */\nGraph.prototype.weakComponents = function() {\n    //TODO: alternately, instead of returning graph-like objects:\n    //  - could simply decorate the vertices (vertex.component = componentIndex), or clone the graph and do that\n    var self = this;\n\n    var searchGraph = this;\n    var undiscovered;\n    var components = [];\n\n    function getComponent(undiscoveredVertex) {\n        //TODO: better interface on dfs (search v. searchTree)\n        var search = new DepthFirstSearch(searchGraph)._search(undiscoveredVertex);\n\n        // remove curr discovered from undiscovered\n        undiscovered = undiscovered.filter(name => !(name in search.discovered));\n\n        return {\n            vertices: Object.keys(search.discovered).map(vertexName => self.vertices[vertexName].toJSON()),\n            edges: search.edges.map(edge => {\n                // restore any reversed edges\n                var hasBeenReversed = self.vertices[edge.target].edges[edge.source] !== undefined;\n                if (self.directed && hasBeenReversed) {\n                    var swap = edge.source;\n                    edge.source = edge.target;\n                    edge.target = swap;\n                }\n                return edge;\n            })\n        };\n    }\n\n    if (self.directed) {\n        // if directed - convert to undirected for search\n        searchGraph = new Graph(false, self.toNodesAndLinks());\n    }\n    undiscovered = Object.keys(searchGraph.vertices);\n    //console.debug( '(initial) undiscovered:', undiscovered );\n    while (undiscovered.length) {\n        var undiscoveredVertex = searchGraph.vertices[undiscovered.shift()];\n        components.push(getComponent(undiscoveredVertex));\n        //console.debug( 'undiscovered now:', undiscovered );\n    }\n\n    //console.debug( 'components:\\n', JSON.stringify( components, null, '  ' ) );\n    return components;\n};\n\n/** Return a single graph containing the weakly connected components in this graph */\nGraph.prototype.weakComponentGraph = function() {\n    //note: although this can often look like the original graph - edges can be lost\n    var components = this.weakComponents();\n    return new Graph(this.directed, {\n        vertices: components.reduce((reduction, curr) => reduction.concat(curr.vertices), []),\n        edges: components.reduce((reduction, curr) => reduction.concat(curr.edges), [])\n    });\n};\n\n/** Return an array of graphs of the weakly connected components in this graph */\nGraph.prototype.weakComponentGraphArray = function() {\n    //note: although this can often look like the original graph - edges can be lost\n    var graph = this;\n    return this.weakComponents().map(component => new Graph(graph.directed, component));\n};\n\n// ============================================================================\n/** Create a random graph with numVerts vertices and numEdges edges (for testing)\n */\nfunction randGraph(directed, numVerts, numEdges) {\n    //console.debug( 'randGraph', directed, numVerts, numEdges );\n    var data = { nodes: [], links: [] };\n    function randRange(range) {\n        return Math.floor(Math.random() * range);\n    }\n    for (var i = 0; i < numVerts; i++) {\n        data.nodes.push({ name: i });\n    }\n    for (i = 0; i < numEdges; i++) {\n        data.links.push({\n            source: randRange(numVerts),\n            target: randRange(numVerts)\n        });\n    }\n    //console.debug( JSON.stringify( data, null, '  ' ) );\n    return new Graph(directed, data);\n}\n\n// ============================================================================\nexport default {\n    Vertex: Vertex,\n    Edge: Edge,\n    BreadthFirstSearch: BreadthFirstSearch,\n    DepthFirstSearch: DepthFirstSearch,\n    Graph: Graph,\n    randGraph: randGraph\n};\n"]}