{"version":3,"sources":["utils/metrics-logger.js"],"names":["MetricsLogger","options","self","this","userId","window","bootstrapped","user","id","consoleLogger","_init","LoggingCache","ALL","INFO","WARN","METRIC","NONE","defaultNamespace","clientPrefix","logLevel","consoleLevel","cacheKeyPrefix","postUrl","delayPostInMs","getPingData","undefined","onServerResponse","prototype","defaultOptions","hasOwnProperty","k","_parseLevel","_postSize","_initCache","cache","maxCacheSize","key","err","type","level","_typeof","maxSize","upper","toUpperCase","_emitToConsole","Error","emit","namespace","logArguments","_addToCache","arguments","addTime","add","_buildEntry","entry","args","Date","_postCache","_sending","postSize","jQuery","when","entries","get","entriesLength","length","postData","metrics","JSON","stringify","always","message","xhr","readyState","status","responseJSON","responseText","response","remove","_waiting","setTimeout","whitelist","indexOf","Array","call","unshift","warn","info","apply","error","DEBUG","debug","log","slice","ERROR","metric","_hasStorage","_initStorage","localStorage","test","setItem","removeItem","e","getItem","empty","_cache","splice","overage","push","_unparseAndStore","_fetchAndParse","count","removed","print"],"mappings":"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","file":"../../scripts/utils/metrics-logger.js","sourcesContent":["/*global window, jQuery, console */\n/*=============================================================================\nTODO:\n    while anon: logs saved to 'logs-null' - this will never post\n        unless we manually do so at/after login\n        OR prepend when userId and localStorage has 'logs-null'\n    wire up _delayPost and test\n\n=============================================================================*/\n/** @class MetricsLogger\n *\n *  Object to cache, output, and post log/metric messages to the server.\n *  Meant to be attached to the Galaxy object.\n *\n *  Log from objects by either attaching logger directly:\n *      panel.logger.metric( 'user dataset deletion', panel.user.id, hda.toJSON() )\n *  or using the LoggableMixin or addLogging function:\n *      MyBackboneModel.extend( LoggableMixin ).extend({ ... })\n *      addLogging( MyBackboneModel, 'my-backbone-model' )\n *\n *  Log from templates by calling directly from Galaxy object:\n *      Galaxy.logger.metric( 'template loaded', { ownedByUser : true });\n *\n *  If you attempt to log an un-serializable object (circular reference, window, etc.),\n *  that entry will not be cached (or sent). If you set consoleLevel and consoleLogger\n *  appropriately, a warning will be shown when this happens:\n *      > panel.metric( 'something weird with window', { window : window })\n *      !'Metrics logger could not stringify logArguments: ...'\n */\nfunction MetricsLogger(options) {\n    options = options || {};\n    var self = this;\n\n    ///** get the current user's id from bootstrapped data or options */\n    self.userId = window.bootstrapped && window.bootstrapped.user ? window.bootstrapped.user.id : null;\n    self.userId = self.userId || options.userId || null;\n\n    /** the (optional) console to emit logs to */\n    self.consoleLogger = options.consoleLogger || null;\n\n    self._init(options);\n    return self;\n}\n\n//----------------------------------------------------------------------------- defaults and constants\n// see: python std lib, logging\nMetricsLogger.ALL = 0;\nMetricsLogger.LOG = 0;\nMetricsLogger.DEBUG = 10;\nMetricsLogger.INFO = 20;\nMetricsLogger.WARN = 30;\nMetricsLogger.ERROR = 40;\n// metrics levels here?\n//MetricsLogger.MinorEvent  = 45;\n//MetricsLogger.MajorEvent  = 50;\nMetricsLogger.METRIC = 50;\nMetricsLogger.NONE = 100;\n\n/** default options - override these through the constructor */\nMetricsLogger.defaultOptions = {\n    /** if an incoming message has a level >= this, it will be cached - can also be a string (e.g. 'debug') */\n    logLevel: MetricsLogger.NONE,\n    /** if an incoming message has a level >= this, it will be output to the console */\n    consoleLevel: MetricsLogger.NONE,\n    /** the default 'namespace' or label associated with an incoming message (if none is passed) */\n    defaultNamespace: \"Galaxy\",\n    /** the namespaces output to the console (all namespaces will be output if this is falsy)\n     *  note: applies only to the console (not the event/metrics log/cache)\n     */\n    consoleNamespaceWhitelist: null,\n    /** the prefix attached to client-side logs to distinguish them in the metrics db */\n    clientPrefix: \"client.\",\n\n    /** the maximum number of messages the cache should hold; if exceeded older messages are removed first */\n    maxCacheSize: 3000,\n    /** the number of messages accumulate before posting to the server; should be <= maxCacheSize */\n    postSize: 1000,\n    /** T/F whether to add a timestamp to incoming cached messages */\n    addTime: true,\n    /** string to prefix to userid for cache web storage */\n    cacheKeyPrefix: \"logs-\",\n\n    /** the relative url to post messages to */\n    postUrl: \"/api/metrics\",\n    /** delay before trying post again after two failures */\n    delayPostInMs: 1000 * 60 * 10,\n\n    /** an (optional) function that should return an object; used to send additional data with the metrics */\n    getPingData: undefined,\n    /** an (optional) function that will handle the servers response after successfully posting messages */\n    onServerResponse: undefined\n};\n\n//----------------------------------------------------------------------------- set up\n/** initialize the logger with options, set up instance vars and cache, and add onpageunload to window */\nMetricsLogger.prototype._init = function _init(options) {\n    var self = this;\n    self.options = {};\n    for (var k in MetricsLogger.defaultOptions) {\n        if (MetricsLogger.defaultOptions.hasOwnProperty(k)) {\n            self.options[k] = options.hasOwnProperty(k) ? options[k] : MetricsLogger.defaultOptions[k];\n        }\n    }\n    self.options.logLevel = self._parseLevel(self.options.logLevel);\n    self.options.consoleLevel = self._parseLevel(self.options.consoleLevel);\n    //self._emitToConsole( 'debug', 'MetricsLogger', 'MetricsLogger.options:', self.options );\n\n    /** is the logger currently sending? */\n    self._sending = false;\n    /** the setTimeout id if the logger POST has failed more than once */\n    self._waiting = null;\n    /** the current number of entries to send in a POST */\n    self._postSize = self.options.postSize;\n\n    self._initCache();\n\n    return self;\n};\n\n/** initialize the cache */\nMetricsLogger.prototype._initCache = function _initCache() {\n    try {\n        this.cache = new LoggingCache({\n            maxSize: this.options.maxCacheSize,\n            key: this.options.cacheKeyPrefix + this.userId\n        });\n    } catch (err) {\n        this._emitToConsole(\"warn\", \"MetricsLogger\", [\"Could not intitialize logging cache:\", err]);\n        this.options.logLevel = MetricsLogger.NONE;\n    }\n};\n\n/** return the numeric log level if level in 'none, debug, log, info, warn, error' */\nMetricsLogger.prototype._parseLevel = function _parseLevel(level) {\n    var type = typeof level;\n    if (type === \"number\") {\n        return level;\n    }\n    if (type === \"string\") {\n        var upper = level.toUpperCase();\n        if (MetricsLogger.hasOwnProperty(upper)) {\n            return MetricsLogger[upper];\n        }\n    }\n    throw new Error(`Unknown log level: ${level}`);\n};\n\n//----------------------------------------------------------------------------- main entry point\n/** record a log/message's arguments to the cache and/or the console based on level and namespace */\nMetricsLogger.prototype.emit = function emit(level, namespace, logArguments) {\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ 'emit:', level, namespace, logArguments ]);\n    var self = this;\n    namespace = namespace || self.options.defaultNamespace;\n    if (!level || !logArguments) {\n        return self;\n    }\n    // add to cache if proper level\n    //TODO: respect do not track?\n    //if( !navigator.doNotTrack && level >= self.options.logLevel ){\n    level = self._parseLevel(level);\n    if (level >= self.options.logLevel) {\n        self._addToCache(level, namespace, logArguments);\n    }\n    // also emit to consoleLogger if proper level for that\n    if (self.consoleLogger && level >= self.options.consoleLevel) {\n        self._emitToConsole(level, namespace, logArguments);\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- cache\n/** add a message to the cache and if messages.length is high enough post them to the server */\nMetricsLogger.prototype._addToCache = function _addToCache(level, namespace, logArguments) {\n    this._emitToConsole(\"debug\", \"MetricsLogger\", [\n        \"_addToCache:\",\n        arguments,\n        this.options.addTime,\n        this.cache.length()\n    ]);\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ '\\t logArguments:', logArguments ]);\n    var self = this;\n    // try add to the cache and if we've got _postSize number of entries, attempt to post them to the server\n    try {\n        var newLength = self.cache.add(self._buildEntry(level, namespace, logArguments));\n        if (newLength >= self._postSize) {\n            self._postCache();\n        }\n        // discard entry if an error occurs, but warn if level set to do so\n    } catch (err) {\n        self._emitToConsole(\"warn\", \"MetricsLogger\", [\n            \"Metrics logger could not stringify logArguments:\",\n            namespace,\n            logArguments\n        ]);\n        self._emitToConsole(\"error\", \"MetricsLogger\", [err]);\n    }\n    return self;\n};\n\n/** build a log cache entry object from the given level, namespace, and arguments (optionally adding timestamp */\nMetricsLogger.prototype._buildEntry = function _buildEntry(level, namespace, logArguments) {\n    this._emitToConsole(\"debug\", \"MetricsLogger\", [\"_buildEntry:\", arguments]);\n    var entry = {\n        level: level,\n        namespace: this.options.clientPrefix + namespace,\n        args: logArguments\n    };\n    if (this.options.addTime) {\n        entry.time = new Date().toISOString();\n    }\n    return entry;\n};\n\n/** post _postSize messages from the cache to the server, removing them if successful\n *      if the post fails, wait until maxCacheSize is accumulated instead and try again then\n *      in addition to the messages from the cache ('metrics'), any info from getPingData (if set) will be sent\n *      onServerResponse will be called (if set) with any response from the server\n */\nMetricsLogger.prototype._postCache = function _postCache(options) {\n    options = options || {};\n    this._emitToConsole(\"info\", \"MetricsLogger\", [\"_postCache\", options, this._postSize]);\n\n    // short circuit if we're already sending\n    if (!this.options.postUrl || this._sending) {\n        return jQuery.when({});\n    }\n\n    var self = this;\n    var postSize = options.count || self._postSize;\n\n    var // do not splice - remove after *successful* post\n    entries = self.cache.get(postSize);\n\n    var entriesLength = entries.length;\n\n    var // use the optional getPingData to add any extra info we may want to send\n    postData = typeof self.options.getPingData === \"function\" ? self.options.getPingData() : {};\n\n    //console.debug( postSize, entriesLength );\n\n    // add the metrics and send\n    postData.metrics = JSON.stringify(entries);\n    //console.debug( postData.metrics );\n    self._sending = true;\n    return jQuery\n        .post(self.options.postUrl, postData)\n        .always(() => {\n            self._sending = false;\n        })\n        .fail((xhr, status, message) => {\n            // if we failed the previous time, set the next post target to the max num of entries\n            self._postSize = self.options.maxCacheSize;\n            //TODO:??\n            // log this failure to explain any gap in metrics\n            self.emit(\"error\", \"MetricsLogger\", [\n                \"_postCache error:\",\n                xhr.readyState,\n                xhr.status,\n                xhr.responseJSON || xhr.responseText\n            ]);\n            //TODO: still doesn't solve the problem that when cache == max, post will be tried on every emit\n            //TODO: see _delayPost\n        })\n        .done(response => {\n            if (typeof self.options.onServerResponse === \"function\") {\n                self.options.onServerResponse(response);\n            }\n            // only remove if post successful\n            self.cache.remove(entriesLength);\n            //console.debug( 'removed entries:', entriesLength, 'size now:', self.cache.length() );\n            // if we succeeded, reset the post target to the normal num of entries\n            self._postSize = self.options.postSize;\n        });\n    // return the xhr promise\n};\n\n/** set _waiting to true and, after delayPostInMs, set it back to false */\nMetricsLogger.prototype._delayPost = function _delayPost() {\n    //TODO: this won't work between pages\n    var self = this;\n    self._waiting = setTimeout(() => {\n        self._waiting = null;\n    }, self.options.delayPostInMs);\n};\n\n//----------------------------------------------------------------------------- console\n/** output message to console based on level and consoleLogger type */\nMetricsLogger.prototype._emitToConsole = function _emitToConsole(level, namespace, logArguments) {\n    //console.debug( '_emitToConsole:', level, namespace, logArguments );\n    var self = this;\n\n    var whitelist = self.options.consoleNamespaceWhitelist;\n    if (!self.consoleLogger) {\n        return self;\n    }\n    // if a whitelist for namespaces is set, bail if this namespace is not in the list\n    if (whitelist && whitelist.indexOf(namespace) === -1) {\n        return self;\n    }\n\n    var args = Array.prototype.slice.call(logArguments, 0);\n    args.unshift(namespace);\n    //TODO: script location and/or source maps?\n    //TODO: branch on navigator.userAgent == AIIEEE - it only has log\n    if (level >= MetricsLogger.METRIC && typeof self.consoleLogger.info === \"function\") {\n        return self.consoleLogger.info.apply(self.consoleLogger, args);\n    } else if (level >= MetricsLogger.ERROR && typeof self.consoleLogger.error === \"function\") {\n        return self.consoleLogger.error.apply(self.consoleLogger, args);\n    } else if (level >= MetricsLogger.WARN && typeof self.consoleLogger.warn === \"function\") {\n        self.consoleLogger.warn.apply(self.consoleLogger, args);\n    } else if (level >= MetricsLogger.INFO && typeof self.consoleLogger.info === \"function\") {\n        self.consoleLogger.info.apply(self.consoleLogger, args);\n    } else if (level >= MetricsLogger.DEBUG && typeof self.consoleLogger.debug === \"function\") {\n        self.consoleLogger.debug.apply(self.consoleLogger, args);\n    } else if (typeof self.consoleLogger.log === \"function\") {\n        self.consoleLogger.log.apply(self.consoleLogger, args);\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- shortcuts\n// generic functions when logging from non-namespaced object (e.g. templates)\n/** log to default namespace */\nMetricsLogger.prototype.log = function log() {\n    this.emit(1, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n};\n\n/** debug to default namespace */\nMetricsLogger.prototype.debug = function debug() {\n    this.emit(MetricsLogger.DEBUG, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n};\n\n/** info to default namespace */\nMetricsLogger.prototype.info = function info() {\n    this.emit(MetricsLogger.INFO, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n};\n\n/** warn to default namespace */\nMetricsLogger.prototype.warn = function warn() {\n    this.emit(MetricsLogger.WARN, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n};\n\n/** error to default namespace */\nMetricsLogger.prototype.error = function error() {\n    this.emit(MetricsLogger.ERROR, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n};\n\n/** metric to default namespace */\nMetricsLogger.prototype.metric = function metric() {\n    this.emit(MetricsLogger.METRIC, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n};\n\n/* ============================================================================\nTODO:\n    need a performance pass - the JSON un/parsing is a bit much\n\n============================================================================ */\n/** @class LoggingCache\n *  Simple implementation of cache wrapping an array.\n *\n *  Formats an entry before it's cached and only keeps options.maxSize number\n *  of entries. Older entries are deleted first.\n */\nfunction LoggingCache(options) {\n    var self = this;\n    return self._init(options || {});\n}\n\n/** default options */\nLoggingCache.defaultOptions = {\n    /** maximum number of entries to keep before discarding oldest */\n    maxSize: 5000\n};\n\n/** initialize with options */\nLoggingCache.prototype._init = function _init(options) {\n    if (!this._hasStorage()) {\n        //TODO: fall back to jstorage\n        throw new Error(\"LoggingCache needs localStorage\");\n    }\n    if (!options.key) {\n        throw new Error(\"LoggingCache needs key for localStorage\");\n    }\n    this.key = options.key;\n    this._initStorage();\n\n    this.maxSize = options.maxSize || LoggingCache.defaultOptions.maxSize;\n    return this;\n};\n\n/** tests for localStorage fns */\nLoggingCache.prototype._hasStorage = function _hasStorage() {\n    //TODO: modernizr\n    var test = \"test\";\n    try {\n        localStorage.setItem(test, test);\n        localStorage.removeItem(test);\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\n\n/** if no localStorage set for key, initialize to empty array */\nLoggingCache.prototype._initStorage = function _initStorage() {\n    if (localStorage.getItem(this.key) === null) {\n        return this.empty();\n    }\n    return this;\n};\n\n/** add an entry to the cache, removing the oldest beforehand if size >= maxSize */\nLoggingCache.prototype.add = function add(entry) {\n    var self = this;\n    var _cache = self._fetchAndParse();\n    var overage = _cache.length + 1 - self.maxSize;\n    if (overage > 0) {\n        _cache.splice(0, overage);\n    }\n    _cache.push(entry);\n    self._unparseAndStore(_cache);\n    return _cache.length;\n};\n\n/** get the entries from localStorage and parse them */\nLoggingCache.prototype._fetchAndParse = function _fetchAndParse() {\n    var self = this;\n    return JSON.parse(localStorage.getItem(self.key));\n};\n\n/** stringify the entries and put them in localStorage */\nLoggingCache.prototype._unparseAndStore = function _unparseAndStore(entries) {\n    var self = this;\n    return localStorage.setItem(self.key, JSON.stringify(entries));\n};\n\n///** process the entry before caching */\n//LoggingCache.prototype._preprocessEntry = function _preprocessEntry( entry ){\n//    return JSON.stringify( entry );\n//};\n\n/** return the length --- oh, getters where are you? */\nLoggingCache.prototype.length = function length() {\n    return this._fetchAndParse().length;\n};\n\n/** get count number of entries starting with the oldest */\nLoggingCache.prototype.get = function get(count) {\n    return this._fetchAndParse().slice(0, count);\n};\n\n/** remove count number of entries starting with the oldest */\nLoggingCache.prototype.remove = function remove(count) {\n    var _cache = this._fetchAndParse();\n    var removed = _cache.splice(0, count);\n    this._unparseAndStore(_cache);\n    return removed;\n};\n\n/** empty/clear the entire cache */\nLoggingCache.prototype.empty = function empty() {\n    localStorage.setItem(this.key, \"[]\");\n    return this;\n};\n\n/** stringify count number of entries (but do not remove) */\nLoggingCache.prototype.stringify = function stringify(count) {\n    return JSON.stringify(this.get(count));\n};\n\n/** outputs entire cache to console */\nLoggingCache.prototype.print = function print() {\n    // popup? (really, carl? a popup?) - easier to copy/paste\n    console.log(JSON.stringify(this._fetchAndParse(), null, \"  \"));\n};\n\n//=============================================================================\nexport default {\n    MetricsLogger: MetricsLogger,\n    LoggingCache: LoggingCache\n};\n"]}