{"version":3,"sources":["mvc/history/history-model.js"],"names":["History","Backbone","Model","extend","_baseMvc2","default","LoggableMixin","mixin","SearchableModelMixin","_logNamespace","UPDATE_DELAY","defaults","model_class","id","name","state","deleted","contents_active","urlRoot","Galaxy","root","_historyContents2","HistoryContents","tag","contentsClass","historyJSON","options","this","logger","searchAttributes","searchAliases","history","historyId","get","order","_setUpListeners","_setUpCollectionListeners","initialize","updateTimeoutId","on","clearUpdateTimeout","model","newId","contents","error","trigger","apply","arguments","contentsShown","contentsActive","active","shown","includeDeleted","includeHidden","hidden","nice_size","size","_utils2","bytesToString","_localization2","toJSON","_","prototype","call","key","user","isAnonymous","numOfUnfinishedJobs","unfinishedJobIds","length","numOfUnfinishedShownContents","runningAndActive","_fetchContentRelatedAttributes","contentRelatedAttrs","fetch","data","$","param","keys","join","refresh","self","lastUpdateTime","allFetched","fetchPage","currentPage","fetchUpdated","done","response","status","xhr","serverResponseDatetime","Date","getResponseHeader","checkForUpdates","delay","_delayThenUpdate","historyData","clearTimeout","parse","parsed","create_time","update_time","fetchWithContents","contentsOptions","then","setHistoryId","fetchContents","view","fetchCurrentPage","save","jQuery","when","purged","undelete","copy","current","allDatasets","Error","postData","all_datasets","post","setAsCurrent","getJSON","newHistory","toString","_collectionSuper","InfinitelyScrollingCollection","HistoryCollection","limitOnFirstFetch","limitPerFetch","models","log","currentHistoryId","url","setUpListeners","change:deleted","debug","remove","copied","newData","setCurrent","oldCurrentId","_buildFetchData","_buildFetchFilters","superFilters","filters","fetchFirst","silent","limit","encoded_id-in","comparators","clone","name-dsc","buildComparator","ascending","size-asc","fetchMore","currentHistory","sort","unshift","create","hdas","historyOptions","xhrOptions","collection"],"mappings":"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","file":"../../../scripts/mvc/history/history-model.js","sourcesContent":["import HISTORY_CONTENTS from \"mvc/history/history-contents\";\nimport HISTORY_PREFS from \"mvc/history/history-preferences\";\nimport CONTROLLED_FETCH_COLLECTION from \"mvc/base/controlled-fetch-collection\";\nimport UTILS from \"utils/utils\";\nimport BASE_MVC from \"mvc/base-mvc\";\nimport _l from \"utils/localization\";\n\n//==============================================================================\n/** @class Model for a Galaxy history resource - both a record of user\n *      tool use and a collection of the datasets those tools produced.\n *  @name History\n *  @augments Backbone.Model\n */\nvar History = Backbone.Model.extend(BASE_MVC.LoggableMixin).extend(\n    BASE_MVC.mixin(\n        BASE_MVC.SearchableModelMixin,\n        /** @lends History.prototype */ {\n            _logNamespace: \"history\",\n\n            /** ms between fetches when checking running jobs/datasets for updates */\n            UPDATE_DELAY: 4000,\n\n            // values from api (may need more)\n            defaults: {\n                model_class: \"History\",\n                id: null,\n                name: \"Unnamed History\",\n                state: \"new\",\n\n                deleted: false,\n                contents_active: {},\n                contents_states: {}\n            },\n\n            urlRoot: `${Galaxy.root}api/histories`,\n\n            contentsClass: HISTORY_CONTENTS.HistoryContents,\n\n            /** What model fields to search with */\n            searchAttributes: [\"name\", \"annotation\", \"tags\"],\n\n            /** Adding title and singular tag */\n            searchAliases: {\n                title: \"name\",\n                tag: \"tags\"\n            },\n\n            // ........................................................................ set up/tear down\n            /** Set up the model\n     *  @param {Object} historyJSON model data for this History\n     *  @param {Object} options     any extra settings including logger\n     */\n            initialize: function(historyJSON, options) {\n                options = options || {};\n                this.logger = options.logger || null;\n                this.log(`${this}.initialize:`, historyJSON, options);\n\n                /** HistoryContents collection of the HDAs contained in this history. */\n                this.contents = new this.contentsClass([], {\n                    history: this,\n                    historyId: this.get(\"id\"),\n                    order: options.order\n                });\n\n                this._setUpListeners();\n                this._setUpCollectionListeners();\n\n                /** cached timeout id for the dataset updater */\n                this.updateTimeoutId = null;\n            },\n\n            /** set up any event listeners for this history including those to the contained HDAs\n     *  events: error:contents  if an error occurred with the contents collection\n     */\n            _setUpListeners: function() {\n                // if the model's id changes ('current' or null -> an actual id), update the contents history_id\n                return this.on({\n                    error: function(model, xhr, options, msg, details) {\n                        this.clearUpdateTimeout();\n                    },\n                    \"change:id\": function(model, newId) {\n                        if (this.contents) {\n                            this.contents.historyId = newId;\n                        }\n                    }\n                });\n            },\n\n            /** event handlers for the contents submodels */\n            _setUpCollectionListeners: function() {\n                if (!this.contents) {\n                    return this;\n                }\n                // bubble up errors\n                return this.listenTo(this.contents, {\n                    error: function() {\n                        this.trigger.apply(this, jQuery.makeArray(arguments));\n                    }\n                });\n            },\n\n            // ........................................................................ derived attributes\n            /**  */\n            contentsShown: function() {\n                var contentsActive = this.get(\"contents_active\");\n                var shown = contentsActive.active || 0;\n                shown += this.contents.includeDeleted ? contentsActive.deleted : 0;\n                shown += this.contents.includeHidden ? contentsActive.hidden : 0;\n                return shown;\n            },\n\n            /** convert size in bytes to a more human readable version */\n            nice_size: function() {\n                var size = this.get(\"size\");\n                return size ? UTILS.bytesToString(size, true, 2) : _l(\"(empty)\");\n            },\n\n            /** override to add nice_size */\n            toJSON: function() {\n                return _.extend(Backbone.Model.prototype.toJSON.call(this), {\n                    nice_size: this.nice_size()\n                });\n            },\n\n            /** override to allow getting nice_size */\n            get: function(key) {\n                if (key === \"nice_size\") {\n                    return this.nice_size();\n                }\n                return Backbone.Model.prototype.get.apply(this, arguments);\n            },\n\n            // ........................................................................ common queries\n            /** T/F is this history owned by the current user (Galaxy.user)\n     *      Note: that this will return false for an anon user even if the history is theirs.\n     */\n            ownedByCurrUser: function() {\n                // no currUser\n                if (!Galaxy || !Galaxy.user) {\n                    return false;\n                }\n                // user is anon or history isn't owned\n                if (Galaxy.user.isAnonymous() || Galaxy.user.id !== this.get(\"user_id\")) {\n                    return false;\n                }\n                return true;\n            },\n\n            /** Return the number of running jobs assoc with this history (note: unknown === 0) */\n            numOfUnfinishedJobs: function() {\n                var unfinishedJobIds = this.get(\"non_ready_jobs\");\n                return unfinishedJobIds ? unfinishedJobIds.length : 0;\n            },\n\n            /** Return the number of running hda/hdcas in this history (note: unknown === 0) */\n            numOfUnfinishedShownContents: function() {\n                return this.contents.runningAndActive().length || 0;\n            },\n\n            // ........................................................................ updates\n            _fetchContentRelatedAttributes: function() {\n                var contentRelatedAttrs = [\"size\", \"non_ready_jobs\", \"contents_active\", \"hid_counter\"];\n                return this.fetch({\n                    data: $.param({\n                        keys: contentRelatedAttrs.join(\",\")\n                    })\n                });\n            },\n\n            /** check for any changes since the last time we updated (or fetch all if ) */\n            refresh: function(options) {\n                // console.log( this + '.refresh' );\n                options = options || {};\n                var self = this;\n\n                // note if there was no previous update time, all summary contents will be fetched\n                var lastUpdateTime = self.lastUpdateTime;\n                // if we don't flip this, then a fully-fetched list will not be re-checked via fetch\n                this.contents.allFetched = false;\n                var fetchFn =\n                    self.contents.currentPage !== 0\n                        ? () => self.contents.fetchPage(self.contents.currentPage)\n                        : () => self.contents.fetchUpdated(lastUpdateTime);\n                // note: if there was no previous update time, all summary contents will be fetched\n                return fetchFn().done((response, status, xhr) => {\n                    var serverResponseDatetime;\n                    try {\n                        serverResponseDatetime = new Date(xhr.getResponseHeader(\"Date\"));\n                    } catch (err) {}\n                    self.lastUpdateTime = serverResponseDatetime || new Date();\n                    self.checkForUpdates(options);\n                });\n            },\n\n            /** continuously fetch updated contents every UPDATE_DELAY ms if this history's datasets or jobs are unfinished */\n            checkForUpdates: function(options) {\n                // console.log( this + '.checkForUpdates' );\n                options = options || {};\n                var delay = this.UPDATE_DELAY;\n                var self = this;\n                if (!self.id) {\n                    return;\n                }\n\n                function _delayThenUpdate() {\n                    // prevent buildup of updater timeouts by clearing previous if any, then set new and cache id\n                    self.clearUpdateTimeout();\n                    self.updateTimeoutId = setTimeout(() => {\n                        self.refresh(options);\n                    }, delay);\n                }\n\n                // if there are still datasets in the non-ready state, recurse into this function with the new time\n                var nonReadyContentCount = this.numOfUnfinishedShownContents();\n                // console.log( 'nonReadyContentCount:', nonReadyContentCount );\n                if (nonReadyContentCount > 0) {\n                    _delayThenUpdate();\n                } else {\n                    // no datasets are running, but currently runnning jobs may still produce new datasets\n                    // see if the history has any running jobs and continue to update if so\n                    // (also update the size for the user in either case)\n                    self._fetchContentRelatedAttributes().done(historyData => {\n                        // console.log( 'non_ready_jobs:', historyData.non_ready_jobs );\n                        if (self.numOfUnfinishedJobs() > 0) {\n                            _delayThenUpdate();\n                        } else {\n                            // otherwise, let listeners know that all updates have stopped\n                            self.trigger(\"ready\");\n                        }\n                    });\n                }\n            },\n\n            /** clear the timeout and the cached timeout id */\n            clearUpdateTimeout: function() {\n                if (this.updateTimeoutId) {\n                    clearTimeout(this.updateTimeoutId);\n                    this.updateTimeoutId = null;\n                }\n            },\n\n            // ........................................................................ ajax\n            /** override to use actual Dates objects for create/update times */\n            parse: function(response, options) {\n                var parsed = Backbone.Model.prototype.parse.call(this, response, options);\n                if (parsed.create_time) {\n                    parsed.create_time = new Date(parsed.create_time);\n                }\n                if (parsed.update_time) {\n                    parsed.update_time = new Date(parsed.update_time);\n                }\n                return parsed;\n            },\n\n            /** fetch this histories data (using options) then it's contents (using contentsOptions) */\n            fetchWithContents: function(options, contentsOptions) {\n                options = options || {};\n                var self = this;\n\n                // console.log( this + '.fetchWithContents' );\n                // TODO: push down to a base class\n                options.view = \"dev-detailed\";\n\n                // fetch history then use history data to fetch (paginated) contents\n                return this.fetch(options).then(function getContents(history) {\n                    self.contents.history = self;\n                    self.contents.setHistoryId(history.id);\n                    return self.fetchContents(contentsOptions);\n                });\n            },\n\n            /** fetch this histories contents, adjusting options based on the stored history preferences */\n            fetchContents: function(options) {\n                options = options || {};\n                var self = this;\n\n                // we're updating, reset the update time\n                self.lastUpdateTime = new Date();\n                return self.contents.fetchCurrentPage(options);\n            },\n\n            /** save this history, _Mark_ing it as deleted (just a flag) */\n            _delete: function(options) {\n                if (this.get(\"deleted\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: true }, options);\n            },\n            /** purge this history, _Mark_ing it as purged and removing all dataset data from the server */\n            purge: function(options) {\n                if (this.get(\"purged\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: true, purged: true }, options);\n            },\n            /** save this history, _Mark_ing it as undeleted */\n            undelete: function(options) {\n                if (!this.get(\"deleted\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: false }, options);\n            },\n\n            /** Make a copy of this history on the server\n     *  @param {Boolean} current    if true, set the copy as the new current history (default: true)\n     *  @param {String} name        name of new history (default: none - server sets to: Copy of <current name>)\n     *  @fires copied               passed this history and the response JSON from the copy\n     *  @returns {xhr}\n     */\n            copy: function(current, name, allDatasets) {\n                current = current !== undefined ? current : true;\n                if (!this.id) {\n                    throw new Error(\"You must set the history ID before copying it.\");\n                }\n\n                var postData = { history_id: this.id };\n                if (current) {\n                    postData.current = true;\n                }\n                if (name) {\n                    postData.name = name;\n                }\n                if (!allDatasets) {\n                    postData.all_datasets = false;\n                }\n                postData.view = \"dev-detailed\";\n\n                var history = this;\n                var copy = jQuery.post(this.urlRoot, postData);\n                // if current - queue to setAsCurrent before firing 'copied'\n                if (current) {\n                    return copy.then(response => {\n                        var newHistory = new History(response);\n                        return newHistory.setAsCurrent().done(() => {\n                            history.trigger(\"copied\", history, response);\n                        });\n                    });\n                }\n                return copy.done(response => {\n                    history.trigger(\"copied\", history, response);\n                });\n            },\n\n            setAsCurrent: function() {\n                var history = this;\n\n                var xhr = jQuery.getJSON(`${Galaxy.root}history/set_as_current?id=${this.id}`);\n\n                xhr.done(() => {\n                    history.trigger(\"set-as-current\", history);\n                });\n                return xhr;\n            },\n\n            // ........................................................................ misc\n            toString: function() {\n                return `History(${this.get(\"id\")},${this.get(\"name\")})`;\n            }\n        }\n    )\n);\n\n//==============================================================================\nvar _collectionSuper = CONTROLLED_FETCH_COLLECTION.InfinitelyScrollingCollection;\n/** @class A collection of histories (per user)\n *      that maintains the current history as the first in the collection.\n *  New or copied histories become the current history.\n */\nvar HistoryCollection = _collectionSuper.extend(BASE_MVC.LoggableMixin).extend({\n    _logNamespace: \"history\",\n\n    model: History,\n    /** @type {String} initial order used by collection */\n    order: \"update_time\",\n    /** @type {Number} limit used for the first fetch (or a reset) */\n    limitOnFirstFetch: 10,\n    /** @type {Number} limit used for each subsequent fetch */\n    limitPerFetch: 10,\n\n    initialize: function(models, options) {\n        options = options || {};\n        this.log(\"HistoryCollection.initialize\", models, options);\n        _collectionSuper.prototype.initialize.call(this, models, options);\n\n        /** @type {boolean} should deleted histories be included */\n        this.includeDeleted = options.includeDeleted || false;\n\n        /** @type {String} encoded id of the history that's current */\n        this.currentHistoryId = options.currentHistoryId;\n\n        this.setUpListeners();\n        // note: models are sent to reset *after* this fn ends; up to this point\n        // the collection *is empty*\n    },\n\n    urlRoot: `${Galaxy.root}api/histories`,\n    url: function() {\n        return this.urlRoot;\n    },\n\n    /** set up reflexive event handlers */\n    setUpListeners: function setUpListeners() {\n        return this.on({\n            // when a history is deleted, remove it from the collection (if optionally set to do so)\n            \"change:deleted\": function(history) {\n                // TODO: this becomes complicated when more filters are used\n                this.debug(\"change:deleted\", this.includeDeleted, history.get(\"deleted\"));\n                if (!this.includeDeleted && history.get(\"deleted\")) {\n                    this.remove(history);\n                }\n            },\n            // listen for a history copy, setting it to current\n            copied: function(original, newData) {\n                this.setCurrent(new History(newData, []));\n            },\n            // when a history is made current, track the id in the collection\n            \"set-as-current\": function(history) {\n                var oldCurrentId = this.currentHistoryId;\n                this.trigger(\"no-longer-current\", oldCurrentId);\n                this.currentHistoryId = history.id;\n            }\n        });\n    },\n\n    /** override to change view */\n    _buildFetchData: function(options) {\n        return _.extend(_collectionSuper.prototype._buildFetchData.call(this, options), {\n            view: \"dev-detailed\"\n        });\n    },\n\n    /** override to filter out deleted and purged */\n    _buildFetchFilters: function(options) {\n        var superFilters = _collectionSuper.prototype._buildFetchFilters.call(this, options) || {};\n        var filters = {};\n        if (!this.includeDeleted) {\n            filters.deleted = false;\n            filters.purged = false;\n        } else {\n            // force API to return both deleted and non\n            //TODO: when the API is updated, remove this\n            filters.deleted = null;\n        }\n        return _.defaults(superFilters, filters);\n    },\n\n    /** override to fetch current as well (as it may be outside the first 10, etc.) */\n    fetchFirst: function(options) {\n        var self = this;\n        // TODO: batch?\n        var xhr = $.when();\n        if (this.currentHistoryId) {\n            xhr = _collectionSuper.prototype.fetchFirst.call(self, {\n                silent: true,\n                limit: 1,\n                filters: {\n                    // without these a deleted current history will return [] here and block the other xhr\n                    purged: \"\",\n                    deleted: \"\",\n                    \"encoded_id-in\": this.currentHistoryId\n                }\n            });\n        }\n        return xhr.then(() => {\n            options = options || {};\n            options.offset = 0;\n            return self.fetchMore(options);\n        });\n    },\n\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators: _.extend(_.clone(_collectionSuper.prototype.comparators), {\n        name: BASE_MVC.buildComparator(\"name\", {\n            ascending: true\n        }),\n        \"name-dsc\": BASE_MVC.buildComparator(\"name\", {\n            ascending: false\n        }),\n        size: BASE_MVC.buildComparator(\"size\", {\n            ascending: false\n        }),\n        \"size-asc\": BASE_MVC.buildComparator(\"size\", {\n            ascending: true\n        })\n    }),\n\n    /** override to always have the current history first */\n    sort: function(options) {\n        options = options || {};\n        var silent = options.silent;\n        var currentHistory = this.remove(this.get(this.currentHistoryId));\n        _collectionSuper.prototype.sort.call(this, _.defaults({ silent: true }, options));\n        this.unshift(currentHistory, { silent: true });\n        if (!silent) {\n            this.trigger(\"sort\", this, options);\n        }\n        return this;\n    },\n\n    /** create a new history and by default set it to be the current history */\n    create: function create(data, hdas, historyOptions, xhrOptions) {\n        //TODO: .create is actually a collection function that's overridden here\n        var collection = this;\n\n        var xhr = jQuery.getJSON(`${Galaxy.root}history/create_new_current`);\n        return xhr.done(newData => {\n            collection.setCurrent(new History(newData, [], historyOptions || {}));\n        });\n    },\n\n    /** set the current history to the given history, placing it first in the collection.\n     *  Pass standard bbone options for use in unshift.\n     *  @triggers new-current passed history and this collection\n     */\n    setCurrent: function(history, options) {\n        options = options || {};\n        // new histories go in the front\n        this.unshift(history, options);\n        this.currentHistoryId = history.get(\"id\");\n        if (!options.silent) {\n            this.trigger(\"new-current\", history, this);\n        }\n        return this;\n    },\n\n    toString: function toString() {\n        return `HistoryCollection(${this.length},current:${this.currentHistoryId})`;\n    }\n});\n\n//==============================================================================\nexport default {\n    History: History,\n    HistoryCollection: HistoryCollection\n};\n"]}