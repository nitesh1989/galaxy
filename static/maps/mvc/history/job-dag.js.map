{"version":3,"sources":["mvc/history/job-dag.js"],"names":["_super","_graph2","default","Graph","JobDAG","options","self","this","filters","_historyContentsMap","_toolMap","_outputIdToJobMap","filteredSetMetadata","dataKeys","call","_","pick","omit","filteredErroredJobs","excludeSetMetadata","prototype","constructor","init","push","jobData","_initFilters","job","id","excludeErroredJobs","tool_id","isArray","debug","length","read","data","has","historyContents","concat","preprocessJobs","jobs","createGraph","_filterJobs","_read","preprocessHistoryContents","content","i","clone","preprocessTools","tools","info","tool","preprocessJob","sort","a","b","create_time","cmpCreate","index","inputs","_processInputs","size","noInputJobs","outputs","_processOutputs","noOutputJobs","inputMap","each","input","nameInJob","name","inputOutput","Error","JSON","stringify","src","outputMap","output","_validateInputOutput","_filterJob","j","jobsData","createVertex","targetId","inputId","sourceId","createJobLessVertex","directed","dataset","toVerticesAndEdges","contentId","mangledId","createEdge","dag","weakComponents","map","component","vertices","aCreateTime","bCreateTime","weakComponentGraphArray","_jobsDataMap","jobsDataMap","_jobsData","forEach"],"mappings":"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","file":"../../../scripts/mvc/history/job-dag.js","sourcesContent":["import GRAPH from \"utils/graph\";\nimport addLogging from \"utils/add-logging\";\n\n// ============================================================================\nvar _super = GRAPH.Graph;\n/** A Directed acyclic Graph built from a history's job data.\n *      Reads in job json, filters and process that json, and builds a graph\n *      using the connections between job inputs and outputs.\n */\nvar JobDAG = function(options) {\n    options = options || {};\n    var self = this;\n    //this.logger = console;\n\n    self.filters = [];\n\n    // instance vars\n    //TODO: needed?\n    self._jobsData = [];\n    self._historyContentsMap = {};\n    self._toolMap = {};\n\n    self._outputIdToJobMap = {};\n    self.noInputJobs = [];\n    self.noOutputJobs = [];\n\n    //TODO: save these?\n    self.filteredSetMetadata = [];\n    self.filteredErroredJobs = [];\n\n    self.dataKeys = [\"jobs\", \"historyContents\", \"tools\"];\n    _super.call(self, true, _.pick(options, self.dataKeys), _.omit(options, self.dataKeys));\n};\nJobDAG.prototype = new GRAPH.Graph();\nJobDAG.prototype.constructor = JobDAG;\n\n// add logging ability - turn off/on using the this.logger statement above\naddLogging(JobDAG);\n\n// ----------------------------------------------------------------------------\n/** process jobs, options, filters, and any history data, then create the graph */\nJobDAG.prototype.init = function _init(options) {\n    options = options || {};\n\n    var self = this;\n    self.options = _.defaults(options, {\n        excludeSetMetadata: false\n    });\n    self.filters = self._initFilters();\n\n    _super.prototype.init.call(self, options);\n    return self;\n};\n\n/** add job filters based on options */\nJobDAG.prototype._initFilters = function __initFilters() {\n    var self = this;\n    var filters = [];\n\n    if (self.options.excludeSetMetadata) {\n        self.filteredSetMetadata = [];\n        filters.push(function filterSetMetadata(jobData) {\n            if (jobData.job.tool_id !== \"__SET_METADATA__\") {\n                return true;\n            }\n            self.filteredSetMetadata.push(jobData.job.id);\n            return false;\n        });\n    }\n\n    if (self.options.excludeErroredJobs) {\n        self.filteredErroredJobs = [];\n        filters.push(function filterErrored(jobData) {\n            if (jobData.job.state !== \"error\") {\n                return true;\n            }\n            self.filteredErroredJobs.push(jobData.job.id);\n            return false;\n        });\n    }\n\n    // all outputs deleted\n    // all outputs hidden\n\n    if (_.isArray(self.options.filters)) {\n        filters = filters.concat(self.options.filters);\n    }\n    self.debug(\"filters len:\", filters.length);\n    return filters;\n};\n\n/**  */\nJobDAG.prototype.read = function _read(data) {\n    var self = this;\n    if (_.has(data, \"historyContents\") && _.has(data, \"jobs\") && _.has(data, \"tools\")) {\n        // a job dag is composed of these three elements:\n        //  clone the 3 data sources into the DAG, processing the jobs finally using the history and tools\n        self\n            .preprocessHistoryContents(data.historyContents || [])\n            .preprocessTools(data.tools || {})\n            .preprocessJobs(data.jobs || []);\n\n        // filter jobs and create the vertices and edges of the job DAG\n        self.createGraph(self._filterJobs());\n        return self;\n    }\n    return _super.prototype.read.call(this, data);\n};\n\n/**  */\nJobDAG.prototype.preprocessHistoryContents = function _preprocessHistoryContents(historyContents) {\n    this.info(\"processing history\");\n    var self = this;\n    self._historyContentsMap = {};\n\n    historyContents.forEach((content, i) => {\n        self._historyContentsMap[content.id] = _.clone(content);\n    });\n    return self;\n};\n\n/**  */\nJobDAG.prototype.preprocessTools = function _preprocessTools(tools) {\n    this.info(\"processing tools\");\n    var self = this;\n    self._toolMap = {};\n\n    _.each(tools, (tool, id) => {\n        self._toolMap[id] = _.clone(tool);\n    });\n    return self;\n};\n\n/** sort the cloned jobs, decorate with tool and history contents info, and store in prop array */\nJobDAG.prototype.preprocessJobs = function _preprocessJobs(jobs) {\n    this.info(\"processing jobs\");\n    var self = this;\n    self._outputIdToJobMap = {};\n\n    self._jobsData = self.sort(jobs).map(job => self.preprocessJob(_.clone(job)));\n    //console.debug( JSON.stringify( self._jobsData, null, '    ' ) );\n    //console.debug( JSON.stringify( self._outputIdToJobMap, null, '    ' ) );\n    return self;\n};\n\n/** sort the jobs based on update time */\nJobDAG.prototype.sort = function _sort(jobs) {\n    function cmpCreate(a, b) {\n        if (a.create_time > b.create_time) {\n            return 1;\n        }\n        if (a.create_time < b.create_time) {\n            return -1;\n        }\n        return 0;\n    }\n    return jobs.sort(cmpCreate);\n};\n\n/** decorate with input/output datasets and tool */\nJobDAG.prototype.preprocessJob = function _preprocessJob(job, index) {\n    //this.info( 'preprocessJob', job, index );\n    var self = this;\n\n    var jobData = { job: job };\n\n    jobData.inputs = self._processInputs(job);\n    if (_.size(jobData.inputs) === 0) {\n        self.noInputJobs.push(job.id);\n    }\n    jobData.outputs = self._processOutputs(job);\n    if (_.size(jobData.outputs) === 0) {\n        self.noOutputJobs.push(job.id);\n    }\n\n    jobData.tool = self._toolMap[job.tool_id];\n\n    //self.info( '\\t jobData:', jobData );\n    return jobData;\n};\n\n/**\n */\nJobDAG.prototype._processInputs = function __processInputs(job) {\n    var self = this;\n    var inputs = job.inputs;\n    var inputMap = {};\n    _.each(inputs, (input, nameInJob) => {\n        input = _.clone(self._validateInputOutput(input));\n        input.name = nameInJob;\n        // since this is a DAG and we're processing in order of create time,\n        //  the inputs for this job will already be listed in _outputIdToJobMap\n        //  TODO: we can possibly exploit this\n        //console.debug( 'input in _outputIdToJobMap', self._outputIdToJobMap[ input.id ] );\n        input.content = self._historyContentsMap[input.id];\n        inputMap[input.id] = input;\n    });\n    return inputMap;\n};\n\n/**\n */\nJobDAG.prototype._validateInputOutput = function __validateInputOutput(inputOutput) {\n    if (!inputOutput.id) {\n        throw new Error(\"No id on job input/output: \", JSON.stringify(inputOutput));\n    }\n    if (!inputOutput.src || inputOutput.src !== \"hda\") {\n        throw new Error(\"Bad src on job input/output: \", JSON.stringify(inputOutput));\n    }\n    return inputOutput;\n};\n\n/**\n */\nJobDAG.prototype._processOutputs = function __processOutputs(job) {\n    var self = this;\n    var outputs = job.outputs;\n    var outputMap = {};\n    _.each(outputs, (output, nameInJob) => {\n        output = _.clone(self._validateInputOutput(output));\n        output.name = nameInJob;\n        // add dataset content to jobData\n        output.content = self._historyContentsMap[output.id];\n        outputMap[output.id] = output;\n\n        self._outputIdToJobMap[output.id] = job.id;\n    });\n    return outputMap;\n};\n\n/**  */\nJobDAG.prototype._filterJobs = function __filterJobs() {\n    var self = this;\n    return self._jobsData.filter((j, i) => self._filterJob(j, i));\n};\n\n/**\n */\nJobDAG.prototype._filterJob = function _filterJob(jobData, index) {\n    // apply filters after processing job allowing access to the additional data above inside the filters\n    var self = this;\n    for (var i = 0; i < self.filters.length; i++) {\n        if (!self.filters[i].call(self, jobData)) {\n            self.debug(\"\\t job\", jobData.job.id, \" has been filtered out by function:\\n\", self.filters[i]);\n            return false;\n        }\n    }\n    return true;\n};\n\n/** Walk all the jobs (vertices), attempting to find connections\n *  between datasets used as both inputs and outputs (edges)\n */\nJobDAG.prototype.createGraph = function _createGraph(jobsData) {\n    var self = this;\n    self.debug(\"connections:\");\n    //console.debug( jobsData );\n\n    _.each(jobsData, jobData => {\n        var id = jobData.job.id;\n        self.debug(\"\\t\", id, jobData);\n        self.createVertex(id, jobData);\n    });\n    _.each(jobsData, jobData => {\n        var targetId = jobData.job.id;\n        _.each(jobData.inputs, (input, inputId) => {\n            //console.debug( '\\t\\t target input:', inputId, input );\n            var sourceId = self._outputIdToJobMap[inputId];\n            //console.debug( '\\t\\t source job id:', sourceId );\n            if (!sourceId) {\n                var joblessVertex = self.createJobLessVertex(inputId);\n                sourceId = joblessVertex.name;\n            }\n            //TODO:?? no checking here whether sourceId is actually in the vertex map\n            //console.debug( '\\t\\t creating edge, source:', sourceId, self.vertices[ sourceId ] );\n            //console.debug( '\\t\\t creating edge, target:', targetId, self.vertices[ targetId ] );\n            self.createEdge(sourceId, targetId, self.directed, {\n                dataset: inputId\n            });\n        });\n    });\n    //console.debug( self.toVerticesAndEdges().edges );\n\n    self.debug(\"final graph: \", JSON.stringify(self.toVerticesAndEdges(), null, \"  \"));\n    return self;\n};\n\n/** Return a 'mangled' version of history contents id to prevent contents <-> job id collision */\nJobDAG.prototype.createJobLessVertex = function _createJobLessVertex(contentId) {\n    // currently, copied contents are the only history contents without jobs (that I know of)\n    //note: following needed to prevent id collision btwn content and jobs in vertex map\n    var JOBLESS_ID_MANGLER = \"copy-\";\n\n    var mangledId = JOBLESS_ID_MANGLER + contentId;\n    return this.createVertex(mangledId, this._historyContentsMap[contentId]);\n};\n\n/** Override to re-sort (ugh) jobs in each component by update time */\nJobDAG.prototype.weakComponentGraphArray = function() {\n    var dag = this;\n    return this.weakComponents().map(component => {\n        //TODO: this seems to belong above (in sort) - why isn't it preserved?\n        // note: using create_time (as opposed to update_time)\n        //  since update_time for jobless/copied datasets is changes more often\n        component.vertices.sort(function cmpCreate(a, b) {\n            var aCreateTime = a.data.job ? a.data.job.create_time : a.data.create_time;\n\n            var bCreateTime = b.data.job ? b.data.job.create_time : b.data.create_time;\n\n            if (aCreateTime > bCreateTime) {\n                return 1;\n            }\n            if (aCreateTime < bCreateTime) {\n                return -1;\n            }\n            return 0;\n        });\n        return new Graph(dag.directed, component);\n    });\n};\n\nJobDAG.prototype._jobsDataMap = function() {\n    var jobsDataMap = {};\n    this._jobsData.forEach(jobData => {\n        jobsDataMap[jobData.job.id] = jobData;\n    });\n    return jobsDataMap;\n};\n\n// ============================================================================\nexport default JobDAG;\n"]}