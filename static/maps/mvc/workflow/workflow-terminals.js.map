{"version":3,"sources":["mvc/workflow/workflow-terminals.js"],"names":["CollectionTypeDescription","collectionType","this","isCollection","rank","split","length","window","workflow_globals","NULL_COLLECTION_TYPE_DESCRIPTION","canMatch","canMapOver","other","otherCollectionType","toString","ANY_COLLECTION_TYPE_DESCRIPTION","equal","$","extend","prototype","otherCollectionTypeDescription","requiredSuffix","_endsWith","effectiveMapOver","substring","effectiveCollectionType","str","suffix","indexOf","TerminalMapping","Backbone","Model","initialize","attr","mapOver","terminalMapping","disableMapOver","terminal","setMapOver","collectionTypeDescription","trigger","Terminal","element","connect","connectors","connector","node","markChanged","disconnect","splice","inArray","redraw","each","_","c","slice","destroy","destroyIfInvalid","multiple","val","output_terminals","outputTerminal","isMappedOver","resetMappingIfNeeded","call","OutputTerminal","hasConnectedMappedInputTerminals","mappedInputTerminals","mappedInput","hasMappedOverInputTerminals","resetMapping","handle2","connectedInput","BaseInputTerminal","update","_inputFilled","hasConnectedOutputTerminals","connected","inputFilled","inputsFilled","_collectionAttached","firstOutput","handle1","_mappingConstraints","constraints","push","first","values","inputTerminal","_producesAcceptableDatatype","t","thisDatatype","datatypes","cat_outputs","post_job_actions","pja_i","pja","action_type","output_name","name","action_arguments","other_datatype_i","other_datatype","_otherCollectionType","app","isSubType","InputTerminal","otherMapOver","input","append","collection","attachable","other_output","thisMapOver","every","bind","InputCollectionTerminal","collectionTypes","extensions","_effectiveMapOver","some","collectionTypeIndex","_effectiveCollectionTypes","effectiveCollectionTypes","map","mappingConstraints","OutputCollectionTerminal","collection_type","collectionTypeSource","console","output","newCollectionType","log"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-terminals.js","sourcesContent":["// TODO; tie into Galaxy state?\nwindow.workflow_globals = window.workflow_globals || {};\nfunction CollectionTypeDescription(collectionType) {\n    this.collectionType = collectionType;\n    this.isCollection = true;\n    this.rank = collectionType.split(\":\").length;\n}\n\nvar NULL_COLLECTION_TYPE_DESCRIPTION = {\n    isCollection: false,\n    canMatch: function(other) {\n        return false;\n    },\n    canMapOver: function(other) {\n        return false;\n    },\n    toString: function() {\n        return \"NullCollectionType[]\";\n    },\n    append: function(otherCollectionType) {\n        return otherCollectionType;\n    },\n    equal: function(other) {\n        return other === this;\n    }\n};\n\nvar ANY_COLLECTION_TYPE_DESCRIPTION = {\n    isCollection: true,\n    canMatch: function(other) {\n        return NULL_COLLECTION_TYPE_DESCRIPTION !== other;\n    },\n    canMapOver: function(other) {\n        return false;\n    },\n    toString: function() {\n        return \"AnyCollectionType[]\";\n    },\n    append: function(otherCollectionType) {\n        throw \"Cannot append to ANY_COLLECTION_TYPE_DESCRIPTION\";\n    },\n    equal: function(other) {\n        return other === this;\n    }\n};\n\n$.extend(CollectionTypeDescription.prototype, {\n    append: function(otherCollectionTypeDescription) {\n        if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n            return this;\n        }\n        if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n            return otherCollectionType;\n        }\n        return new CollectionTypeDescription(`${this.collectionType}:${otherCollectionTypeDescription.collectionType}`);\n    },\n    canMatch: function(otherCollectionTypeDescription) {\n        if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n            return false;\n        }\n        if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n            return true;\n        }\n        return otherCollectionTypeDescription.collectionType == this.collectionType;\n    },\n    canMapOver: function(otherCollectionTypeDescription) {\n        if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n            return false;\n        }\n        if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n            return false;\n        }\n        if (this.rank <= otherCollectionTypeDescription.rank) {\n            // Cannot map over self...\n            return false;\n        }\n        var requiredSuffix = otherCollectionTypeDescription.collectionType;\n        return this._endsWith(this.collectionType, requiredSuffix);\n    },\n    effectiveMapOver: function(otherCollectionTypeDescription) {\n        var otherCollectionType = otherCollectionTypeDescription.collectionType;\n        var effectiveCollectionType = this.collectionType.substring(\n            0,\n            this.collectionType.length - otherCollectionType.length - 1\n        );\n        return new CollectionTypeDescription(effectiveCollectionType);\n    },\n    equal: function(otherCollectionTypeDescription) {\n        return otherCollectionTypeDescription.collectionType == this.collectionType;\n    },\n    toString: function() {\n        return `CollectionType[${this.collectionType}]`;\n    },\n    _endsWith: function(str, suffix) {\n        return str.indexOf(suffix, str.length - suffix.length) !== -1;\n    }\n});\n\nvar TerminalMapping = Backbone.Model.extend({\n    initialize: function(attr) {\n        this.mapOver = attr.mapOver || NULL_COLLECTION_TYPE_DESCRIPTION;\n        this.terminal = attr.terminal;\n        this.terminal.terminalMapping = this;\n    },\n    disableMapOver: function() {\n        this.setMapOver(NULL_COLLECTION_TYPE_DESCRIPTION);\n    },\n    setMapOver: function(collectionTypeDescription) {\n        // TODO: Can I use \"attributes\" or something to auto trigger \"change\"\n        // event?\n        this.mapOver = collectionTypeDescription;\n        this.trigger(\"change\");\n    }\n});\n\nvar Terminal = Backbone.Model.extend({\n    initialize: function(attr) {\n        this.element = attr.element;\n        this.connectors = [];\n    },\n    connect: function(connector) {\n        this.connectors.push(connector);\n        if (this.node) {\n            this.node.markChanged();\n        }\n    },\n    disconnect: function(connector) {\n        this.connectors.splice($.inArray(connector, this.connectors), 1);\n        if (this.node) {\n            this.node.markChanged();\n            this.resetMappingIfNeeded();\n        }\n    },\n    redraw: function() {\n        $.each(this.connectors, (_, c) => {\n            c.redraw();\n        });\n    },\n    destroy: function() {\n        $.each(this.connectors.slice(), (_, c) => {\n            c.destroy();\n        });\n    },\n    destroyInvalidConnections: function() {\n        _.each(this.connectors, connector => {\n            connector && connector.destroyIfInvalid();\n        });\n    },\n    setMapOver: function(val) {\n        if (this.multiple) {\n            return; // Cannot set this to be multirun...\n        }\n\n        if (!this.mapOver().equal(val)) {\n            this.terminalMapping.setMapOver(val);\n            _.each(this.node.output_terminals, outputTerminal => {\n                outputTerminal.setMapOver(val);\n            });\n        }\n    },\n    mapOver: function() {\n        if (!this.terminalMapping) {\n            return NULL_COLLECTION_TYPE_DESCRIPTION;\n        } else {\n            return this.terminalMapping.mapOver;\n        }\n    },\n    isMappedOver: function() {\n        return this.terminalMapping && this.terminalMapping.mapOver.isCollection;\n    },\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n    },\n\n    resetMappingIfNeeded: function() {} // Subclasses should override this...\n});\n\nvar OutputTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.datatypes = attr.datatypes;\n    },\n\n    resetMappingIfNeeded: function() {\n        // If inputs were only mapped over to preserve\n        // an output just disconnected reset these...\n        if (!this.node.hasConnectedOutputTerminals() && !this.node.hasConnectedMappedInputTerminals()) {\n            _.each(this.node.mappedInputTerminals(), mappedInput => {\n                mappedInput.resetMappingIfNeeded();\n            });\n        }\n\n        var noMappedInputs = !this.node.hasMappedOverInputTerminals();\n        if (noMappedInputs) {\n            this.resetMapping();\n        }\n    },\n\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n        _.each(this.connectors, connector => {\n            var connectedInput = connector.handle2;\n            if (connectedInput) {\n                // Not exactly right because this is still connected.\n                // Either rewrite resetMappingIfNeeded or disconnect\n                // and reconnect if valid.\n                connectedInput.resetMappingIfNeeded();\n                connector.destroyIfInvalid();\n            }\n        });\n    }\n});\n\nvar BaseInputTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.update(attr.input); // subclasses should implement this...\n    },\n    canAccept: function(other) {\n        if (this._inputFilled()) {\n            return false;\n        } else {\n            return this.attachable(other);\n        }\n    },\n    resetMappingIfNeeded: function() {\n        var mapOver = this.mapOver();\n        if (!mapOver.isCollection) {\n            return;\n        }\n        // No output terminals are counting on this being mapped\n        // over if connected inputs are still mapped over or if none\n        // of the outputs are connected...\n        var reset = this.node.hasConnectedMappedInputTerminals() || !this.node.hasConnectedOutputTerminals();\n        if (reset) {\n            this.resetMapping();\n        }\n    },\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n        if (!this.node.hasMappedOverInputTerminals()) {\n            _.each(this.node.output_terminals, terminal => {\n                // This shouldn't be called if there are mapped over\n                // outputs.\n                terminal.resetMapping();\n            });\n        }\n    },\n    connected: function() {\n        return this.connectors.length !== 0;\n    },\n    _inputFilled: function() {\n        var inputFilled;\n        if (!this.connected()) {\n            inputFilled = false;\n        } else {\n            if (this.multiple) {\n                if (this._collectionAttached()) {\n                    // Can only attach one collection to multiple input\n                    // data parameter.\n                    inputsFilled = true;\n                } else {\n                    inputFilled = false;\n                }\n            } else {\n                inputFilled = true;\n            }\n        }\n        return inputFilled;\n    },\n    _collectionAttached: function() {\n        if (!this.connected()) {\n            return false;\n        } else {\n            var firstOutput = this.connectors[0].handle1;\n            if (!firstOutput) {\n                return false;\n            } else {\n                if (\n                    firstOutput.isCollection ||\n                    firstOutput.isMappedOver() ||\n                    firstOutput.datatypes.indexOf(\"input_collection\") > 0\n                ) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        }\n    },\n    _mappingConstraints: function() {\n        // If this is a connected terminal, return list of collection types\n        // other terminals connected to node are constraining mapping to.\n        if (!this.node) {\n            return []; // No node - completely unconstrained\n        }\n        var mapOver = this.mapOver();\n        if (mapOver.isCollection) {\n            return [mapOver];\n        }\n\n        var constraints = [];\n        if (!this.node.hasConnectedOutputTerminals()) {\n            _.each(this.node.connectedMappedInputTerminals(), inputTerminal => {\n                constraints.push(inputTerminal.mapOver());\n            });\n        } else {\n            // All outputs should have same mapOver status - least specific.\n            constraints.push(_.first(_.values(this.node.output_terminals)).mapOver());\n        }\n        return constraints;\n    },\n    _producesAcceptableDatatype: function(other) {\n        // other is a non-collection output...\n        for (var t in this.datatypes) {\n            var thisDatatype = this.datatypes[t];\n            if (thisDatatype == \"input\") {\n                return true;\n            }\n            var cat_outputs = new Array();\n            cat_outputs = cat_outputs.concat(other.datatypes);\n            if (other.node.post_job_actions) {\n                for (var pja_i in other.node.post_job_actions) {\n                    var pja = other.node.post_job_actions[pja_i];\n                    if (\n                        pja.action_type == \"ChangeDatatypeAction\" &&\n                        (pja.output_name == \"\" || pja.output_name == other.name) &&\n                        pja.action_arguments\n                    ) {\n                        cat_outputs.push(pja.action_arguments[\"newtype\"]);\n                    }\n                }\n            }\n            // FIXME: No idea what to do about case when datatype is 'input'\n            for (var other_datatype_i in cat_outputs) {\n                var other_datatype = cat_outputs[other_datatype_i];\n                if (\n                    other_datatype == \"input\" ||\n                    other_datatype == \"_sniff_\" ||\n                    other_datatype == \"input_collection\" ||\n                    window.workflow_globals.app.isSubType(cat_outputs[other_datatype_i], thisDatatype)\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    },\n    _otherCollectionType: function(other) {\n        var otherCollectionType = NULL_COLLECTION_TYPE_DESCRIPTION;\n        if (other.isCollection) {\n            otherCollectionType = other.collectionType;\n        }\n        var otherMapOver = other.mapOver();\n        if (otherMapOver.isCollection) {\n            otherCollectionType = otherMapOver.append(otherCollectionType);\n        }\n        return otherCollectionType;\n    }\n});\n\nvar InputTerminal = BaseInputTerminal.extend({\n    update: function(input) {\n        this.datatypes = input.extensions;\n        this.multiple = input.multiple;\n        this.collection = false;\n    },\n    connect: function(connector) {\n        BaseInputTerminal.prototype.connect.call(this, connector);\n        var other_output = connector.handle1;\n        if (!other_output) {\n            return;\n        }\n        var otherCollectionType = this._otherCollectionType(other_output);\n        if (otherCollectionType.isCollection) {\n            this.setMapOver(otherCollectionType);\n        }\n    },\n    attachable: function(other) {\n        var otherCollectionType = this._otherCollectionType(other);\n        var thisMapOver = this.mapOver();\n        if (otherCollectionType.isCollection) {\n            if (this.multiple) {\n                if (this.connected() && !this._collectionAttached()) {\n                    // if single inputs attached, cannot also attach a\n                    // collection (yet...)\n                    return false;\n                }\n                if (otherCollectionType.rank == 1) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    // TODO: Allow subcollection mapping over this as if it were\n                    // a list collection input.\n                    return false;\n                }\n            }\n            if (thisMapOver.isCollection && thisMapOver.canMatch(otherCollectionType)) {\n                return this._producesAcceptableDatatype(other);\n            } else {\n                //  Need to check if this would break constraints...\n                var mappingConstraints = this._mappingConstraints();\n                if (mappingConstraints.every(_.bind(otherCollectionType.canMatch, otherCollectionType))) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    return false;\n                }\n            }\n        } else if (thisMapOver.isCollection) {\n            // Attempting to match a non-collection output to an\n            // explicitly collection input.\n            return false;\n        }\n        return this._producesAcceptableDatatype(other);\n    }\n});\n\nvar InputCollectionTerminal = BaseInputTerminal.extend({\n    update: function(input) {\n        this.multiple = false;\n        this.collection = true;\n        this.datatypes = input.extensions;\n        var collectionTypes = [];\n        if (input.collection_types) {\n            _.each(input.collection_types, collectionType => {\n                collectionTypes.push(new CollectionTypeDescription(collectionType));\n            });\n        } else {\n            collectionTypes.push(ANY_COLLECTION_TYPE_DESCRIPTION);\n        }\n        this.collectionTypes = collectionTypes;\n    },\n    connect: function(connector) {\n        BaseInputTerminal.prototype.connect.call(this, connector);\n        var other = connector.handle1;\n        if (!other) {\n            return;\n        }\n\n        var effectiveMapOver = this._effectiveMapOver(other);\n        this.setMapOver(effectiveMapOver);\n    },\n    _effectiveMapOver: function(other) {\n        var collectionTypes = this.collectionTypes;\n        var otherCollectionType = this._otherCollectionType(other);\n        var canMatch = _.some(collectionTypes, collectionType => collectionType.canMatch(otherCollectionType));\n\n        if (!canMatch) {\n            for (var collectionTypeIndex in collectionTypes) {\n                var collectionType = collectionTypes[collectionTypeIndex];\n                if (otherCollectionType.canMapOver(collectionType)) {\n                    var effectiveMapOver = otherCollectionType.effectiveMapOver(collectionType);\n                    if (effectiveMapOver != NULL_COLLECTION_TYPE_DESCRIPTION) {\n                        return effectiveMapOver;\n                    }\n                }\n            }\n        }\n        return NULL_COLLECTION_TYPE_DESCRIPTION;\n    },\n    _effectiveCollectionTypes: function() {\n        var thisMapOver = this.mapOver();\n        return _.map(this.collectionTypes, t => thisMapOver.append(t));\n    },\n    attachable: function(other) {\n        var otherCollectionType = this._otherCollectionType(other);\n        if (otherCollectionType.isCollection) {\n            var effectiveCollectionTypes = this._effectiveCollectionTypes();\n            var thisMapOver = this.mapOver();\n            var canMatch = _.some(effectiveCollectionTypes, effectiveCollectionType =>\n                effectiveCollectionType.canMatch(otherCollectionType)\n            );\n            if (canMatch) {\n                // Only way a direct match...\n                return this._producesAcceptableDatatype(other);\n                // Otherwise we need to mapOver\n            } else if (thisMapOver.isCollection) {\n                // In this case, mapOver already set and we didn't match skipping...\n                return false;\n            } else if (_.some(this.collectionTypes, collectionType => otherCollectionType.canMapOver(collectionType))) {\n                var effectiveMapOver = this._effectiveMapOver(other);\n                if (!effectiveMapOver.isCollection) {\n                    return false;\n                }\n                //  Need to check if this would break constraints...\n                var mappingConstraints = this._mappingConstraints();\n                if (mappingConstraints.every(effectiveMapOver.canMatch)) {\n                    return this._producesAcceptableDatatype(other);\n                }\n            }\n        }\n        return false;\n    }\n});\n\nvar OutputCollectionTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.datatypes = attr.datatypes;\n        if (attr.collection_type) {\n            this.collectionType = new CollectionTypeDescription(attr.collection_type);\n        } else {\n            var collectionTypeSource = attr.collection_type_source;\n            if (!collectionTypeSource) {\n                console.log(\"Warning: No collection type or collection type source defined.\");\n            }\n            this.collectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n        }\n        this.isCollection = true;\n    },\n    update: function(output) {\n        var newCollectionType;\n        if (output.collection_type) {\n            newCollectionType = new CollectionTypeDescription(output.collection_type);\n        } else {\n            var collectionTypeSource = output.collection_type_source;\n            if (!collectionTypeSource) {\n                console.log(\"Warning: No collection type or collection type source defined.\");\n            }\n            newCollectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n        }\n\n        if (newCollectionType.collectionType != this.collectionType.collectionType) {\n            _.each(this.connectors, connector => {\n                // TODO: consider checking if connection valid before removing...\n                connector.destroy();\n            });\n        }\n        this.collectionType = newCollectionType;\n    }\n});\n\nexport default {\n    InputTerminal: InputTerminal,\n    OutputTerminal: OutputTerminal,\n    InputCollectionTerminal: InputCollectionTerminal,\n    OutputCollectionTerminal: OutputCollectionTerminal,\n    TerminalMapping: TerminalMapping,\n\n    // test export\n    CollectionTypeDescription: CollectionTypeDescription,\n    NULL_COLLECTION_TYPE_DESCRIPTION: NULL_COLLECTION_TYPE_DESCRIPTION,\n    ANY_COLLECTION_TYPE_DESCRIPTION: ANY_COLLECTION_TYPE_DESCRIPTION\n};\n"]}