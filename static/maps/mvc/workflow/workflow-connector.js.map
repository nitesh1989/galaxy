{"version":3,"sources":["mvc/workflow/workflow-connector.js"],"names":["Connector","handle1","handle2","this","canvas","dragging","inner_color","outer_color","$","extend","connect","t2","prototype","destroy","disconnect","destroyIfInvalid","attachable","redraw","createElement","canvas_container","append","style","zIndex","relativeLeft","e","document","offset","left","top","start_x","start_y","relativeTop","end_x","element","end_y","canvas_min_x","min","canvas_max_x","Math","max","canvas_min_y","canvas_max_y","cp_shift","canvas_left","canvas_top","canvas_width","canvas_height","setAttribute","start_offsets","isMappedOver","num_offsets","end_offsets","i","inner_width","outer_width","length","connector","draw_outlined_curve","c","offset_start","offset_end","lineWidth","beginPath","bezierCurveTo","moveTo","stroke","strokeStyle"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-connector.js","sourcesContent":["function Connector(handle1, handle2) {\n    this.canvas = null;\n    this.dragging = false;\n    this.inner_color = \"#FFFFFF\";\n    this.outer_color = \"#D8B365\";\n    if (handle1 && handle2) {\n        this.connect(handle1, handle2);\n    }\n}\n$.extend(Connector.prototype, {\n    connect: function(t1, t2) {\n        this.handle1 = t1;\n        if (this.handle1) {\n            this.handle1.connect(this);\n        }\n        this.handle2 = t2;\n        if (this.handle2) {\n            this.handle2.connect(this);\n        }\n    },\n    destroy: function() {\n        if (this.handle1) {\n            this.handle1.disconnect(this);\n        }\n        if (this.handle2) {\n            this.handle2.disconnect(this);\n        }\n        $(this.canvas).remove();\n    },\n    destroyIfInvalid: function() {\n        if (this.handle1 && this.handle2 && !this.handle2.attachable(this.handle1)) {\n            this.destroy();\n        }\n    },\n    redraw: function() {\n        var canvas_container = $(\"#canvas-container\");\n        if (!this.canvas) {\n            this.canvas = document.createElement(\"canvas\");\n            canvas_container.append($(this.canvas));\n            if (this.dragging) {\n                this.canvas.style.zIndex = \"300\";\n            }\n        }\n        var relativeLeft = e => $(e).offset().left - canvas_container.offset().left;\n        var relativeTop = e => $(e).offset().top - canvas_container.offset().top;\n        if (!this.handle1 || !this.handle2) {\n            return;\n        }\n        // Find the position of each handle\n        var start_x = relativeLeft(this.handle1.element) + 5;\n        var start_y = relativeTop(this.handle1.element) + 5;\n        var end_x = relativeLeft(this.handle2.element) + 5;\n        var end_y = relativeTop(this.handle2.element) + 5;\n        // Calculate canvas area\n        var canvas_extra = 100;\n        var canvas_min_x = Math.min(start_x, end_x);\n        var canvas_max_x = Math.max(start_x, end_x);\n        var canvas_min_y = Math.min(start_y, end_y);\n        var canvas_max_y = Math.max(start_y, end_y);\n        var cp_shift = Math.min(Math.max(Math.abs(canvas_max_y - canvas_min_y) / 2, 100), 300);\n        var canvas_left = canvas_min_x - canvas_extra;\n        var canvas_top = canvas_min_y - canvas_extra;\n        var canvas_width = canvas_max_x - canvas_min_x + 2 * canvas_extra;\n        var canvas_height = canvas_max_y - canvas_min_y + 2 * canvas_extra;\n        // Place the canvas\n        this.canvas.style.left = `${canvas_left}px`;\n        this.canvas.style.top = `${canvas_top}px`;\n        this.canvas.setAttribute(\"width\", canvas_width);\n        this.canvas.setAttribute(\"height\", canvas_height);\n        // Adjust points to be relative to the canvas\n        start_x -= canvas_left;\n        start_y -= canvas_top;\n        end_x -= canvas_left;\n        end_y -= canvas_top;\n\n        // Draw the line\n\n        var c = this.canvas.getContext(\"2d\");\n\n        var start_offsets = null;\n        var end_offsets = null;\n        var num_offsets = 1;\n        if (this.handle1 && this.handle1.isMappedOver()) {\n            var start_offsets = [-6, -3, 0, 3, 6];\n            num_offsets = 5;\n        } else {\n            var start_offsets = [0];\n        }\n        if (this.handle2 && this.handle2.isMappedOver()) {\n            var end_offsets = [-6, -3, 0, 3, 6];\n            num_offsets = 5;\n        } else {\n            var end_offsets = [0];\n        }\n        var connector = this;\n        for (var i = 0; i < num_offsets; i++) {\n            var inner_width = 5;\n            var outer_width = 7;\n            if (start_offsets.length > 1 || end_offsets.length > 1) {\n                // We have a multi-run, using many lines, make them small.\n                inner_width = 1;\n                outer_width = 3;\n            }\n            connector.draw_outlined_curve(\n                start_x,\n                start_y,\n                end_x,\n                end_y,\n                cp_shift,\n                inner_width,\n                outer_width,\n                start_offsets[i % start_offsets.length],\n                end_offsets[i % end_offsets.length]\n            );\n        }\n    },\n    draw_outlined_curve: function(\n        start_x,\n        start_y,\n        end_x,\n        end_y,\n        cp_shift,\n        inner_width,\n        outer_width,\n        offset_start,\n        offset_end\n    ) {\n        var offset_start = offset_start || 0;\n        var offset_end = offset_end || 0;\n        var c = this.canvas.getContext(\"2d\");\n        c.lineCap = \"round\";\n        c.strokeStyle = this.outer_color;\n        c.lineWidth = outer_width;\n        c.beginPath();\n        c.moveTo(start_x, start_y + offset_start);\n        c.bezierCurveTo(\n            start_x + cp_shift,\n            start_y + offset_start,\n            end_x - cp_shift,\n            end_y + offset_end,\n            end_x,\n            end_y + offset_end\n        );\n        c.stroke();\n        // Inner line\n        c.strokeStyle = this.inner_color;\n        c.lineWidth = inner_width;\n        c.beginPath();\n        c.moveTo(start_x, start_y + offset_start);\n        c.bezierCurveTo(\n            start_x + cp_shift,\n            start_y + offset_start,\n            end_x - cp_shift,\n            end_y + offset_end,\n            end_x,\n            end_y + offset_end\n        );\n        c.stroke();\n    }\n});\nexport default Connector;\n"]}