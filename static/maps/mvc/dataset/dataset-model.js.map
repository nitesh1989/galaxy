{"version":3,"sources":["mvc/dataset/dataset-model.js"],"names":["searchableMixin","_baseMvc2","default","SearchableModelMixin","DatasetAssociation","Backbone","Model","extend","LoggableMixin","mixin","_logNamespace","defaults","logNamespace","_states2","NEW","deleted","name","accessible","data_type","file_size","meta_files","state","initialize","attributes","options","this","misc_info","get","set","NOT_VIEWABLE","urls","_generateUrls","_setUpListeners","id","purge","edit","_downloadQueryParameters","report_error","rerun","show_params","display","_","each","value","key","Galaxy","root","on","currModel","newState","log","inReadyState","trigger","previous","toJSON","json","prototype","call","isDeletedOrPurged","ready","has","hasData","fetch","dataset","always","response","parsed","parse","create_time","Date","update_time","save","attrs","wait","delete","jQuery","when","isUndefined","undelete","hda","xhr","ajax","done","_purge","responseObj","purged","fail","message","url","error","responseJSON","responseText","indexOf","_localization2","messageBuriedInUnfortunatelyFormattedError","searchAliases","title","format","database","blurb","description","searchAttributes","tag","nameAndId","DatasetAssociationCollection","Collection","model","urlRoot","ids","map","item","notReady","filter","content","haveDetails","all","hasDetails","ajaxQueue","ajaxFn","Deferred","startingLength","length","responses","deferred","resolve","ajaxFns","chain","reverse","i","total","shift","matches","matchesWhat","toString","join"],"mappings":"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","file":"../../../scripts/mvc/dataset/dataset-model.js","sourcesContent":["import STATES from \"mvc/dataset/states\";\nimport BASE_MVC from \"mvc/base-mvc\";\nimport _l from \"utils/localization\";\n\nvar logNamespace = \"dataset\";\n//==============================================================================\nvar searchableMixin = BASE_MVC.SearchableModelMixin;\n/** @class base model for any DatasetAssociation (HDAs, LDDAs, DatasetCollectionDAs).\n *      No knowledge of what type (HDA/LDDA/DCDA) should be needed here.\n *  The DA's are made searchable (by attribute) by mixing in SearchableModelMixin.\n */\nvar DatasetAssociation = Backbone.Model.extend(BASE_MVC.LoggableMixin).extend(\n    BASE_MVC.mixin(\n        searchableMixin,\n        /** @lends DatasetAssociation.prototype */ {\n            _logNamespace: logNamespace,\n\n            /** default attributes for a model */\n            defaults: {\n                state: STATES.NEW,\n                deleted: false,\n                purged: false,\n                name: \"(unnamed dataset)\",\n                accessible: true,\n                // sniffed datatype (sam, tabular, bed, etc.)\n                data_type: \"\",\n                file_ext: \"\",\n                file_size: 0,\n\n                // array of associated file types (eg. [ 'bam_index', ... ])\n                meta_files: [],\n\n                misc_blurb: \"\",\n                misc_info: \"\",\n\n                tags: []\n                // do NOT default on annotation, as this default is valid and will be passed on 'save'\n                //  which is incorrect behavior when the model is only partially fetched (annos are not passed in summary data)\n                //annotation          : ''\n            },\n\n            /** instance vars and listeners */\n            initialize: function(attributes, options) {\n                this.debug(`${this}(Dataset).initialize`, attributes, options);\n\n                //!! this state is not in trans.app.model.Dataset.states - set it here -\n                if (!this.get(\"accessible\")) {\n                    this.set(\"state\", STATES.NOT_VIEWABLE);\n                }\n\n                /** Datasets rely/use some web controllers - have the model generate those URLs on startup */\n                this.urls = this._generateUrls();\n\n                this._setUpListeners();\n            },\n\n            /** returns misc. web urls for rendering things like re-run, display, etc. */\n            _generateUrls: function() {\n                var id = this.get(\"id\");\n                if (!id) {\n                    return {};\n                }\n                var urls = {\n                    purge: `datasets/${id}/purge_async`,\n                    display: `datasets/${id}/display/?preview=True`,\n                    edit: `datasets/edit?dataset_id=${id}`,\n                    download: `datasets/${id}/display${this._downloadQueryParameters()}`,\n                    report_error: `dataset/errors?id=${id}`,\n                    rerun: `tool_runner/rerun?id=${id}`,\n                    show_params: `datasets/${id}/show_params`,\n                    visualization: \"visualization\",\n                    meta_download: `dataset/get_metadata_file?hda_id=${id}&metadata_name=`\n                };\n                _.each(urls, (value, key) => {\n                    urls[key] = Galaxy.root + value;\n                });\n                this.urls = urls;\n                return urls;\n            },\n\n            _downloadQueryParameters: function() {\n                return `?to_ext=${this.get(\"file_ext\")}`;\n            },\n\n            /** set up any event listeners\n     *  event: state:ready  fired when this DA moves into/is already in a ready state\n     */\n            _setUpListeners: function() {\n                // if the state has changed and the new state is a ready state, fire an event\n                this.on(\"change:state\", function(currModel, newState) {\n                    this.log(`${this} has changed state:`, currModel, newState);\n                    if (this.inReadyState()) {\n                        this.trigger(\"state:ready\", currModel, newState, this.previous(\"state\"));\n                    }\n                });\n                // the download url (currently) relies on having a correct file extension\n                this.on(\"change:id change:file_ext\", function(currModel) {\n                    this._generateUrls();\n                });\n            },\n\n            // ........................................................................ common queries\n            /** override to add urls */\n            toJSON: function() {\n                var json = Backbone.Model.prototype.toJSON.call(this);\n                //console.warn( 'returning json?' );\n                //return json;\n                return _.extend(json, {\n                    urls: this.urls\n                });\n            },\n\n            /** Is this dataset deleted or purged? */\n            isDeletedOrPurged: function() {\n                return this.get(\"deleted\") || this.get(\"purged\");\n            },\n\n            /** Is this dataset in a 'ready' state; where 'Ready' states are states where no\n     *      processing (for the ds) is left to do on the server.\n     */\n            inReadyState: function() {\n                var ready = _.contains(STATES.READY_STATES, this.get(\"state\"));\n                return this.isDeletedOrPurged() || ready;\n            },\n\n            /** Does this model already contain detailed data (as opposed to just summary level data)? */\n            hasDetails: function() {\n                // if it's inaccessible assume it has everything it needs\n                if (!this.get(\"accessible\")) {\n                    return true;\n                }\n                return this.has(\"annotation\");\n            },\n\n            /** Convenience function to match dataset.has_data. */\n            hasData: function() {\n                return this.get(\"file_size\") > 0;\n            },\n\n            // ........................................................................ ajax\n            fetch: function(options) {\n                var dataset = this;\n                return Backbone.Model.prototype.fetch.call(this, options).always(() => {\n                    dataset._generateUrls();\n                });\n            },\n\n            /** override to use actual Dates objects for create/update times */\n            parse: function(response, options) {\n                var parsed = Backbone.Model.prototype.parse.call(this, response, options);\n                if (parsed.create_time) {\n                    parsed.create_time = new Date(parsed.create_time);\n                }\n                if (parsed.update_time) {\n                    parsed.update_time = new Date(parsed.update_time);\n                }\n                return parsed;\n            },\n\n            /** override to wait by default */\n            save: function(attrs, options) {\n                options = options || {};\n                options.wait = _.isUndefined(options.wait) ? true : options.wait;\n                return Backbone.Model.prototype.save.call(this, attrs, options);\n            },\n\n            //NOTE: subclasses of DA's will need to implement url and urlRoot in order to have these work properly\n            /** save this dataset, _Mark_ing it as deleted (just a flag) */\n            delete: function(options) {\n                if (this.get(\"deleted\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: true }, options);\n            },\n            /** save this dataset, _Mark_ing it as undeleted */\n            undelete: function(options) {\n                if (!this.get(\"deleted\") || this.get(\"purged\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: false }, options);\n            },\n\n            /** remove the file behind this dataset from the filesystem (if permitted) */\n            purge: function _purge(options) {\n                //TODO: use, override model.destroy, HDA.delete({ purge: true })\n                if (this.get(\"purged\")) {\n                    return jQuery.when();\n                }\n                options = options || {};\n                options.url = this.urls.purge;\n\n                //TODO: ideally this would be a DELETE call to the api\n                //  using purge async for now\n                var hda = this;\n\n                var xhr = jQuery.ajax(options);\n                xhr.done((message, status, responseObj) => {\n                    hda.set({ deleted: true, purged: true });\n                });\n                xhr.fail((xhr, status, message) => {\n                    // Exception messages are hidden within error page including:  '...not allowed in this Galaxy instance.'\n                    // unbury and re-add to xhr\n                    var error = _l(\"Unable to purge dataset\");\n                    var messageBuriedInUnfortunatelyFormattedError =\n                        \"Removal of datasets by users \" + \"is not allowed in this Galaxy instance\";\n                    if (xhr.responseJSON && xhr.responseJSON.error) {\n                        error = xhr.responseJSON.error;\n                    } else if (xhr.responseText.indexOf(messageBuriedInUnfortunatelyFormattedError) !== -1) {\n                        error = messageBuriedInUnfortunatelyFormattedError;\n                    }\n                    xhr.responseText = error;\n                    hda.trigger(\"error\", hda, xhr, options, _l(error), {\n                        error: error\n                    });\n                });\n                return xhr;\n            },\n\n            // ........................................................................ searching\n            /** what attributes of an HDA will be used in a text search */\n            searchAttributes: [\"name\", \"file_ext\", \"genome_build\", \"misc_blurb\", \"misc_info\", \"annotation\", \"tags\"],\n\n            /** our attr keys don't often match the labels we display to the user - so, when using\n     *      attribute specifiers ('name=\"bler\"') in a term, allow passing in aliases for the\n     *      following attr keys.\n     */\n            searchAliases: {\n                title: \"name\",\n                format: \"file_ext\",\n                database: \"genome_build\",\n                blurb: \"misc_blurb\",\n                description: \"misc_blurb\",\n                info: \"misc_info\",\n                tag: \"tags\"\n            },\n\n            // ........................................................................ misc\n            /** String representation */\n            toString: function() {\n                var nameAndId = this.get(\"id\") || \"\";\n                if (this.get(\"name\")) {\n                    nameAndId = `\"${this.get(\"name\")}\",${nameAndId}`;\n                }\n                return `Dataset(${nameAndId})`;\n            }\n        }\n    )\n);\n\n//==============================================================================\n/** @class Backbone collection for dataset associations.\n */\nvar DatasetAssociationCollection = Backbone.Collection.extend(BASE_MVC.LoggableMixin).extend(\n    /** @lends HistoryContents.prototype */ {\n        _logNamespace: logNamespace,\n\n        model: DatasetAssociation,\n\n        /** root api url */\n        urlRoot: `${Galaxy.root}api/datasets`,\n\n        /** url fn */\n        url: function() {\n            return this.urlRoot;\n        },\n\n        // ........................................................................ common queries\n        /** Get the ids of every item in this collection\n     *  @returns array of encoded ids\n     */\n        ids: function() {\n            return this.map(item => item.get(\"id\"));\n        },\n\n        /** Get contents that are not ready\n     *  @returns array of content models\n     */\n        notReady: function() {\n            return this.filter(content => !content.inReadyState());\n        },\n\n        /** return true if any datasets don't have details */\n        haveDetails: function() {\n            return this.all(dataset => dataset.hasDetails());\n        },\n\n        // ........................................................................ ajax\n        /** using a queue, perform ajaxFn on each of the models in this collection */\n        ajaxQueue: function(ajaxFn, options) {\n            var deferred = jQuery.Deferred();\n            var startingLength = this.length;\n            var responses = [];\n\n            if (!startingLength) {\n                deferred.resolve([]);\n                return deferred;\n            }\n\n            // use reverse order (stylistic choice)\n            var ajaxFns = this.chain()\n                .reverse()\n                .map((dataset, i) => () => {\n                    var xhr = ajaxFn.call(dataset, options);\n                    // if successful, notify using the deferred to allow tracking progress\n                    xhr.done(response => {\n                        deferred.notify({\n                            curr: i,\n                            total: startingLength,\n                            response: response,\n                            model: dataset\n                        });\n                    });\n                    // (regardless of previous error or success) if not last ajax call, shift and call the next\n                    //  if last fn, resolve deferred\n                    xhr.always(response => {\n                        responses.push(response);\n                        if (ajaxFns.length) {\n                            ajaxFns.shift()();\n                        } else {\n                            deferred.resolve(responses);\n                        }\n                    });\n                })\n                .value();\n            // start the queue\n            ajaxFns.shift()();\n\n            return deferred;\n        },\n\n        // ........................................................................ sorting/filtering\n        /** return a new collection of datasets whose attributes contain the substring matchesWhat */\n        matches: function(matchesWhat) {\n            return this.filter(dataset => dataset.matches(matchesWhat));\n        },\n\n        /** String representation. */\n        toString: function() {\n            return [\"DatasetAssociationCollection(\", this.length, \")\"].join(\"\");\n        }\n    }\n);\n\n//==============================================================================\nexport default {\n    DatasetAssociation: DatasetAssociation,\n    DatasetAssociationCollection: DatasetAssociationCollection\n};\n"]}